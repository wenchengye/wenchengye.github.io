---
title: thinking-in-java
catalog: true
subtitle:
header-img:
tags:
---

## 2

* Java中没有unsigned 数值类型(char是unsigned)。
* char是16位的，值域为`\u0000`-`\uffff`。
* Java中浮点数采用IEEE754格式，float的值域为`-2^127`-`2^127`，但只保证24个二进制位的精度(即对于整数而已float只能保证`2^24`以内的数字能精确表示)；double的值域为`-2^1023`-`2^1023`，但只保证53个二进制位的精度。
* `java.lang`这个包会被自动import到源码。
* javadoc中可以使用HTML标签，但不要使用标题标签。

## 3

* Java中指数计数法如：`float a = 1.27e16f`，其中`e`代表10的次方数。
* 0x开头表示16进制数字，0开头表示8进制数字。
* 位操作`&`与、`|`或、`^`异或、`～`非，其中`～`是一元操作符；`&=`、`|=`、`^=`都是合法的。
* 位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为`2^5 = 32`位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。
* 对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。
* break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，`break <label>;`和`continue <label>`有助于跳出多层循环。例如：`label1: while () { while() { break label1;} }`。

## 5

* 当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。
* 可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。
* finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。
* 类的属性的初始化的执行顺序取决于属性定义的顺序。
* 实例初始化，其语法和`static { ... }`类似、但是去掉static关键字；这段代码执行于对象创建之后 & 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些功用的初始化逻辑。
* Java中数组的长度是不可变的(C++难道不是么...)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。
* 在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作*可变参数列表*来传递给方法。
* 不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。

## 6

* 每个类--包括内部类、同一文件中的多个类--都会生成一个单独的.class文件。
* Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。
* 类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。
* 如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。
* 访问权限修饰词也可以用于修饰类。
* 非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此...)。
* 每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。

## 7

* 当对象需要被隐式转换成String时，**编译器**会调用其toString()方法。
* 工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。
* 当创建一个继承类的对象时，这个对象中包含了一个基类的对象。
* 创建继承类时，想要正确的初始化基类，唯一的方法就是调用基类 的某个构造函数：
    - 在不显式调用基类的构造函数的情况下，编译器(应该是编译器负责的)会自动调用基类的默认构造函数(不带参数的)。
    - 编译器合成的默认构造函数也会调用基类的默认构造函数。
    - 如果基类没有默认构造函数，则必须显式的调用基类的构造函数，否则编译器会报错。
    - 显式的调用基类的构造函数(包括带参数的构造函数和默认构造函数)，必须发生在继承类构造函数的第一行，否则会编译报错。
* 继承类对象的引用可以转型成基类对象的引用，这个被称为向上转型。
* final关键字可以修饰数据、方法和类：
    - final修饰属性时，如果属性是类对象，则表示这个引用不可改变，而所被引用的对象是可以改变的；Java没有提供C++的const关键字保证类对象不被改变的机制；注意数组也是类对象也符合类对象的规则。
    - final修饰方法时，保证方法不会再继承类中被覆盖。private方法默认是final的，但其实继承类也看不到它，所以继承类依然可以定义一个与父类private方法同名的新方法。
    - final修饰类时，保证类不会被继承。
* 在某些(早期)的Java实现中，final修饰的方法也起到了C++中inline关键字的作用来优化执行效率，但这导致的代码膨胀反而有时会降低效率；更新的Java虚拟机会探测并消除这种inline，所以无需再把final视为inline的一种方式了。
* 类加载和对象初始化顺序：基类加载 -> 基类静态初始化 -> 继承类加载 -> 继承类静态初始化 -> 将被分配的内存初始化为0 -> 基类对象的属性初始化 -> 基类对象构造函数 -> 继承类对象的属性初始化 -> 继承类对象构造函数。 

## 8

* 将方法调用(函数调用语句)和方法主体(函数所处的内存地址)关联起来的过程叫绑定，绑定包括前期绑定和动态绑定。前期绑定是在编译时发生的，而动态绑定是在运行时根据对象类型来进行的。
* 不同语言实现动态绑定的方式略有不同。
* Java语言中除了static方法和final方法(当然还有private方法，但上一章说过private方法默认是final方法)是采用前期绑定，其他方法都使用的动态绑定。所以final关键字除了防止override之外，还有关闭动态绑定的作用。
* 一种错误是尝试override定义为private的方法。因为private方法是final的，所以override和多态是不会发生的，而实际上发生的是在导出类中多了一个和基类private方法同名的方法。所以通过基类引用调用这个private方法时，调用的是基类函数；通过导出类引用调用时，实际上是调用导出类中的同名方法。从private方法是前期绑定的这个原理上，也很好理解这个行为。
* 在导出类中，尽量不要使用和基类private方法相同的方法名。
* 构造函数自然不会有多态的特性；实际上构造函数应该归类于static方法，虽然它没有static关键字。
* 在上一章介绍了对象的构造顺序；如果需要定一个某种显式的析构(例如release())，其调用顺序应当和构造顺序恰恰相反(就如同C++的析构函数一样)。
* Java在构造函数中调用动态绑定的方法时，动态绑定是起作用的(和C++不同)，也就是说会调用导出类的方法；但要注意，这个时候导出类很可能还没有被构造，这可能会带来一些错误。
* 作者认为C++处理构造函数内动态绑定函数调用的方式更为合理；所以在构造函数中应该尽量避免调用方法，或者只调用private或final方法。
* 从JavaSE5开始，override方法的返回类型，可以是父类中被overrdie方法的返回类型的导出类(有点绕口，但返回值不是函数signature的一部分)。
* 在Java中使用强制类型转换(括号转换)时会进行类型检查(C++不会)，如果例如在向下转型时类型不符合，会抛出ClassCastException。

## 9

* 如果类中包含abstract方法，那么类必须也被声明为abstract的，否则会在编译时报错；但是声明为abstract的类，不是必须包含abstract方法，可能仅仅是像组织该类型实例化。
