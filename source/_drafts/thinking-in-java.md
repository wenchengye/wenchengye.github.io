---
title: thinking-in-java
catalog: true
subtitle:
header-img:
tags:
---

## 2

* Java中没有unsigned 数值类型(char是unsigned)。
* char是16位的，值域为`\u0000`-`\uffff`。
* Java中浮点数采用IEEE754格式，float的值域为`-2^127`-`2^127`，但只保证24个二进制位的精度(即对于整数而言float只能保证`2^24`以内的数字能精确表示)；double的值域为`-2^1023`-`2^1023`，但只保证53个二进制位的精度。
* `java.lang`这个包会被自动import到源码。
* javadoc中可以使用HTML标签，但不要使用标题标签。

## 3

* Java中指数计数法如：`float a = 1.27e16f`，其中`e`代表10的次方数。
* 0x开头表示16进制数字，0开头表示8进制数字。
* 位操作`&`与、`|`或、`^`异或、`～`非，其中`～`是一元操作符；`&=`、`|=`、`^=`都是合法的。
* 位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为`2^5 = 32`位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。
* 对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。
* break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，`break <label>;`和`continue <label>`有助于跳出多层循环。例如：`label1: while () { while() { break label1;} }`。

## 5

* 当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。
* 可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。
* finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。
* 类的属性的初始化的执行顺序取决于属性定义的顺序。
* 实例初始化，其语法和`static { ... }`类似、但是去掉static关键字；这段代码执行于对象创建之后 & 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些公用的初始化逻辑。
* Java中数组的长度是不可变的(C++难道不是么...)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。
* 在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作*可变参数列表*来传递给方法。
* 不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。

## 6

* 每个类--包括内部类、同一文件中的多个类--都会生成一个单独的.class文件。
* Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。
* 类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。
* 如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。
* 访问权限修饰词也可以用于修饰类。
* 非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此...)。
* 每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。

## 7

* 当对象需要被隐式转换成String时，**编译器**会调用其toString()方法。
* 工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。
* 当创建一个继承类的对象时，这个对象中包含了一个基类的对象。
* 创建继承类时，想要正确的初始化基类，唯一的方法就是调用基类 的某个构造函数：
    - 在不显式调用基类的构造函数的情况下，编译器(应该是编译器负责的)会自动调用基类的默认构造函数(不带参数的)。
    - 编译器合成的默认构造函数也会调用基类的默认构造函数。
    - 如果基类没有默认构造函数，则必须显式的调用基类的构造函数，否则编译器会报错。
    - 显式的调用基类的构造函数(包括带参数的构造函数和默认构造函数)，必须发生在继承类构造函数的第一行，否则会编译报错。
* 继承类对象的引用可以转型成基类对象的引用，这个被称为向上转型。
* final关键字可以修饰数据、方法和类：
    - final修饰属性时，如果属性是类对象，则表示这个引用不可改变，而所被引用的对象是可以改变的；Java没有提供C++的const关键字保证类对象不被改变的机制；注意数组也是类对象也符合类对象的规则。
    - final修饰方法时，保证方法不会再继承类中被覆盖。private方法默认是final的，但其实继承类也看不到它，所以继承类依然可以定义一个与父类private方法同名的新方法。
    - final修饰类时，保证类不会被继承。
* 在某些(早期)的Java实现中，final修饰的方法也起到了C++中inline关键字的作用来优化执行效率，但这导致的代码膨胀反而有时会降低效率；更新的Java虚拟机会探测并消除这种inline，所以无需再把final视为inline的一种方式了。
* 类加载和对象初始化顺序：基类加载 -> 基类静态初始化 -> 继承类加载 -> 继承类静态初始化 -> 将被分配的内存初始化为0 -> 基类对象的属性初始化 -> 基类对象构造函数 -> 继承类对象的属性初始化 -> 继承类对象构造函数。 

## 8

* 将方法调用(函数调用语句)和方法主体(函数所处的内存地址)关联起来的过程叫绑定，绑定包括前期绑定和动态绑定。前期绑定是在编译时发生的，而动态绑定是在运行时根据对象类型来进行的。
* 不同语言实现动态绑定的方式略有不同。
* Java语言中除了static方法和final方法(当然还有private方法，但上一章说过private方法默认是final方法)是采用前期绑定，其他方法都使用的动态绑定。所以final关键字除了防止override之外，还有关闭动态绑定的作用。
* 一种错误是尝试override定义为private的方法。因为private方法是final的，所以override和多态是不会发生的，而实际上发生的是在导出类中多了一个和基类private方法同名的方法。所以通过基类引用调用这个private方法时，调用的是基类函数；通过导出类引用调用时，实际上是调用导出类中的同名方法。从private方法是前期绑定的这个原理上，也很好理解这个行为。
* 在导出类中，尽量不要使用和基类private方法相同的方法名。
* 构造函数自然不会有多态的特性；实际上构造函数应该归类于static方法，虽然它没有static关键字。
* 在上一章介绍了对象的构造顺序；如果需要定一个某种显式的析构(例如release())，其调用顺序应当和构造顺序恰恰相反(就如同C++的析构函数一样)。
* Java在构造函数中调用动态绑定的方法时，动态绑定是起作用的(和C++不同)，也就是说会调用导出类的方法；但要注意，这个时候导出类很可能还没有被构造，这可能会带来一些错误。
* 作者认为C++处理构造函数内动态绑定函数调用的方式更为合理；所以在构造函数中应该尽量避免调用方法，或者只调用private或final方法。
* 从JavaSE5开始，override方法的返回类型，可以是父类中被override方法的返回类型的导出类(有点绕口，但返回值不是函数signature的一部分)。
* 在Java中使用强制类型转换(括号转换)时会进行类型检查(C++不会)，如果例如在向下转型时类型不符合，会抛出ClassCastException。

## 9

* 如果类中包含abstract方法，那么类必须也被声明为abstract的，否则会在编译时报错；但是声明为abstract的类，不是必须包含abstract方法，可能仅仅是想阻止该类型实例化。
* interface自身的访问控制和class一样，可以用public修饰或者不加修饰(包访问权限)；interface的属性默认是static且final的；interface的方法默认是public的。
* 在Java继承中，导出类override的方法的访问权限必须大于等于父类中相同方法的访问权限(override某个public方法时，覆盖实现的方法也必须是public的)。
* 当extends和implements同时作用于一个类时，extends必须写在前面。
* 接口是用来建立类与类直接的方法调用协议。
* Java的抽象类只能单根继承；相对于抽象类而言，接口还提供的部分多重继承的特性，从而比抽象类更灵活。
* 在定义基类时应该优先考虑接口，其次才是抽象类。
* 与类的单根继承不同，接口可以extends多个接口。
* 在多重继承的过程中(基类和接口)，如果遇到两个方法签名相同但是返回值不同，会发生编译错误。
* 接口也很适合用来声明大量常量；在Java5推出enum之前，接口被用作enum的替代品来声明常量。
* 接口可以声明在类内部，类内部的接口还可以是private的(除了public和包访问权限外)；接口也可能声明在接口内部，接口内部的接口默认是public的。

## 10

* 非静态内部类可以访问其外围类的*一切*元素，与C++不同(C++的内部类只有命名空间的作用)。
* 如果想在"非静态内部类的主人(外围类)"以外的地方创建非静态内部类的实例，可以使用"外围类实例.new"这样的语法；例如`A a = new A();A.Inner inner = a.new Inner();`。(注意构造函数无需用`A.Inner()`,事实上这样用编译不过)
* 可以在方法中或者方法的某个作用域中(大括号包裹的范围)定义类，那么这个类的可见性就限制在方法或作用域内部；这样的定义的类不能用访问控制关键字修饰。如果类被定义在静态方法中，那就是静态内部类；如果被定义在成员方法中，那就是非静态内部类，即内部类。
* 匿名内部类可以继承基类或者实现接口，但是只能在继承类和实现接口之间二选一，并且不能继承多个接口。
* 匿名内部类只具有默认构造函数，但不能定义自己的构造函数；可以使用实例静代码块(非静态代码块)来实现类似构造函数的效果。
* 内部类不能具有static属性，也不能包含嵌套类，但是嵌套类可以有static属性和包含嵌套类。
* 可以在接口中定义内部类，接口中的内部类默认是public和static的，即公共嵌套类；这是在接口中包含一些代码实现的方式。
* 无论内部类被嵌套多少层，它都能访问所有外围类的所有成员。多层嵌套的内部类可以用`Father.A.B var = fatherinstance.new B()`这样的语法创建。
* 内部类作为外围类的一部分，某种程度上给了外围类一种多重继承的能力，即用多个内部类继承多个抽象类。
* 如果想让某个独立的类例如 A 类继承其他某个类的内部类例如 B.C ，那么 A 类的构造函数需要如下语法才能通过编译`class A extends B.C {  A(B b) { b.super() } }`。这个一个奇怪的语法。
* 不存在继承外围类并override内部类的语法，例如有内部类A.B，C继承A并声明内部类C.B，那么A.B和C.B是两个命名空间中的两个不相关的类(除了名字相同)，不存在override关系。

## 11

* Arrays.asList()方法返回的List长度时不可变的，对这个List调用add()或remove()都会抛出异常。
* HashSet是不保证顺序的，LinkedHashSet按照插入顺序保存，TreeSet按照比较结果升序保存；同样的HashMap是不保证顺序的，LinkedHashMap按照插入顺序保存，TreeMap按照比较结果升序保存。Hash*存取都是最快的，LinkedHash*取几乎和Hask*一样快。
* 迭代器设计的初衷，是为了以统一的方式遍历所有容器，这样即使容易类型发生的改变，遍历相关的代码也无需修改。
* List.listIterator()返回ListIterator，ListIterator是Iterator的子类型。ListIterator支持双向移动，而Iterator不行。
* LinkedList实现的Queue接口（实际上是Deque接口，Deque extends from Queue)。
* foreach语法之所以能作用于容器是因为Collection扩展了Iterable接口。foreach可以作用于任何实现了Iterable的类型和数组，但这不意味数组是Iterable或会被自动转型成Iterable。
* **不要使用**Java1.0中提供的Vector、Hashtable、Stack这几个容器。

## 12

* 发现程序错误的最理想时机是编译时。
* 所有标准异常类都包含以字符串为参数的构造函数，字符串代表了异常信息的描述。
* 任何继承自 Throwable 的对象可以被作为异常抛出；异常信息通常经由异常类的类名体现，或者将更详细的异常信息保存在异常内部。
* `Exception.printStackTrace()` 有带参数的版本，用于指定输出流。
* `Throwable.fillInStackTrace()` 可以记录栈帧的当前状态。
* `Throwable` 的 stackTace 中保存了一个数据，代表一个出错的调用栈，每个元素表示栈中的一帧。
* 除了 RuntimeExcetion 及其子类，其他类型的异常都是由编译器强制约束需要被捕获的；RuntimeException 往往代表的是编程错误，比如错误的调用参数。
* C++ 没有 finally 结构，C++ 依赖析构函数实现类似的效果；在 try 块中无论执行 return、break、continue 等任何语句，finall 代码块都会被执行。
* Java 在设计时有缺陷，某些写法会造成异常丢失，例如在 finally 里面再次抛出异常或者执行 return 语句都会似的原本抛出的异常无法被开发者和外层代码发现（除非单步调试）。相比之下，C++ 禁止在一个异常还没处理完毕之前，抛出另一个异常。
* 当函数的异常说明列表遇到 override 时，总体规则就是 override 方法的异常说明列表需要是基类异常说明列表的子集（通俗来说，就是在继承和 override 的过程中，异常说明列表只能越变越小）;但是构造函数是个特例，子类构造函数的异常说明列表需要时父类构造函数的异常说明列表的超集，同时在子类构造函数中不能捕获父类构造函数抛出的异常。
* override 方法可以抛出父类方法异常列表中某个异常的子类。
* 函数签名只包括函数名和参数列表，而不包含异常列表，所以不是只改变异常列表来重载方法。
* 如果构造函数包含会抛出异常的代码，需要很仔细的处理，只是捕获异常可能会导致对象构造的不完整；尽量不要让构造函数包含会抛出异常的代码。
* 作者并不喜欢 checked exception，因为强制开发者处理自己不了解的异常，可能会导致最后吞掉异常；提到了一种通用的处理方法，捕获 checked exception 然后用其创建 RuntimeException 再抛出，但这种方法也不应该滥用。

13
* 编译器会将连续的字符串 '+' 操作符优化为 StringBuilder，以防止反复创建字符串对象；不过当有循环调用时，也会反复创建 StringBuilder 对象，所以这时不要依赖编译器优化，自己创建 StringBuilder 来处理。
* 当对象引用和字符串做 '+' 操作符时，会自动调用对象的的 `toString()` 方法。
* 格式化输出
    - Java 为 PrintStream 和 PrintWriter 类(`System.out`就是这种类型的对象)引入了 `format()` 和 `printf()` 方法来支持格式和输出，两个方法是等价的。
    - Java 的格式化输出最终都是由 Formatter 类实现，可以通过输出流来创建一个 Formatter 对象，调用其 `format()` 方法向输出流进行格式化输出，这是完成格式化输出的另一个选择。
    - 格式化输出的样式语法为 `%[{参数index}$][{flag}][{宽度}][.{精度}]{参数类型}`。例如`%2$-16.2f`，其中`-16` 表示宽度为16左对齐，默认为右对齐。
    - `String.format()` 方法是一个静态方法，返回一个格式化字符串对象，当然也是通过 Formatter 类实现的。
* 正则表达式
    - 在 Java 中正则表达式的转意符为 `\\`，其与意为插入一个正则表达式的反斜杠，例如 `\\d` 表示正则匹配一个数字。
    - `String.matches()` 可以判断是否正则匹配；`String.split()` 按正则切分；`String.replace()` 和 `String.replaceAll()` 可以按正则替换。
    - `Pattern.compile()` 方法编译一个正则表达式，可以生成 Pattern 对象，对其调用 `Pattern.matcher()` 方法可以返回一个 Matcher 对象，表示正则匹配的结果.
    - `Pattern.split()` 方法可以用于切分字符串。
    - Matcher 提供了 `replaceFirst()` 和 `replaceAll()` 用于替换匹配部分。还有更强大的 `appendReplacement()` 和 `appendTail()` 用于渐进是式的替换。
    - `Matcher.reset()` 可以重置其匹配的字符串。
* Scanner
    - Scanner 通过 File，InputStream，String 等任何实现了 Readable 接口的对象构建，用于方便的类型化读取（有点像 C 里面的 scanf() 函数）。它提供了 `nextLine()` 、 `nextInt()`、`nextDouble()` 等方法。
    - 默认情况下 Scanner 根据空白字符分词，可以调用 `Scanner.useDelimiter()` 方法，传入一个正则表达式来指定分词方式。例如 `Scanner a.useDelimiter("\\s*,\\s*")`。Scanner 提供了 `next()`、`hasNext`、`match()` 等方法来逐个读取正则匹配结果。
    - StringTokenizer，是 Java5 之前的提供的类，功能和 Scanner 类似；它可以视为被废弃了。

14
* `Class.newInstance()` 成功执行的前提是类一定要有默认构造器。
* 类加载分为三个阶段：加载，读取 .class 文件中的字节码，创建 Class 对象；链接，验证字节码，为静态属性分配存储空间；初始化，执行静态构造器和静态初始化代码块。
* 类的初始化阶段被设计成尽可能 lazy，通过 ".class" 获取对 Class 对象引用时并不会触发类的初始化阶段，甚至引用类所包含的编译期常量也不会触发初始化阶段；通过 `Class.forName()` 获取 Class 对象的引用总能触发初始化阶段。
* Class 类支持泛型参数；Class<?> 和 Class 是等价的，但前者更好，因为它明确表示可以匹配任何类型。
* `Class.cast()` 方法可以显示的执行强制转型操作，尽管需要使用这种方式的的情况比较少见。
* `Class.isInstance()` 实现了和 instanceof 语句相同的功能；`Class.isAssignableFrom()` 提供了 instanceof 语意之外的另一种类型比较功能。
* 运行时类型信息和反射这些工具，给开发者提供了破坏封装的方式，使他们可以调用一些原本被愿意被暴露的 api；使用反射再运行时修改 final 成员变量不会成功，虽然也不会抛出异常。
* 尽量使用多态而不是 RTTI。 

15
* 基本类型不能作为 java 范型的类型参数(需要使用包装类型，如 Integer);但需要注意自动包装机制不能对数组起效果，例如 `int[]` 无法被自动包装成 `Integer[]`。
* 如果可以使用泛型方法来替代泛型类，那么就选择泛型方法；构造函数也可以是泛型方法。
* static 方法无法访问泛型类的类型参数，如果想要使 static 方法具有泛型能力，就必须使其成为泛型方法。
* 定义泛型方法需要将泛型参数列表声明放在**返回值**前面。
* 通常来说泛型方法依赖类型推断，也可以在'.'操作符和方法名之间插入泛型参数列表来显示制定类型，例如`A.<T,K>a()`。
* 参数化的泛型类可以被向上转型成无参数的泛型类，编译器不会 warning，例如 `A = new A<T,K>()`；但是反向转型编译器会有 warning。
* `Array.newInstance()` 可以借由类型来创建数组。
* 了解技术的边界，是成为高级程序员的条件。
* 接口可以支持泛型；可以创建带泛型参数的匿名内部类。
* 因为类型擦除的存在，关于泛型参数的信息只能在静态类型检查时获得，在此之后泛型类型会被替换为泛型类型上界（使用 `<T extends ClassA>` 的语法指定泛型类的类型上界），泛型代码将无从得知泛型参数的具体类型是什么。
* 补偿泛型类型信息缺失的方式：
    - 将泛型参数的 `Class<T>` 作为参数传递到泛型代码中。
    - 使用工厂类代替泛型参数类型的构造函数。
    - 无法使用泛型参数创建泛型类型的数组，最终它们都会是 `Object[]` 类型的数组；使用 `List` 代替数组或者使用 `Array.newInstance()` 创建数组。
* 不要让编译器报出不需要处理警告，而是用 `@SuppressWarnings` 去压制它们，否则无用的警告会稀释真正值得注意的警告。
* 可以通过 `Type<T extends A & B & C>` 来给泛型参数指定多个上界，上界中只能有一个是 class 其他需要是 interface，其中 class 必须排在多个上界的最前面；可以在继承泛型类的时候添加上界，例如 `TypaB<T extends C> extends TypeA<T>`。
* 数组可以向上转型而不会编译期报错，例如 `Base[] array = Derived[]`（但是 `array = new Base()` 会造成运行时异常）；泛型类则不能向上转型，`Generic<Base> generic = Generic<Derived>` 无法通过编译。
* 可以通过通配符的方式完成泛型向上转型，例如 `Generic<? extends Base> generic = Generic<Derived>` 。
* 用通配符作为泛型参数存在限制，编译器拒绝函数参数列表中涉及通配符的函数调用，但是通配符可以作为函数的返回值；即通配符作为泛型参数之后，泛型参数对象不能被传入，只能被传出。
* 可以将泛型类的函数参数声明为 `Object` 而不是 `T`，参数传入就不会受通配符影响。
* 和 "extend" 通配符相对的，`Type<? super A>` 通配符可以出现在函数参数列表中。`Type<? super A>` 可以被称为泛型参数下界，任何继承自下界类的类对象，都可以作为传入参数的合法值，下界类的父类对象作为参数传入，则会引发编译期报错。
* 下界声明只能用在通配符泛型中，不能用在确切类型泛型，`Type<T super A>` 这种声明不能通过编译。
* 上界通配符解决了向上转型时泛型参数类型传出问题，下界通配符解决了向上转型时泛型参数类型传入问题。
* 无界通配符 `Type<?>` 看上去和非泛型类型（泛型参数等于 Object）差不多，但是无界通配符提供了更好的编译时检查，而非泛型类型则放弃了编译时检查：
    - `Type<?>` 拒绝通配符类型作为参数传入，而 `Type` 则将所有传入参数转为 Object。
    - `Type<?>` 在转型成泛型参数不同的参数化泛型时，编译器会报错，`Type` 则只会造成 warning。
* 确切类型泛型没有传入传出的限制，但是通配符泛型类型可以接受范围更广的参数化泛型。
