---
title: thinking-in-java
catalog: true
subtitle:
header-img:
tags:
---

## 2

* Java中没有unsigned 数值类型(char是unsigned)。
* char是16位的，值域为`\u0000`-`\uffff`。
* Java中浮点数采用IEEE754格式，float的值域为`-2^127`-`2^127`，但只保证24个二进制位的精度(即对于整数而已float只能保证`2^24`以内的数字能精确表示)；double的值域为`-2^1023`-`2^1023`，但只保证53个二进制位的精度。
* `java.lang`这个包会被自动import到源码。
* javadoc中可以使用HTML标签，但不要使用标题标签。

## 3

* Java中指数计数法如：`float a = 1.27e16f`，其中`e`代表10的次方数。
* 0x开头表示16进制数字，0开头表示8进制数字。
* 位操作`&`与、`|`或、`^`异或、`～`非，其中`～`是一元操作符；`&=`、`|=`、`^=`都是合法的。
* 位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为`2^5 = 32`位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。
* 对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。
* break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，`break <label>;`和`continue <label>`有助于跳出多层循环。例如：`label1: while () { while() { break label1;} }`。

## 5

* 当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。
* 可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。
* finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。
* 类的属性的初始化的执行顺序取决于属性定义的顺序。
* 实例初始化，其语法和`static { ... }`类似、但是去掉static关键字；这段代码执行于对象创建之后 & 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些功用的初始化逻辑。
* Java中数组的长度是不可变的(C++难道不是么...)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。
* 在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作*可变参数列表*来传递给方法。
* 不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。

## 6

* 每个类--包括内部类、同一文件中的多个类--都会生成一个单独的.class文件。
* Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。
* 类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。
* 如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。
* 访问权限修饰词也可以用于修饰类。
* 非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此...)。
* 每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。

## 7

* 当对象需要被隐式转换成String时，**编译器**会调用其toString()方法。
* 工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。
* 当创建一个集成类的对象时，这个对象中包含了一个基类的对象。
