---
title: 活跃性问题
subtitle: JCIP读书笔记第十章
catalog: true
header-img: /img/header_img/java-note-header.jpg
tags:
  - Java
categories:
  - 读书笔记
date: 2017-10-05 08:37:09
---


## 死锁   

再来一次五哲学家用筷子吃饭的例子，解释什么是死锁。数据库系统采用如下方法来避免死锁，在互相死锁的事务中挑选牺牲者并中止该事务。

### 加锁顺序造成的死锁

当线程需要同时获取多个锁时，有可能会发生加锁顺序造成的死锁；如果所有线程，都依照一个全局固定的顺序来依次获取多个锁，那么就可以避免加锁顺序造成的死锁。

要保持全局的加锁顺序固定，看起来是相当脆弱易出错的协议，尤其有动态的锁对象的时候。

### 动态的加锁顺序造成的锁死

当锁对象是动态的--例如将锁对象作为参数传入函数--就很容易发生难以察觉的加锁顺序锁死。
一种方式是用hashCode来定义动态锁对象的加锁；当锁对象的hashCode一致时使用额外的一个锁(被称为tie锁)在获取锁序列最外层加锁，使整个序列的获取过程变成互斥的。


### 当多锁获取发生在不同对象的不同方法中

多锁获取可能不是发生在同一个方法中，而是由多层调用栈造成，在这种情况下就很难注意到多锁获取的发生，更不用说保持顺序。

在持有锁的情况下调用外部方法，很容易发生活跃性问题。外部方法可能会去获取另一个锁，从而诱发加锁顺序死锁；外部方法可能会很久才返回，导致持有锁的时间过长。

### Open call

当在调用外部方法时不持有锁，这次调用被称为Open call。尽量使用Open call可以减少死锁发生的风险，并在死锁发生的时候使得问题变得容易被分析。

### 资源死锁

## 避免和诊断死锁

同时最多持有一个锁的代码不会发生死锁，虽然有时这样做无法满足需求。如果需要同时持有多个锁，那么需要先定位这些多锁获取场景，然后应用全局加锁顺序；全部使用Open Call有利于这些多锁获取场景的定位。

### 限时获取锁

使用tryLock可以让程序从死锁中恢复过来。

### 使用Thread Dump分析死锁

Thread Dump可以输出JVM中所有线程持有锁的情况和等待锁的情况，包括锁是在那个stack frame获取的，如果有死锁存在还是提示死锁信息。在Java5.0中，Thread Dump无法输出显式锁的信息；Java6.0中Thread Dump包含了显示锁的信息，但无法准确定位显示锁获取的stack frame。

## 其他活跃性问题

### Starvation

当一个线程理论上可以获取所需资源，但在实际情况下它永远不可能获得所需资源，就发生了Starvation；例如不合理的设置线程优先级，可能造成某些线程永远无法使用Cpu。
Java的线程API定义了10个线程优先级，在执行时这些线程优先级会被映射为系统线程优先级；在不同平台上设置线程优先级会有不同的效果，有些平台的系统线程优先级可能不足10个。
因为线程优先级的效果具有平台依赖性，所以非必要情况下不要调整线程优先级；UI线程和后台线程是一个适合使用线程优先级的场景。

### 活锁

活锁通常是由某种死循环逻辑，或者几个线程由于不良设计处于永久的逻辑冲突造成的。假设两个线程在同时请求某种资源时发生逻辑冲突，并且两个线程冲突后等待重试的时间相同，那么这两个线程就发生了活锁。





