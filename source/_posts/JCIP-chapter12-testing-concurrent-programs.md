---
title: 测试并发程序
subtitle: JCIP读书笔记第十二章
catalog: true
header-img: /img/header_img/java-note-header.jpg
tags:
  - Java
categories:
  - 读书笔记
date: 2017-10-06 11:50:07
---


## 展开点

* aspect-oriented programming (AOP) 。

## 概述

并发相关的测试通常可以归类为线程安全测试和线程活跃性测试。
线程安全测试通常需要验证变量的一致性，所以测试代码本身也需要时线程安全的；但有时候加入这样的测试代码之后会隐藏原有的线程安全类bug。
线程活跃性测试的难点在于，如何界定活跃性问题(例如死锁)真的发生了和程序运行效率低之间的区别。
并发相关的性能测试包含如下指标：

* 吞吐量：一组并发任务的完成速率。
* 响应速度：单个任务提交到完成之间的时间跨度。
* 伸缩性：吞吐量随并发数增长的幅度。

## 正确性测试

并发程序的正确性测试和非并发程序一样，需要找出所有的一致性条件进行验证，这一章用一个BlockingQueue的实现作为例子来做正确性测试。

### 基本单元测试

与非并发程序相同，验证基本的一致性。

### 测试阻塞方法

测试阻塞方法在条件满足时能否正确的阻塞，借助interrupt()和Thread.join()来完成测试。

通过Thread.getState()方法可以返回线程是否在WAITING状态，但是通过这种方法来验证阻塞并不可靠。首先阻塞并不意味线程状态为WAITING，JVM可能使用自旋来实现阻塞；其次执行了Object.wait()的线程肯能会被唤醒进入RUNNING状态，但这不意味着等待条件成立；再次Thread从发生阻塞到进入WAITING状态需要一定时间。
总体来说Thread.getState()方法并不是用于状态控制或者测试的，其主要应用场景是输出调试信息。

### 线程安全性测试

线程安全性的测试代码需要多线程并发执行，来确定是否有竞态条件等情况；但书写正确的并发测试代码也很有难度，同时要防止额外的测试代码同步影响被测试代码的同步情况。

线程安全性的测试程序最好不要引入新的同步。

本章使用了一个生产者消费者模式的实现，来作为线程安全性测试的例子，细节较多可以看原文。

线程安全性测试理应运行在多核系统上，为了尽可能发现竞态条件运行线程数量应该多于Cpu数量。

并发测试程序应当设置超时，以防止因为错误造成的程序无法结束。

### 测试资源管理

测试是否有内存泄漏。

### 增加线程切换

线程安全问题能否出线也许依赖运气，但是增加线程切换可以增加线程安全问题被暴露的几率。
在适当的位置调用Thread.yield()可以增加线程切换的机会。

## 性能测试

略

## 避免性能测试中的干扰

### GC干扰

是否触发GC会对性能测试结果产生明显的影响。避免GC干扰的主要方式就是确保测试过程中不触发GC(这个似乎很难保证)；或者使用足够多的内存申请，并运行足够长的时间，确保在测试过程中总是触发适当的GC(可以通过log来检查GC是否真的发生)。

### 动态编译干扰

由于JIT的存在，解释器执行字节码的效率远低于JIT后直接执行汇编。JIT干扰性能测试主要有两种因素：动态编译本身耗时，无法预测动态编译何时发生就无法确定测试究竟是执行的字节码还是汇编。

避免动态编译干扰的一种方法是，先让被测试代码进行“热身”(预执行N个循环)，在进行性能测试。有些JVM在动态编译发生时会输出log。

由于JVM会执行很多额外工作，如果一次运行中包含几组不相干的性能测试时，在几组测试之间加入Thread.Sleep()来防止JVM后台线程的干扰。

### 代码优化(忽略无用)造成的干扰

在性能测试中，需要防止编译器将测试代码视为无用代码进行删除优化，导致测试结果过于乐观。这就要求一些出于测试目的的运算的结果在后续代码中被使用。

一种做法是打印测试运算的结果，但是额外的IO也会干扰性能测试；一种trick的方法是：使用运算结果的hashCode和一个随机值做比较，相等时打印一些信息，这个比较几乎不会成功所以对测试干扰非常小，例如下面的代码：

```java
if (foo.x.hashCode() == System.nanoTime()) 
    System.out.print(" ");
```

同时在性能测试的运算中，要防止运算结果可以被编译器预测从而进行优化；加入时间变量可以做到这一点。

## 辅助测试的方法

无论怎样，单元测试不会找到代码中所有的Bug，也许需要借助单元测试以外的方法来增加找到Bug的概率。

### Code Review

即便并发专家在写并发代码时也会犯错误，同时在单元测试中揭露线程安全错误是有运气成分的，所以CR总是必要的。

### 静态代码分析工具

例如FindBugs。

###  aspect-oriented programming (AOP) 

展开点。

### Profile工具



