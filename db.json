{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/overspark-img.jpeg","path":"img/overspark-img.jpeg","modified":0,"renderable":0},{"_id":"source/img/header_img/about-header.jpg","path":"img/header_img/about-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/android-note-header.jpg","path":"img/header_img/android-note-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-header.jpg","path":"img/header_img/archive-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/home-header.jpg","path":"img/header_img/home-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/java-note-header.jpg","path":"img/header_img/java-note-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/manner-note-header.jpg","path":"img/header_img/manner-note-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/platform-source-header.jpg","path":"img/header_img/platform-source-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-header.jpg","path":"img/header_img/tag-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tips-header.jpg","path":"img/header_img/tips-header.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tools-note-header.jpg","path":"img/header_img/tools-note-header.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"c6d6edce7d28417a654f98e14a35ec4b55728b26","modified":1572580572622},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1499847726000},{"_id":"source/CNAME","hash":"f0ebcd04d04285244244be45b61f500b5ab6e2a2","modified":1499847726000},{"_id":"source/_drafts/JCIP-chapter4-composing-objects.md","hash":"1d9aa713bcac4badee06ea7ad83b4fe41c2926aa","modified":1507542025000},{"_id":"source/_drafts/android-developers-guide-note-platform-architecture.md","hash":"49ac5a744dfbd1de90a90414c948d19289c6763f","modified":1507541197000},{"_id":"source/_drafts/android-developers-guide-note-animation-and-graphics.md","hash":"62ec2480fd1fb50e9ad2f90485107902256cc455","modified":1507541197000},{"_id":"source/_drafts/android-developers-guide-note-ui.md","hash":"f5cc93b0f8f6bfd3560e2eaf7acd93f0cb85f433","modified":1507541197000},{"_id":"source/_drafts/gradle-manual-write-script-1.md","hash":"f9555bcdedcaabb654567439bf6f49c5e6402a7c","modified":1560481116000},{"_id":"source/_drafts/gradle-manual-write-script-2.md","hash":"dda815bc6a95c5469cb3dba66ca2d05ef117fc81","modified":1560413466000},{"_id":"source/_drafts/head-first-design-pattern.md","hash":"8932cfc52c6ae83b51642e702f4cea27aafa0ea3","modified":1572580640445},{"_id":"source/_drafts/thinking-in-java-generic.md","hash":"9ec4a242588d76f18228e0041843298c178e30bc","modified":1573983445034},{"_id":"source/_drafts/thinking-in-java.md","hash":"21675ae7b7e5f5e35a0f9bf073ceaa1113e8fe39","modified":1561508957000},{"_id":"source/archive/index.md","hash":"ca9e26480c4691f50ab2a8e0be1ca7d9571626c3","modified":1507541197000},{"_id":"source/about/index.md","hash":"d4f45f579c11b6fecd4ff5ee66b11968577e8e5e","modified":1525425526000},{"_id":"source/_posts/JCIP-chapter10-avoiding-liveness-hazards.md","hash":"6bb3a1bf2ee5bf01a8ae43259a7da747dc7b353f","modified":1507541197000},{"_id":"source/_posts/JCIP-chapter12-testing-concurrent-programs.md","hash":"e71e4706e3fd62f4a6c9e7ab33ab753a2a0f6731","modified":1507541197000},{"_id":"source/_posts/JCIP-chapter13-explicit-locks.md","hash":"e312dfc43b2381d1d8c92ed43a55126999b7de51","modified":1507541197000},{"_id":"source/_posts/JCIP-chapter14-building-custom-synchronizers.md","hash":"5c235ff22eec987d065e92091a4a7a1e228c204b","modified":1507541197000},{"_id":"source/_posts/JCIP-chapter15-atomic-variable-and-nonblocking-synchronization.md","hash":"3bd0cc7c4b120e2756a9e0f6fd6fdab1463d14d2","modified":1507541197000},{"_id":"source/_posts/JCIP-chapter16-java-memory-model.md","hash":"7923387183bcf40a030b46384137720f6f0168b5","modified":1507541197000},{"_id":"source/_posts/JCIP-chapter5-building-blocks.md","hash":"6075726609ba9236b19c75eb773f4a355a092cd4","modified":1507541329000},{"_id":"source/_posts/JCIP-chapter7-cancellation-and-shutdown.md","hash":"18f957ddeefba40a8988bdc8fa0ae6d6250c5625","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-components-activity.md","hash":"02d3b4fa702d1a6b08b47957fd235bd58ad6c87a","modified":1522125884000},{"_id":"source/_posts/android-developers-guide-note-app-components-content-provider.md","hash":"f1e2da4bbe95e466cf836eb1f12478f54aaffcb8","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-components-fragment.md","hash":"9596a117c39e25269cdc7915becd0ee36867497d","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-components-intents.md","hash":"95fa0d02e832b505ef30f34024936d425c514a92","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-components-others.md","hash":"c66b85fe4c62fb318fbe47e24126e09f10c8cb97","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-components-service.md","hash":"cc85e6f5afb3f1a02eb266d51a438aafb1867009","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-resources.md","hash":"38011426b2f97a4ae54dca4e387185e044d7150c","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-app-manifest.md","hash":"376a50e90065f83b0961b0eb2249a20511e08a6f","modified":1507541197000},{"_id":"source/_posts/android-developers-guide-note-introduction.md","hash":"f74e1b5fadc894b0aec02eab66bd7c3fe0a74ac2","modified":1507541197000},{"_id":"source/_posts/tips-decompile-android-rom.md","hash":"edf0b8ba30c6d92e1ec74ae3303d1c294c10c66d","modified":1525420442000},{"_id":"source/_posts/tips-move-git-with-history.md","hash":"98789d3168852b357463fc2371546f704e45accb","modified":1623915699845},{"_id":"source/_posts/tips-read-aosp-in-intellij.md","hash":"3b7514dfd65c6354c0bbbfdfb4b423a21ae0f7d1","modified":1507541197000},{"_id":"source/img/.DS_Store","hash":"76061c7d5bc66008f9649e82ffff8f8ec2fdfe1e","modified":1572580589068},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1499847726000},{"_id":"source/img/overspark-img.jpeg","hash":"c52dacd006e205b12e0516cfb63a48fdcc8e83f7","modified":1507541197000},{"_id":"source/tags/index.md","hash":"d51a22b3b6921d2343b15d8d6a8bd3dee835a279","modified":1507541197000},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1507541197000},{"_id":"source/archive/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1499847726000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1507541197000},{"_id":"source/img/header_img/.DS_Store","hash":"cb009ea04844ace3288a033d5bf8659f26c103b8","modified":1507541197000},{"_id":"source/img/signature/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1507541197000},{"_id":"source/_drafts/android-plugin-overview.md","hash":"a1db35ba3f634ebea9dadec3301ed602740e7b80","modified":1552014747000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1499847726000},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1507541197000},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1507541197000},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1507541197000},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1507541197000},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1507541197000},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1507541197000},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1507541197000},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1507541197000},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1507541197000},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1507541197000},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1507541197000},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1507541197000},{"_id":"themes/beantech/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1507541197000},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1507541197000},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1507541197000},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1507541197000},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1507541197000},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1507541197000},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1507541197000},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1507541197000},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1507541197000},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1507541197000},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1507541197000},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1507541197000},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1507541197000},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1507541197000},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1507541197000},{"_id":"themes/beantech/source/css/toc.styl","hash":"9e959cebf9aef87ecac0ea20db7ee96ea1c26b38","modified":1507541197000},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1507541197000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1507541197000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1507541197000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1507541197000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1507541197000},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1507541197000},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1507541197000},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1507541197000},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1507541197000},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1507541197000},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1507541197000},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1507541197000},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1507541197000},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1507541197000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1499847726000},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1507541197000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1507541197000},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1507541197000},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1507541197000},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1507541197000},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1507541197000},{"_id":"source/img/header_img/about-header.jpg","hash":"1035c392a062586e3ce68e05eba730981602bd07","modified":1507541197000},{"_id":"source/img/header_img/archive-header.jpg","hash":"b5bd86de81f819515e48253c5fce3af7636e51e2","modified":1507541197000},{"_id":"source/img/header_img/platform-source-header.jpg","hash":"735912a77a985e1e74110d240beda27197ab55c7","modified":1507685756000},{"_id":"source/img/header_img/manner-note-header.jpg","hash":"b95217f925201f95375aeefb850c085f37711b36","modified":1508119338000},{"_id":"source/img/header_img/android-note-header.jpg","hash":"a4923476f3925e17a309402ae2bcd63206218bb1","modified":1507541197000},{"_id":"source/img/header_img/home-header.jpg","hash":"767ffd664f3d4bc2bc4cb7eb2777bb8c072ce5f4","modified":1507541197000},{"_id":"source/img/header_img/java-note-header.jpg","hash":"7c5b8db2b72e0e0d2ac4c0f010eb6aa2b0b452b8","modified":1507541197000},{"_id":"source/img/header_img/tools-note-header.jpg","hash":"66e7d21fd7027a423b34f12c871c6c0fb9eef556","modified":1502938974000},{"_id":"source/img/header_img/tips-header.jpg","hash":"78533e1e73342689c333aedd73e969f5dbbb1285","modified":1507541197000},{"_id":"source/img/header_img/tag-header.jpg","hash":"b47d475ccabde4d448d743f0eb6c147417f7ccb8","modified":1507541197000},{"_id":"public/archive/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2017/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2017/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2017/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2017/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2017/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2018/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2021/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/archives/2021/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/tags/Java/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/tags/Android/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/tags/Android/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/tags/Git/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/categories/读书笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/categories/读书笔记/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/categories/经验/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623916265648},{"_id":"public/404.html","hash":"7993476e7e57dfad0201c7532868d0d16cd2b2a5","modified":1623916265648},{"_id":"public/tags/index.html","hash":"992dd8c1045936c932e739bc416db2d6649e4378","modified":1623916265648},{"_id":"public/2021/06/17/tips-move-git-with-history/index.html","hash":"fd6946c86bfa63a1ca86c905bec249f84086668a","modified":1623916265648},{"_id":"public/2018/05/04/tips-decompile-android-rom/index.html","hash":"3e743d4e4aeb607e165c4156ef8f2331d76b2fc1","modified":1623916265648},{"_id":"public/2017/10/09/JCIP-chapter5-building-blocks/index.html","hash":"b67ccdc37d16e56e99b9186817c111fb09046628","modified":1623916265648},{"_id":"public/2017/10/09/JCIP-chapter7-cancellation-and-shutdown/index.html","hash":"5789b1699461d5a7fd8e37a90f15da591ea702db","modified":1623916265648},{"_id":"public/2017/10/06/JCIP-chapter12-testing-concurrent-programs/index.html","hash":"e20745ea7ebf938fc797e64bb99c7b18db31c5a4","modified":1623916265648},{"_id":"public/2017/10/05/JCIP-chapter10-avoiding-liveness-hazards/index.html","hash":"de483de2ce8660b1616dd7aad9603223a7bf03e0","modified":1623916265648},{"_id":"public/2017/09/29/JCIP-chapter13-explicit-locks/index.html","hash":"e63117abf6aa1ef6675ea58ba5a2fe1b4a6ef607","modified":1623916265648},{"_id":"public/2017/09/29/JCIP-chapter14-building-custom-synchronizers/index.html","hash":"83dbbe8fc0d7aa0f031e5a17f908782b6af03c37","modified":1623916265648},{"_id":"public/2017/09/21/JCIP-chapter15-atomic-variable-and-nonblocking-synchronization/index.html","hash":"dcfa8bd70f05b9f8fd787ca1d9505715b6113139","modified":1623916265648},{"_id":"public/2017/09/10/tips-read-aosp-in-intellij/index.html","hash":"80ad44a2fe5fbede54f4aefc9602ddc512e1476e","modified":1623916265648},{"_id":"public/2017/09/09/JCIP-chapter16-java-memory-model/index.html","hash":"9a358ad3ff81c29825a3d776fc7ef7017ed64726","modified":1623916265648},{"_id":"public/2017/09/09/android-developers-guide-note-app-manifest/index.html","hash":"0856d9a4e3401b8ed7757aa3bce87345efa40f7d","modified":1623916265648},{"_id":"public/2017/09/04/android-developers-guide-note-app-resources/index.html","hash":"d06e00675704d774db0dd45d1c33e66c0db01e16","modified":1623916265648},{"_id":"public/2017/08/21/android-developers-guide-note-app-components-content-provider/index.html","hash":"7655b897bfb66066c6d2abe96d0f6b0c3c6791f2","modified":1623916265648},{"_id":"public/2017/08/21/android-developers-guide-note-app-components-others/index.html","hash":"a500b8a827ff66e6d6e7780aae793d2bce727420","modified":1623916265648},{"_id":"public/2017/08/04/android-developers-guide-note-app-components-service/index.html","hash":"397f9f1858f538de920f669c16734541e320b657","modified":1623916265648},{"_id":"public/2017/08/04/android-developers-guide-note-app-components-fragment/index.html","hash":"a80011debab968d0994312f1433ee50af6be0d17","modified":1623916265648},{"_id":"public/2017/08/03/android-developers-guide-note-app-components-activity/index.html","hash":"3da56589c3c78ba30f65176d79844d5d70fd4414","modified":1623916265648},{"_id":"public/2017/07/26/android-developers-guide-note-app-components-intents/index.html","hash":"ee5f25d552397ee06884a8bfcaaab095eda42975","modified":1623916265648},{"_id":"public/2017/07/18/android-developers-guide-note-introduction/index.html","hash":"f4962b6d34003f8ed8b49f8531a4d7a06cbcdf74","modified":1623916265648},{"_id":"public/img/header_img/platform-source-header.jpg","hash":"735912a77a985e1e74110d240beda27197ab55c7","modified":1623916265648},{"_id":"public/img/header_img/manner-note-header.jpg","hash":"b95217f925201f95375aeefb850c085f37711b36","modified":1623916265648}],"Category":[{"name":"读书笔记","_id":"ckq0lr4p9000x3mrf8cqefvds"},{"name":"经验","_id":"ckq0lr4pr002b3mrf492x2bjc"},{"name":"源码分析","_id":"ckq0lr4q000423mrf1fl8cq2t"}],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2020-05-20T14:19:15.617Z","updated":"2017-07-12T08:22:06.000Z","path":"404.html","title":"","comments":1,"_id":"ckq0lr4om00003mrf8r08cw0b","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-header.jpg","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-header.jpg\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2017-10-09T09:26:37.000Z","path":"archive/index.html","_id":"ckq0lr4or00023mrf8dtddsqk","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"May the Elune be with You","header-img":"img/header_img/about-header.jpg","comments":1,"_content":"\n> Do not stand at my grave and weep, i am not there, i do not sleep.    \n> 不要站在我的墓前为我哭泣。我不在那里，我不曾睡去。   \n> I am in a thousand winds that blow, across northreand's bright and shining snow.    \n> 我是万千呼啸的风，飞过白雪皑皑的诺森德。   \n> I am the gentle showers of rain, on westfall's fields of golden grain.    \n> 我是柔和细腻的雨，洒在西部荒野的金色稻田。   \n> I am in the morning hush, of stranglethorn's jungle, green and lush.    \n> 我是清幽安静的晨，弥漫在绿色茂盛的荆棘谷。   \n> I am in the drums loud and grand, the thunderous hooves across nagrand.    \n> 我是威武雄壮的鼓，踏过无限草原纳格兰。   \n> I am the stars warmly gleaming, over darnassus softly dreaming.    \n> 我是温暖闪耀的星，照耀达纳苏斯的静寞长眠。   \n> I am in the birds that sing, i am in each lovely thing.    \n> 我是歌唱的鸟，我存在于一切的美好。   \n> Do not stand at my grave and cry, i am not there. i do not die.    \n> 不要站在我的墓前为我哭泣，我不在那里，我从未离去。   \n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"May the Elune be with You\"\nheader-img: \"img/header_img/about-header.jpg\"\ncomments: true\n---\n\n> Do not stand at my grave and weep, i am not there, i do not sleep.    \n> 不要站在我的墓前为我哭泣。我不在那里，我不曾睡去。   \n> I am in a thousand winds that blow, across northreand's bright and shining snow.    \n> 我是万千呼啸的风，飞过白雪皑皑的诺森德。   \n> I am the gentle showers of rain, on westfall's fields of golden grain.    \n> 我是柔和细腻的雨，洒在西部荒野的金色稻田。   \n> I am in the morning hush, of stranglethorn's jungle, green and lush.    \n> 我是清幽安静的晨，弥漫在绿色茂盛的荆棘谷。   \n> I am in the drums loud and grand, the thunderous hooves across nagrand.    \n> 我是威武雄壮的鼓，踏过无限草原纳格兰。   \n> I am the stars warmly gleaming, over darnassus softly dreaming.    \n> 我是温暖闪耀的星，照耀达纳苏斯的静寞长眠。   \n> I am in the birds that sing, i am in each lovely thing.    \n> 我是歌唱的鸟，我存在于一切的美好。   \n> Do not stand at my grave and cry, i am not there. i do not die.    \n> 不要站在我的墓前为我哭泣，我不在那里，我从未离去。   \n","updated":"2018-05-04T09:18:46.000Z","path":"about/index.html","_id":"ckq0lr4os00043mrf2h6m5h1h","content":"<blockquote>\n<p>Do not stand at my grave and weep, i am not there, i do not sleep.<br>不要站在我的墓前为我哭泣。我不在那里，我不曾睡去。<br>I am in a thousand winds that blow, across northreand’s bright and shining snow.<br>我是万千呼啸的风，飞过白雪皑皑的诺森德。<br>I am the gentle showers of rain, on westfall’s fields of golden grain.<br>我是柔和细腻的雨，洒在西部荒野的金色稻田。<br>I am in the morning hush, of stranglethorn’s jungle, green and lush.<br>我是清幽安静的晨，弥漫在绿色茂盛的荆棘谷。<br>I am in the drums loud and grand, the thunderous hooves across nagrand.<br>我是威武雄壮的鼓，踏过无限草原纳格兰。<br>I am the stars warmly gleaming, over darnassus softly dreaming.<br>我是温暖闪耀的星，照耀达纳苏斯的静寞长眠。<br>I am in the birds that sing, i am in each lovely thing.<br>我是歌唱的鸟，我存在于一切的美好。<br>Do not stand at my grave and cry, i am not there. i do not die.<br>不要站在我的墓前为我哭泣，我不在那里，我从未离去。   </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Do not stand at my grave and weep, i am not there, i do not sleep.<br>不要站在我的墓前为我哭泣。我不在那里，我不曾睡去。<br>I am in a thousand winds that blow, across northreand’s bright and shining snow.<br>我是万千呼啸的风，飞过白雪皑皑的诺森德。<br>I am the gentle showers of rain, on westfall’s fields of golden grain.<br>我是柔和细腻的雨，洒在西部荒野的金色稻田。<br>I am in the morning hush, of stranglethorn’s jungle, green and lush.<br>我是清幽安静的晨，弥漫在绿色茂盛的荆棘谷。<br>I am in the drums loud and grand, the thunderous hooves across nagrand.<br>我是威武雄壮的鼓，踏过无限草原纳格兰。<br>I am the stars warmly gleaming, over darnassus softly dreaming.<br>我是温暖闪耀的星，照耀达纳苏斯的静寞长眠。<br>I am in the birds that sing, i am in each lovely thing.<br>我是歌唱的鸟，我存在于一切的美好。<br>Do not stand at my grave and cry, i am not there. i do not die.<br>不要站在我的墓前为我哭泣，我不在那里，我从未离去。   </p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-header.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-header.jpg\"\n---\n","date":"2020-05-20T14:19:15.882Z","updated":"2017-10-09T09:26:37.000Z","path":"tags/index.html","comments":1,"_id":"ckq0lr4ot00063mrf8svzh2ek","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"编写线程安全类","subtitle":"JCIP读书笔记第四章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","_content":"\n## 设计线程安全类\n\n## 对象封闭\n\n## 利用已有的线程安全类\n\n## 为已有的线程安全类添加功能\n\n## 记录同步策略\n","source":"_drafts/JCIP-chapter4-composing-objects.md","raw":"---\ntitle: 编写线程安全类\nsubtitle: JCIP读书笔记第四章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\n---\n\n## 设计线程安全类\n\n## 对象封闭\n\n## 利用已有的线程安全类\n\n## 为已有的线程安全类添加功能\n\n## 记录同步策略\n","slug":"JCIP-chapter4-composing-objects","published":0,"date":"2017-10-09T09:40:25.000Z","updated":"2017-10-09T09:40:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4oo00013mrfae9d920p","content":"<h2 id=\"设计线程安全类\"><a href=\"#设计线程安全类\" class=\"headerlink\" title=\"设计线程安全类\"></a>设计线程安全类</h2><h2 id=\"对象封闭\"><a href=\"#对象封闭\" class=\"headerlink\" title=\"对象封闭\"></a>对象封闭</h2><h2 id=\"利用已有的线程安全类\"><a href=\"#利用已有的线程安全类\" class=\"headerlink\" title=\"利用已有的线程安全类\"></a>利用已有的线程安全类</h2><h2 id=\"为已有的线程安全类添加功能\"><a href=\"#为已有的线程安全类添加功能\" class=\"headerlink\" title=\"为已有的线程安全类添加功能\"></a>为已有的线程安全类添加功能</h2><h2 id=\"记录同步策略\"><a href=\"#记录同步策略\" class=\"headerlink\" title=\"记录同步策略\"></a>记录同步策略</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设计线程安全类\"><a href=\"#设计线程安全类\" class=\"headerlink\" title=\"设计线程安全类\"></a>设计线程安全类</h2><h2 id=\"对象封闭\"><a href=\"#对象封闭\" class=\"headerlink\" title=\"对象封闭\"></a>对象封闭</h2><h2 id=\"利用已有的线程安全类\"><a href=\"#利用已有的线程安全类\" class=\"headerlink\" title=\"利用已有的线程安全类\"></a>利用已有的线程安全类</h2><h2 id=\"为已有的线程安全类添加功能\"><a href=\"#为已有的线程安全类添加功能\" class=\"headerlink\" title=\"为已有的线程安全类添加功能\"></a>为已有的线程安全类添加功能</h2><h2 id=\"记录同步策略\"><a href=\"#记录同步策略\" class=\"headerlink\" title=\"记录同步策略\"></a>记录同步策略</h2>"},{"title":"Android Developer Guide中的动画与图形","subtitle":"Android官方guide随笔 - Animation and Graphics","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-08-24T02:53:27.000Z","_content":"\n## 展开点 \n\n* [ViewPropertyAnimator](https://android-developers.googleblog.com/2011/05/introducing-viewpropertyanimator.html)。\n* [绘制性能相关](https://developer.android.google.cn/topic/performance/rendering/index.html)。\n","source":"_drafts/android-developers-guide-note-animation-and-graphics.md","raw":"---\ntitle: Android Developer Guide中的动画与图形\nsubtitle: Android官方guide随笔 - Animation and Graphics\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-08-24 10:53:27\n---\n\n## 展开点 \n\n* [ViewPropertyAnimator](https://android-developers.googleblog.com/2011/05/introducing-viewpropertyanimator.html)。\n* [绘制性能相关](https://developer.android.google.cn/topic/performance/rendering/index.html)。\n","slug":"android-developers-guide-note-animation-and-graphics","published":0,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4os00033mrf793oewhz","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/05/introducing-viewpropertyanimator.html\">ViewPropertyAnimator</a>。</li>\n<li><a href=\"https://developer.android.google.cn/topic/performance/rendering/index.html\">绘制性能相关</a>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/05/introducing-viewpropertyanimator.html\">ViewPropertyAnimator</a>。</li>\n<li><a href=\"https://developer.android.google.cn/topic/performance/rendering/index.html\">绘制性能相关</a>。</li>\n</ul>\n"},{"title":"Android Developer Guide中的系统结构","subtitle":"Android官方guide随笔 - Platform Architecture","header-img":"/img/header_img/android-note-header.jpg","catalog":true,"_content":"\n## Platform Architecture   \n\n### 展开点   \n\n* 为什么选用DEX bytcode。\n* Build toolchains。\n* AOT & JIT。\n* Dalvik & ART。\n* 如何调用Android native libraries。\n* 使用Java feature，other then using Jack。\n\n## Use Java 8 language features   \n\n## Verifying App Behavior on the Android Runtime (ART)   \n\n### 展开点   \n\n* [Debugging Android JNI with CheckJNI](https://android-developers.googleblog.com/2011/07/debugging-android-jni-with-checkjni.html)。\n* [JNI Local Reference Changes in ICS](https://android-developers.googleblog.com/2011/11/jni-local-reference-changes-in-ics.html)。\n* [mockito](https://github.com/mockito/mockito)。\n* adb bugreport。\n\n### caution\n\n*  调用System.getProperty(\"java.vm.version\")判断runtime的类型，如果大于\"2.0.0\"则是ART。\n*  Dalvik的Java栈和Native栈是分开的，ART的Java栈和Native栈是统一的(为了提升局部性)。","source":"_drafts/android-developers-guide-note-platform-architecture.md","raw":"---\ntitle: Android Developer Guide中的系统结构\nsubtitle: Android官方guide随笔 - Platform Architecture\nheader-img: \"/img/header_img/android-note-header.jpg\"\ncatalog: true\ntags: [Android]\ncategories: [读书笔记]\n---\n\n## Platform Architecture   \n\n### 展开点   \n\n* 为什么选用DEX bytcode。\n* Build toolchains。\n* AOT & JIT。\n* Dalvik & ART。\n* 如何调用Android native libraries。\n* 使用Java feature，other then using Jack。\n\n## Use Java 8 language features   \n\n## Verifying App Behavior on the Android Runtime (ART)   \n\n### 展开点   \n\n* [Debugging Android JNI with CheckJNI](https://android-developers.googleblog.com/2011/07/debugging-android-jni-with-checkjni.html)。\n* [JNI Local Reference Changes in ICS](https://android-developers.googleblog.com/2011/11/jni-local-reference-changes-in-ics.html)。\n* [mockito](https://github.com/mockito/mockito)。\n* adb bugreport。\n\n### caution\n\n*  调用System.getProperty(\"java.vm.version\")判断runtime的类型，如果大于\"2.0.0\"则是ART。\n*  Dalvik的Java栈和Native栈是分开的，ART的Java栈和Native栈是统一的(为了提升局部性)。","slug":"android-developers-guide-note-platform-architecture","published":0,"date":"2017-10-09T09:26:37.000Z","updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4os00053mrfdk1rb7nf","content":"<h2 id=\"Platform-Architecture\"><a href=\"#Platform-Architecture\" class=\"headerlink\" title=\"Platform Architecture\"></a>Platform Architecture</h2><h3 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h3><ul>\n<li>为什么选用DEX bytcode。</li>\n<li>Build toolchains。</li>\n<li>AOT &amp; JIT。</li>\n<li>Dalvik &amp; ART。</li>\n<li>如何调用Android native libraries。</li>\n<li>使用Java feature，other then using Jack。</li>\n</ul>\n<h2 id=\"Use-Java-8-language-features\"><a href=\"#Use-Java-8-language-features\" class=\"headerlink\" title=\"Use Java 8 language features\"></a>Use Java 8 language features</h2><h2 id=\"Verifying-App-Behavior-on-the-Android-Runtime-ART\"><a href=\"#Verifying-App-Behavior-on-the-Android-Runtime-ART\" class=\"headerlink\" title=\"Verifying App Behavior on the Android Runtime (ART)\"></a>Verifying App Behavior on the Android Runtime (ART)</h2><h3 id=\"展开点-1\"><a href=\"#展开点-1\" class=\"headerlink\" title=\"展开点\"></a>展开点</h3><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/07/debugging-android-jni-with-checkjni.html\">Debugging Android JNI with CheckJNI</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/11/jni-local-reference-changes-in-ics.html\">JNI Local Reference Changes in ICS</a>。</li>\n<li><a href=\"https://github.com/mockito/mockito\">mockito</a>。</li>\n<li>adb bugreport。</li>\n</ul>\n<h3 id=\"caution\"><a href=\"#caution\" class=\"headerlink\" title=\"caution\"></a>caution</h3><ul>\n<li>调用System.getProperty(“java.vm.version”)判断runtime的类型，如果大于”2.0.0”则是ART。</li>\n<li>Dalvik的Java栈和Native栈是分开的，ART的Java栈和Native栈是统一的(为了提升局部性)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Platform-Architecture\"><a href=\"#Platform-Architecture\" class=\"headerlink\" title=\"Platform Architecture\"></a>Platform Architecture</h2><h3 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h3><ul>\n<li>为什么选用DEX bytcode。</li>\n<li>Build toolchains。</li>\n<li>AOT &amp; JIT。</li>\n<li>Dalvik &amp; ART。</li>\n<li>如何调用Android native libraries。</li>\n<li>使用Java feature，other then using Jack。</li>\n</ul>\n<h2 id=\"Use-Java-8-language-features\"><a href=\"#Use-Java-8-language-features\" class=\"headerlink\" title=\"Use Java 8 language features\"></a>Use Java 8 language features</h2><h2 id=\"Verifying-App-Behavior-on-the-Android-Runtime-ART\"><a href=\"#Verifying-App-Behavior-on-the-Android-Runtime-ART\" class=\"headerlink\" title=\"Verifying App Behavior on the Android Runtime (ART)\"></a>Verifying App Behavior on the Android Runtime (ART)</h2><h3 id=\"展开点-1\"><a href=\"#展开点-1\" class=\"headerlink\" title=\"展开点\"></a>展开点</h3><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/07/debugging-android-jni-with-checkjni.html\">Debugging Android JNI with CheckJNI</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/11/jni-local-reference-changes-in-ics.html\">JNI Local Reference Changes in ICS</a>。</li>\n<li><a href=\"https://github.com/mockito/mockito\">mockito</a>。</li>\n<li>adb bugreport。</li>\n</ul>\n<h3 id=\"caution\"><a href=\"#caution\" class=\"headerlink\" title=\"caution\"></a>caution</h3><ul>\n<li>调用System.getProperty(“java.vm.version”)判断runtime的类型，如果大于”2.0.0”则是ART。</li>\n<li>Dalvik的Java栈和Native栈是分开的，ART的Java栈和Native栈是统一的(为了提升局部性)。</li>\n</ul>\n"},{"title":"Android Developer Guide中的UI","subtitle":"Android官方guide随笔 - UI","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","_content":"\n## 展开点   \n\n* [Say Goodbye to the Menu Button](https://android-developers.googleblog.com/2012/01/say-goodbye-to-menu-button.html)。\n* [New Layout Widgets: Space and GridLayout](https://android-developers.googleblog.com/2011/11/new-layout-widgets-space-and-gridlayout.html)。\n* [Customizing the Action Bar](https://android-developers.googleblog.com/2011/04/customizing-action-bar.html)。\n* [Horizontal View Swiping with ViewPager](https://android-developers.googleblog.com/2011/08/horizontal-view-swiping-with-viewpager.html)。\n* measuredSize和drawingSize的区别。\n* [Holo Everywhere](https://android-developers.googleblog.com/2012/01/holo-everywhere.html)。\n\n## Caution\n\n* 系统提供的控件位于android.widget包下面。\n* `<selector>`标签下`<item>`标签的顺序有意义，系统会从上到下选择第一个合适的`<item>`所以default的`<item>`需要处于最后一个。\n* 系统会先调用Event Listeners之后调用Event Handlers，如果Event Listeners返回true，那么Event Handlers就不会被调用了。\n* 在Touch Mode下isFocusableInTouchMode()为false的View(例如Button)是不会被focus的。\n","source":"_drafts/android-developers-guide-note-ui.md","raw":"---\ntitle: Android Developer Guide中的UI\nsubtitle: Android官方guide随笔 - UI\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\n---\n\n## 展开点   \n\n* [Say Goodbye to the Menu Button](https://android-developers.googleblog.com/2012/01/say-goodbye-to-menu-button.html)。\n* [New Layout Widgets: Space and GridLayout](https://android-developers.googleblog.com/2011/11/new-layout-widgets-space-and-gridlayout.html)。\n* [Customizing the Action Bar](https://android-developers.googleblog.com/2011/04/customizing-action-bar.html)。\n* [Horizontal View Swiping with ViewPager](https://android-developers.googleblog.com/2011/08/horizontal-view-swiping-with-viewpager.html)。\n* measuredSize和drawingSize的区别。\n* [Holo Everywhere](https://android-developers.googleblog.com/2012/01/holo-everywhere.html)。\n\n## Caution\n\n* 系统提供的控件位于android.widget包下面。\n* `<selector>`标签下`<item>`标签的顺序有意义，系统会从上到下选择第一个合适的`<item>`所以default的`<item>`需要处于最后一个。\n* 系统会先调用Event Listeners之后调用Event Handlers，如果Event Listeners返回true，那么Event Handlers就不会被调用了。\n* 在Touch Mode下isFocusableInTouchMode()为false的View(例如Button)是不会被focus的。\n","slug":"android-developers-guide-note-ui","published":0,"date":"2017-10-09T09:26:37.000Z","updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ou00073mrffne69zn3","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2012/01/say-goodbye-to-menu-button.html\">Say Goodbye to the Menu Button</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/11/new-layout-widgets-space-and-gridlayout.html\">New Layout Widgets: Space and GridLayout</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/04/customizing-action-bar.html\">Customizing the Action Bar</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/08/horizontal-view-swiping-with-viewpager.html\">Horizontal View Swiping with ViewPager</a>。</li>\n<li>measuredSize和drawingSize的区别。</li>\n<li><a href=\"https://android-developers.googleblog.com/2012/01/holo-everywhere.html\">Holo Everywhere</a>。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>系统提供的控件位于android.widget包下面。</li>\n<li><code>&lt;selector&gt;</code>标签下<code>&lt;item&gt;</code>标签的顺序有意义，系统会从上到下选择第一个合适的<code>&lt;item&gt;</code>所以default的<code>&lt;item&gt;</code>需要处于最后一个。</li>\n<li>系统会先调用Event Listeners之后调用Event Handlers，如果Event Listeners返回true，那么Event Handlers就不会被调用了。</li>\n<li>在Touch Mode下isFocusableInTouchMode()为false的View(例如Button)是不会被focus的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2012/01/say-goodbye-to-menu-button.html\">Say Goodbye to the Menu Button</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/11/new-layout-widgets-space-and-gridlayout.html\">New Layout Widgets: Space and GridLayout</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/04/customizing-action-bar.html\">Customizing the Action Bar</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/08/horizontal-view-swiping-with-viewpager.html\">Horizontal View Swiping with ViewPager</a>。</li>\n<li>measuredSize和drawingSize的区别。</li>\n<li><a href=\"https://android-developers.googleblog.com/2012/01/holo-everywhere.html\">Holo Everywhere</a>。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>系统提供的控件位于android.widget包下面。</li>\n<li><code>&lt;selector&gt;</code>标签下<code>&lt;item&gt;</code>标签的顺序有意义，系统会从上到下选择第一个合适的<code>&lt;item&gt;</code>所以default的<code>&lt;item&gt;</code>需要处于最后一个。</li>\n<li>系统会先调用Event Listeners之后调用Event Handlers，如果Event Listeners返回true，那么Event Handlers就不会被调用了。</li>\n<li>在Touch Mode下isFocusableInTouchMode()为false的View(例如Button)是不会被focus的。</li>\n</ul>\n"},{"title":"Gradle 脚本基础 - 编写 Gradle 脚本 (Part1)","subtitle":"Gradle Manual 读书笔记 （2.1）","catalog":true,"header-img":"/img/header_img/tools-note-header.jpg","_content":"\n## Gradle 脚本基础 \n\n### Gradle API\n* Gradle 脚本是基于 Groovy (或者 kotlin) 的 DSL (domain specific language), Gradle 脚本的默认编码是 utf-8。\n* Gradle 为每个工程创建了一个 `Project` 对象，并将这个 `Project` 对象 delegate 到 Gradle 脚本；所以未在脚本中定义的*方法*和*变量*都会去 `Project` 的命名空间中去查找，所以 `Project` 类提供了最基础的 Gradle 脚本 API。\n* 大部分 Gradle 脚本都会 delegate 到 `Project` 对象，但是也有例外。例如：settings.gradle 被 delegate 到 `Settings` 对象，init.gradle 被 delegate 到 `Gradle` 对象。\n* `Project` 提供了 `configure(Object o, Closure action)`接口，来用更容易阅读的方式来修改对象。\n* `Project` 提供了 `apply` 接口，来用其他 Gradle 脚本来修改对象 (最常见的就是修改 `Project` 对象)，代码示例：\n\n```groovy\ntask configure {\n    doLast {\n        def pos = new java.text.FieldPosition(10)\n        // Apply the script\n        apply from: 'other.gradle', to: pos\n        println pos.beginIndex\n        println pos.endIndex\n    }\n}\n```\nother.gradle\n```groovy\n// Set properties.\nbeginIndex = 1\nendIndex = 5\n```\n\n* 为了方便，Gradle 在每个脚本中做了一些默认 import。\n\n### 在 Gradle 脚本中使用变量   \n在 Gradle 脚本中声明变量有两种方式：局部变量和 Ext 属性 (extra properties)。\n\n* 局部变量就是单纯的 Groovy 变量，其可见范围也符合 Groovy 语法规则。\n* 大部分 Gradle domain model 都支持 extra properties；extra properties 通过 model 的 ext 属性来添加和访问。\n    - 当 extra property 被添加到对象中后，可以使用像对象属性一样的方式来访问(例如 {object referrence}.{property name})。\n    - Ext 的功能是基于 ExtraPropertiesExtension，ExtraPropertiesExtension 实际上的接口像个 Map；但是基于Groovy酷炫的语法功能，Ext 可以像正常属性一样访问，所以尽量使用访问属性语法(而不是类 Map 函数调用)来访问 Ext 属性。\n    - project 的 Ext在它的 subprojects 中依然可见。\n* 当访问对象的属性时、无论是正常属性还是通过Ext添加的属性、如果该属性不存在那么 Gradle 会抛出异常。\n\n### 在 Gradle 脚本中使用第三方库\n* 如果想在 gradle 脚本执行时使用一些第三方库，可以使用 `buildscript { }` 代码块来引入第三方库。\n* 将第三方库依赖添加到名为 \"classpath\" 的 configuration 上之后，第三方库中的 class 就可以在 gradle 脚本中被引用到。 \n* 多工程环境下，某工程通过 `buildscript { }` 引入的第三方库在其子工程中也能使用。\n* 每个 project 都会有名为 \"buildEnvironment\" 的任务，改任务会打印当前 project 的 gradle 脚本的所有第三方依赖 (和打印 java 工程依赖形式相同)。\n* `buildscript { }` 的 Closure 被代理到 `ScriptHandler` 类对象上，更多使用方法可以参照其 api。\n\n### 一些 Groovy 语法特性   \n* 可遍历的容器加入了`each(Closure action)`函数，例如`configurations.runtime.each { File f -> println f }`。\n* 属性访问会自动调用get和set方法。\n* 函数调用不用加括号。\n* list和map可以使用字面值：\n    - list字面值：`['object1', 'object2']`。\n    - map字面值：`[key1:'value1', key2: 'value2']`\n* 每个 Closure 可以 delegate 一个对象，以便在 Closure 可以直接使用对象的属性和方法。\n\n## Gradle 的生命周期\n\nGradle 的核心是建立起 task 的有向无环图，并按照顺序执行这些 task ；所以 Gradle 脚本的主要工作就是定义和配置 task。\n\n一次 Gradle 执行可以被分为三个阶段\n\n* 初始化阶段，确定 Project 结构并为每个 Project 生成 `Project` 对象(settings.gradle)。\n* 配置阶段，对所有参与这次 Gradle 执行 Project 进行配置(build.gradle)。\n* 执行阶段，确定 taskGraph，并依次执行 task。\n\n### 定位 setting.gradle\n\n初始化阶段 Gradle 会寻找 setting.gradle 脚本，在执行该脚本后创建 Project 对象(多个)。\n\n* 寻找 setting.gradle 是为了确定当次执行是多工程还是单工程，寻找规则如下：\n    - 在相邻目录中的名为 'master' 的目录中寻找(flat 结构，所以 flat 结构的 rootProject 目录需要被命名为 'master')。\n    - 在父目录中寻找。\n    - 如果没有找到，或者执行目录没有在 setting.gradle 中定义，当次执行为单工程；否则为多工程。\n* 可以在命令行中加入 `-u` 参数，强制当次执行为单工程；但是如果执行目录中存在 setting.gradle，`-u` 参数被忽略。\n\n### settings.gradle 和多工程结构\n\n* \"Settings文件\"用于定义多工程结构，其默认命名是 settings.gradle；多工程构建时，root project 目录下必须存在 settings.gradle；正如 build.gradle 会 delegate 一个 `Project` 对象，settings.gradle 会 delegate 一个 `Settings` 对象。\n* 多工程结构被定为单根树形结构，根节点被称为 rootProject；默认配置下，rootProject 物理路径就是 setting.gradle 文件所在的目录，subProject 物理路径结构的和 Project 树结构相同；这种默认配置可以在 setting.gradle 中修改。\n* `Settings.getRootProject()` 和 `Settings.project(String)` 方法会返回 `ProjectDescriptor` 对象，可以通过 `ProjectDescriptor` 对象来修改 Project 的物理路径、build 脚本名字等。\n\n### 监听生命周期\n\n* `Project.beforeEvaluate(Closure)`、`Project.afterEvaluate(Closure)`、`Gradle.beforeProject(Closure)`、`Gradle.afterProject(Closure)`等方法可以用于监听 Project 的 evaluate 过程。\n* 通过 `Project.tasks` 和 `Gradle.taskGraph` 的监听方法，可以监听 task 的创建过程和执行过程。\n\n## 多工程构建\n\n多工程构建是 Gradle 的优势之一，Gradle 的多工程结构以单根树形的方式组织。 \n\n\n## 文件处理\n\n### `Project.file()`\n\n* `Project.file(Object)`方法可以用来创建 `File` 对象，参数可以是相对路径、绝对路径、 `File` 对象、`Path` 对象。\n* `Project.file(Object)` 方法的相对路径参照永远是 project 目录，而不是当前的 working dir。相对的 `new File(relative path)` 参照是 working dir，所以使用 `Project.file(Object)` 方法会获得更好的一致性，文件路径描述不会随命令行路径变化。\n\n### `FileCollection`\n\nGradle 提供了 `FileCollection` 接口来描述文件的集合；`FileCollection` 继承了 `Iterable<File>` 接口。\n\n* `FileCollection` 可以通过 `Project.files(Object...)` 方法来创建；这个方法和`Project.file(Object)` 一样是以 project 的目录为参照目录。\n* `FileCollection`支持 `+` (并集) 和 `-` (差集) 操作符。\n* `Project.files(Object...)`接受很多类型的参数：\n    - 相对路径&绝对路径&文件对象，以及它们的 Collection 对象。\n    - `FileCollection`对象。\n    - `Task`对象，使用task的output中的文件。\n    - `TaskOutputs`对象，使用其中的文件。\n    - 返回以上参数的 `Closure`，在每次获得 `FileCollection` 内容时运行 `Closure`，获得了延迟性和可变性。\n\n### `FileTree`\n\nGradle 提供了 `FileTree` 用来描述某个目录的整个层级结构；`FileTree` 继承了 `FileCollection` 接口。\n \n* FileTree可以通过 `Project.fileTree(java.util.Map)` 方法来创建。\n* 在作为 `Copy` 的参数时，`FileCollection` 不会保留目录层级结构，造成\"平铺\"的效果，而 `FileTree` 则会保留目录层级结构。\n* `Project.fileTree(java.util.Map)` 返回的 `ConfigurableFileTree` 继承了 `PatternFilterable`，支持 `include(String...)` 和 `exclude(String...)` 方法，例如 `tree.exclude '**/Abstract*'`。\n* 另外 `Project.fileTree(java.util.Map)` 的 `FileTree` 对象应用了一些默认exclude，详见[默认exclude列表](http://ant.apache.org/manual/dirtasks.html#defaultexcludes)。\n* `Project.zipTree(java.lang.Object)` 和 `Project.tarTree(java.lang.Object)` 方法可以返回表示 zip 文件、tar 文件的 `FileTree` 对象。\n\n### Util Tasks\n\n* 使用 `Copy` 类型的task来拷贝文件，`Copy.from(Object...)` 接受 `Project.files(Object...)` 形式参数，`Copy.into(Object)` 接受 `Project.file(Object)` 形式参数。\n* 也可以使用 `Project.copy(Closure closure)` 方便来拷贝文件，但是 `Copy` task 可以提供dependsOn以及增量执行等便利。\n* `Sync` 类型 task 继 承自`Copy`，拷贝后会删除 \"into\" 目录下的其他文件(不是拷贝过来的)。\n* Gradle 提供了`Zip`、`Tar`、`Jar`、`War`、`Ear`等一系列task类型来生成压缩文件；使用技巧dig源码为好。\n\n## 使用 Log\n\n* Gradle 的 log 从高到低分为6个等级：\n    - Error。\n    - Quiet，筛选运行参数 -q。\n    - Warning，筛选运行参数 -w。\n    - Lifecycle，运行 Gradle 时的默认筛选等级。\n    - Info，筛选运行参数 -i。\n    - Debug，筛选运行参数 -d。\n* 通过运行参数 -s 可以打印 Gradle 运行的 stacktrace。\n* 标准输出默认被视为是 Quiet 等级的 log；可以通过 `Project.logger` 属性或 `Scrpit.logger` 属性(`Logger`类型的对象)，来输出特定等级的log。\n* 通过 `Project.logging` 属性或 `Script.logging` 属性，可以获得一个 `LoggingManager` 对象；使用 `LoggingManager` 可以修改标准输出&错误输出对应的 log 等级(默认标准输出为 Quiet,错误输出为 Error)。\n* 通过 `Gradle.useLogger(Object)` 方法可以替换 Gradle 默认的输出 log 行为(这个方法具体都能干什么还是看源码为好)。\n\n\n\n","source":"_drafts/gradle-manual-write-script-1.md","raw":"---\ntitle: Gradle 脚本基础 - 编写 Gradle 脚本 (Part1)\nsubtitle: Gradle Manual 读书笔记 （2.1）\ncatalog: true\nheader-img: /img/header_img/tools-note-header.jpg\ntags:\n  - Gradle\ncategories:\n  - 读书笔记\n---\n\n## Gradle 脚本基础 \n\n### Gradle API\n* Gradle 脚本是基于 Groovy (或者 kotlin) 的 DSL (domain specific language), Gradle 脚本的默认编码是 utf-8。\n* Gradle 为每个工程创建了一个 `Project` 对象，并将这个 `Project` 对象 delegate 到 Gradle 脚本；所以未在脚本中定义的*方法*和*变量*都会去 `Project` 的命名空间中去查找，所以 `Project` 类提供了最基础的 Gradle 脚本 API。\n* 大部分 Gradle 脚本都会 delegate 到 `Project` 对象，但是也有例外。例如：settings.gradle 被 delegate 到 `Settings` 对象，init.gradle 被 delegate 到 `Gradle` 对象。\n* `Project` 提供了 `configure(Object o, Closure action)`接口，来用更容易阅读的方式来修改对象。\n* `Project` 提供了 `apply` 接口，来用其他 Gradle 脚本来修改对象 (最常见的就是修改 `Project` 对象)，代码示例：\n\n```groovy\ntask configure {\n    doLast {\n        def pos = new java.text.FieldPosition(10)\n        // Apply the script\n        apply from: 'other.gradle', to: pos\n        println pos.beginIndex\n        println pos.endIndex\n    }\n}\n```\nother.gradle\n```groovy\n// Set properties.\nbeginIndex = 1\nendIndex = 5\n```\n\n* 为了方便，Gradle 在每个脚本中做了一些默认 import。\n\n### 在 Gradle 脚本中使用变量   \n在 Gradle 脚本中声明变量有两种方式：局部变量和 Ext 属性 (extra properties)。\n\n* 局部变量就是单纯的 Groovy 变量，其可见范围也符合 Groovy 语法规则。\n* 大部分 Gradle domain model 都支持 extra properties；extra properties 通过 model 的 ext 属性来添加和访问。\n    - 当 extra property 被添加到对象中后，可以使用像对象属性一样的方式来访问(例如 {object referrence}.{property name})。\n    - Ext 的功能是基于 ExtraPropertiesExtension，ExtraPropertiesExtension 实际上的接口像个 Map；但是基于Groovy酷炫的语法功能，Ext 可以像正常属性一样访问，所以尽量使用访问属性语法(而不是类 Map 函数调用)来访问 Ext 属性。\n    - project 的 Ext在它的 subprojects 中依然可见。\n* 当访问对象的属性时、无论是正常属性还是通过Ext添加的属性、如果该属性不存在那么 Gradle 会抛出异常。\n\n### 在 Gradle 脚本中使用第三方库\n* 如果想在 gradle 脚本执行时使用一些第三方库，可以使用 `buildscript { }` 代码块来引入第三方库。\n* 将第三方库依赖添加到名为 \"classpath\" 的 configuration 上之后，第三方库中的 class 就可以在 gradle 脚本中被引用到。 \n* 多工程环境下，某工程通过 `buildscript { }` 引入的第三方库在其子工程中也能使用。\n* 每个 project 都会有名为 \"buildEnvironment\" 的任务，改任务会打印当前 project 的 gradle 脚本的所有第三方依赖 (和打印 java 工程依赖形式相同)。\n* `buildscript { }` 的 Closure 被代理到 `ScriptHandler` 类对象上，更多使用方法可以参照其 api。\n\n### 一些 Groovy 语法特性   \n* 可遍历的容器加入了`each(Closure action)`函数，例如`configurations.runtime.each { File f -> println f }`。\n* 属性访问会自动调用get和set方法。\n* 函数调用不用加括号。\n* list和map可以使用字面值：\n    - list字面值：`['object1', 'object2']`。\n    - map字面值：`[key1:'value1', key2: 'value2']`\n* 每个 Closure 可以 delegate 一个对象，以便在 Closure 可以直接使用对象的属性和方法。\n\n## Gradle 的生命周期\n\nGradle 的核心是建立起 task 的有向无环图，并按照顺序执行这些 task ；所以 Gradle 脚本的主要工作就是定义和配置 task。\n\n一次 Gradle 执行可以被分为三个阶段\n\n* 初始化阶段，确定 Project 结构并为每个 Project 生成 `Project` 对象(settings.gradle)。\n* 配置阶段，对所有参与这次 Gradle 执行 Project 进行配置(build.gradle)。\n* 执行阶段，确定 taskGraph，并依次执行 task。\n\n### 定位 setting.gradle\n\n初始化阶段 Gradle 会寻找 setting.gradle 脚本，在执行该脚本后创建 Project 对象(多个)。\n\n* 寻找 setting.gradle 是为了确定当次执行是多工程还是单工程，寻找规则如下：\n    - 在相邻目录中的名为 'master' 的目录中寻找(flat 结构，所以 flat 结构的 rootProject 目录需要被命名为 'master')。\n    - 在父目录中寻找。\n    - 如果没有找到，或者执行目录没有在 setting.gradle 中定义，当次执行为单工程；否则为多工程。\n* 可以在命令行中加入 `-u` 参数，强制当次执行为单工程；但是如果执行目录中存在 setting.gradle，`-u` 参数被忽略。\n\n### settings.gradle 和多工程结构\n\n* \"Settings文件\"用于定义多工程结构，其默认命名是 settings.gradle；多工程构建时，root project 目录下必须存在 settings.gradle；正如 build.gradle 会 delegate 一个 `Project` 对象，settings.gradle 会 delegate 一个 `Settings` 对象。\n* 多工程结构被定为单根树形结构，根节点被称为 rootProject；默认配置下，rootProject 物理路径就是 setting.gradle 文件所在的目录，subProject 物理路径结构的和 Project 树结构相同；这种默认配置可以在 setting.gradle 中修改。\n* `Settings.getRootProject()` 和 `Settings.project(String)` 方法会返回 `ProjectDescriptor` 对象，可以通过 `ProjectDescriptor` 对象来修改 Project 的物理路径、build 脚本名字等。\n\n### 监听生命周期\n\n* `Project.beforeEvaluate(Closure)`、`Project.afterEvaluate(Closure)`、`Gradle.beforeProject(Closure)`、`Gradle.afterProject(Closure)`等方法可以用于监听 Project 的 evaluate 过程。\n* 通过 `Project.tasks` 和 `Gradle.taskGraph` 的监听方法，可以监听 task 的创建过程和执行过程。\n\n## 多工程构建\n\n多工程构建是 Gradle 的优势之一，Gradle 的多工程结构以单根树形的方式组织。 \n\n\n## 文件处理\n\n### `Project.file()`\n\n* `Project.file(Object)`方法可以用来创建 `File` 对象，参数可以是相对路径、绝对路径、 `File` 对象、`Path` 对象。\n* `Project.file(Object)` 方法的相对路径参照永远是 project 目录，而不是当前的 working dir。相对的 `new File(relative path)` 参照是 working dir，所以使用 `Project.file(Object)` 方法会获得更好的一致性，文件路径描述不会随命令行路径变化。\n\n### `FileCollection`\n\nGradle 提供了 `FileCollection` 接口来描述文件的集合；`FileCollection` 继承了 `Iterable<File>` 接口。\n\n* `FileCollection` 可以通过 `Project.files(Object...)` 方法来创建；这个方法和`Project.file(Object)` 一样是以 project 的目录为参照目录。\n* `FileCollection`支持 `+` (并集) 和 `-` (差集) 操作符。\n* `Project.files(Object...)`接受很多类型的参数：\n    - 相对路径&绝对路径&文件对象，以及它们的 Collection 对象。\n    - `FileCollection`对象。\n    - `Task`对象，使用task的output中的文件。\n    - `TaskOutputs`对象，使用其中的文件。\n    - 返回以上参数的 `Closure`，在每次获得 `FileCollection` 内容时运行 `Closure`，获得了延迟性和可变性。\n\n### `FileTree`\n\nGradle 提供了 `FileTree` 用来描述某个目录的整个层级结构；`FileTree` 继承了 `FileCollection` 接口。\n \n* FileTree可以通过 `Project.fileTree(java.util.Map)` 方法来创建。\n* 在作为 `Copy` 的参数时，`FileCollection` 不会保留目录层级结构，造成\"平铺\"的效果，而 `FileTree` 则会保留目录层级结构。\n* `Project.fileTree(java.util.Map)` 返回的 `ConfigurableFileTree` 继承了 `PatternFilterable`，支持 `include(String...)` 和 `exclude(String...)` 方法，例如 `tree.exclude '**/Abstract*'`。\n* 另外 `Project.fileTree(java.util.Map)` 的 `FileTree` 对象应用了一些默认exclude，详见[默认exclude列表](http://ant.apache.org/manual/dirtasks.html#defaultexcludes)。\n* `Project.zipTree(java.lang.Object)` 和 `Project.tarTree(java.lang.Object)` 方法可以返回表示 zip 文件、tar 文件的 `FileTree` 对象。\n\n### Util Tasks\n\n* 使用 `Copy` 类型的task来拷贝文件，`Copy.from(Object...)` 接受 `Project.files(Object...)` 形式参数，`Copy.into(Object)` 接受 `Project.file(Object)` 形式参数。\n* 也可以使用 `Project.copy(Closure closure)` 方便来拷贝文件，但是 `Copy` task 可以提供dependsOn以及增量执行等便利。\n* `Sync` 类型 task 继 承自`Copy`，拷贝后会删除 \"into\" 目录下的其他文件(不是拷贝过来的)。\n* Gradle 提供了`Zip`、`Tar`、`Jar`、`War`、`Ear`等一系列task类型来生成压缩文件；使用技巧dig源码为好。\n\n## 使用 Log\n\n* Gradle 的 log 从高到低分为6个等级：\n    - Error。\n    - Quiet，筛选运行参数 -q。\n    - Warning，筛选运行参数 -w。\n    - Lifecycle，运行 Gradle 时的默认筛选等级。\n    - Info，筛选运行参数 -i。\n    - Debug，筛选运行参数 -d。\n* 通过运行参数 -s 可以打印 Gradle 运行的 stacktrace。\n* 标准输出默认被视为是 Quiet 等级的 log；可以通过 `Project.logger` 属性或 `Scrpit.logger` 属性(`Logger`类型的对象)，来输出特定等级的log。\n* 通过 `Project.logging` 属性或 `Script.logging` 属性，可以获得一个 `LoggingManager` 对象；使用 `LoggingManager` 可以修改标准输出&错误输出对应的 log 等级(默认标准输出为 Quiet,错误输出为 Error)。\n* 通过 `Gradle.useLogger(Object)` 方法可以替换 Gradle 默认的输出 log 行为(这个方法具体都能干什么还是看源码为好)。\n\n\n\n","slug":"gradle-manual-write-script-1","published":0,"date":"2019-06-14T02:58:36.000Z","updated":"2019-06-14T02:58:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ou00083mrf0xqo5fmy","content":"<h2 id=\"Gradle-脚本基础\"><a href=\"#Gradle-脚本基础\" class=\"headerlink\" title=\"Gradle 脚本基础\"></a>Gradle 脚本基础</h2><h3 id=\"Gradle-API\"><a href=\"#Gradle-API\" class=\"headerlink\" title=\"Gradle API\"></a>Gradle API</h3><ul>\n<li>Gradle 脚本是基于 Groovy (或者 kotlin) 的 DSL (domain specific language), Gradle 脚本的默认编码是 utf-8。</li>\n<li>Gradle 为每个工程创建了一个 <code>Project</code> 对象，并将这个 <code>Project</code> 对象 delegate 到 Gradle 脚本；所以未在脚本中定义的<em>方法</em>和<em>变量</em>都会去 <code>Project</code> 的命名空间中去查找，所以 <code>Project</code> 类提供了最基础的 Gradle 脚本 API。</li>\n<li>大部分 Gradle 脚本都会 delegate 到 <code>Project</code> 对象，但是也有例外。例如：settings.gradle 被 delegate 到 <code>Settings</code> 对象，init.gradle 被 delegate 到 <code>Gradle</code> 对象。</li>\n<li><code>Project</code> 提供了 <code>configure(Object o, Closure action)</code>接口，来用更容易阅读的方式来修改对象。</li>\n<li><code>Project</code> 提供了 <code>apply</code> 接口，来用其他 Gradle 脚本来修改对象 (最常见的就是修改 <code>Project</code> 对象)，代码示例：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task configure &#123;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> pos = <span class=\"keyword\">new</span> java.text.FieldPosition(<span class=\"number\">10</span>)</span><br><span class=\"line\">        <span class=\"comment\">// Apply the script</span></span><br><span class=\"line\">        apply <span class=\"attr\">from:</span> <span class=\"string\">&#x27;other.gradle&#x27;</span>, <span class=\"attr\">to:</span> pos</span><br><span class=\"line\">        println pos.beginIndex</span><br><span class=\"line\">        println pos.endIndex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>other.gradle<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Set properties.</span></span><br><span class=\"line\">beginIndex = <span class=\"number\">1</span></span><br><span class=\"line\">endIndex = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>为了方便，Gradle 在每个脚本中做了一些默认 import。</li>\n</ul>\n<h3 id=\"在-Gradle-脚本中使用变量\"><a href=\"#在-Gradle-脚本中使用变量\" class=\"headerlink\" title=\"在 Gradle 脚本中使用变量\"></a>在 Gradle 脚本中使用变量</h3><p>在 Gradle 脚本中声明变量有两种方式：局部变量和 Ext 属性 (extra properties)。</p>\n<ul>\n<li>局部变量就是单纯的 Groovy 变量，其可见范围也符合 Groovy 语法规则。</li>\n<li>大部分 Gradle domain model 都支持 extra properties；extra properties 通过 model 的 ext 属性来添加和访问。<ul>\n<li>当 extra property 被添加到对象中后，可以使用像对象属性一样的方式来访问(例如 {object referrence}.{property name})。</li>\n<li>Ext 的功能是基于 ExtraPropertiesExtension，ExtraPropertiesExtension 实际上的接口像个 Map；但是基于Groovy酷炫的语法功能，Ext 可以像正常属性一样访问，所以尽量使用访问属性语法(而不是类 Map 函数调用)来访问 Ext 属性。</li>\n<li>project 的 Ext在它的 subprojects 中依然可见。</li>\n</ul>\n</li>\n<li>当访问对象的属性时、无论是正常属性还是通过Ext添加的属性、如果该属性不存在那么 Gradle 会抛出异常。</li>\n</ul>\n<h3 id=\"在-Gradle-脚本中使用第三方库\"><a href=\"#在-Gradle-脚本中使用第三方库\" class=\"headerlink\" title=\"在 Gradle 脚本中使用第三方库\"></a>在 Gradle 脚本中使用第三方库</h3><ul>\n<li>如果想在 gradle 脚本执行时使用一些第三方库，可以使用 <code>buildscript &#123; &#125;</code> 代码块来引入第三方库。</li>\n<li>将第三方库依赖添加到名为 “classpath” 的 configuration 上之后，第三方库中的 class 就可以在 gradle 脚本中被引用到。 </li>\n<li>多工程环境下，某工程通过 <code>buildscript &#123; &#125;</code> 引入的第三方库在其子工程中也能使用。</li>\n<li>每个 project 都会有名为 “buildEnvironment” 的任务，改任务会打印当前 project 的 gradle 脚本的所有第三方依赖 (和打印 java 工程依赖形式相同)。</li>\n<li><code>buildscript &#123; &#125;</code> 的 Closure 被代理到 <code>ScriptHandler</code> 类对象上，更多使用方法可以参照其 api。</li>\n</ul>\n<h3 id=\"一些-Groovy-语法特性\"><a href=\"#一些-Groovy-语法特性\" class=\"headerlink\" title=\"一些 Groovy 语法特性\"></a>一些 Groovy 语法特性</h3><ul>\n<li>可遍历的容器加入了<code>each(Closure action)</code>函数，例如<code>configurations.runtime.each &#123; File f -&gt; println f &#125;</code>。</li>\n<li>属性访问会自动调用get和set方法。</li>\n<li>函数调用不用加括号。</li>\n<li>list和map可以使用字面值：<ul>\n<li>list字面值：<code>[&#39;object1&#39;, &#39;object2&#39;]</code>。</li>\n<li>map字面值：<code>[key1:&#39;value1&#39;, key2: &#39;value2&#39;]</code></li>\n</ul>\n</li>\n<li>每个 Closure 可以 delegate 一个对象，以便在 Closure 可以直接使用对象的属性和方法。</li>\n</ul>\n<h2 id=\"Gradle-的生命周期\"><a href=\"#Gradle-的生命周期\" class=\"headerlink\" title=\"Gradle 的生命周期\"></a>Gradle 的生命周期</h2><p>Gradle 的核心是建立起 task 的有向无环图，并按照顺序执行这些 task ；所以 Gradle 脚本的主要工作就是定义和配置 task。</p>\n<p>一次 Gradle 执行可以被分为三个阶段</p>\n<ul>\n<li>初始化阶段，确定 Project 结构并为每个 Project 生成 <code>Project</code> 对象(settings.gradle)。</li>\n<li>配置阶段，对所有参与这次 Gradle 执行 Project 进行配置(build.gradle)。</li>\n<li>执行阶段，确定 taskGraph，并依次执行 task。</li>\n</ul>\n<h3 id=\"定位-setting-gradle\"><a href=\"#定位-setting-gradle\" class=\"headerlink\" title=\"定位 setting.gradle\"></a>定位 setting.gradle</h3><p>初始化阶段 Gradle 会寻找 setting.gradle 脚本，在执行该脚本后创建 Project 对象(多个)。</p>\n<ul>\n<li>寻找 setting.gradle 是为了确定当次执行是多工程还是单工程，寻找规则如下：<ul>\n<li>在相邻目录中的名为 ‘master’ 的目录中寻找(flat 结构，所以 flat 结构的 rootProject 目录需要被命名为 ‘master’)。</li>\n<li>在父目录中寻找。</li>\n<li>如果没有找到，或者执行目录没有在 setting.gradle 中定义，当次执行为单工程；否则为多工程。</li>\n</ul>\n</li>\n<li>可以在命令行中加入 <code>-u</code> 参数，强制当次执行为单工程；但是如果执行目录中存在 setting.gradle，<code>-u</code> 参数被忽略。</li>\n</ul>\n<h3 id=\"settings-gradle-和多工程结构\"><a href=\"#settings-gradle-和多工程结构\" class=\"headerlink\" title=\"settings.gradle 和多工程结构\"></a>settings.gradle 和多工程结构</h3><ul>\n<li>“Settings文件”用于定义多工程结构，其默认命名是 settings.gradle；多工程构建时，root project 目录下必须存在 settings.gradle；正如 build.gradle 会 delegate 一个 <code>Project</code> 对象，settings.gradle 会 delegate 一个 <code>Settings</code> 对象。</li>\n<li>多工程结构被定为单根树形结构，根节点被称为 rootProject；默认配置下，rootProject 物理路径就是 setting.gradle 文件所在的目录，subProject 物理路径结构的和 Project 树结构相同；这种默认配置可以在 setting.gradle 中修改。</li>\n<li><code>Settings.getRootProject()</code> 和 <code>Settings.project(String)</code> 方法会返回 <code>ProjectDescriptor</code> 对象，可以通过 <code>ProjectDescriptor</code> 对象来修改 Project 的物理路径、build 脚本名字等。</li>\n</ul>\n<h3 id=\"监听生命周期\"><a href=\"#监听生命周期\" class=\"headerlink\" title=\"监听生命周期\"></a>监听生命周期</h3><ul>\n<li><code>Project.beforeEvaluate(Closure)</code>、<code>Project.afterEvaluate(Closure)</code>、<code>Gradle.beforeProject(Closure)</code>、<code>Gradle.afterProject(Closure)</code>等方法可以用于监听 Project 的 evaluate 过程。</li>\n<li>通过 <code>Project.tasks</code> 和 <code>Gradle.taskGraph</code> 的监听方法，可以监听 task 的创建过程和执行过程。</li>\n</ul>\n<h2 id=\"多工程构建\"><a href=\"#多工程构建\" class=\"headerlink\" title=\"多工程构建\"></a>多工程构建</h2><p>多工程构建是 Gradle 的优势之一，Gradle 的多工程结构以单根树形的方式组织。 </p>\n<h2 id=\"文件处理\"><a href=\"#文件处理\" class=\"headerlink\" title=\"文件处理\"></a>文件处理</h2><h3 id=\"Project-file\"><a href=\"#Project-file\" class=\"headerlink\" title=\"Project.file()\"></a><code>Project.file()</code></h3><ul>\n<li><code>Project.file(Object)</code>方法可以用来创建 <code>File</code> 对象，参数可以是相对路径、绝对路径、 <code>File</code> 对象、<code>Path</code> 对象。</li>\n<li><code>Project.file(Object)</code> 方法的相对路径参照永远是 project 目录，而不是当前的 working dir。相对的 <code>new File(relative path)</code> 参照是 working dir，所以使用 <code>Project.file(Object)</code> 方法会获得更好的一致性，文件路径描述不会随命令行路径变化。</li>\n</ul>\n<h3 id=\"FileCollection\"><a href=\"#FileCollection\" class=\"headerlink\" title=\"FileCollection\"></a><code>FileCollection</code></h3><p>Gradle 提供了 <code>FileCollection</code> 接口来描述文件的集合；<code>FileCollection</code> 继承了 <code>Iterable&lt;File&gt;</code> 接口。</p>\n<ul>\n<li><code>FileCollection</code> 可以通过 <code>Project.files(Object...)</code> 方法来创建；这个方法和<code>Project.file(Object)</code> 一样是以 project 的目录为参照目录。</li>\n<li><code>FileCollection</code>支持 <code>+</code> (并集) 和 <code>-</code> (差集) 操作符。</li>\n<li><code>Project.files(Object...)</code>接受很多类型的参数：<ul>\n<li>相对路径&amp;绝对路径&amp;文件对象，以及它们的 Collection 对象。</li>\n<li><code>FileCollection</code>对象。</li>\n<li><code>Task</code>对象，使用task的output中的文件。</li>\n<li><code>TaskOutputs</code>对象，使用其中的文件。</li>\n<li>返回以上参数的 <code>Closure</code>，在每次获得 <code>FileCollection</code> 内容时运行 <code>Closure</code>，获得了延迟性和可变性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"FileTree\"><a href=\"#FileTree\" class=\"headerlink\" title=\"FileTree\"></a><code>FileTree</code></h3><p>Gradle 提供了 <code>FileTree</code> 用来描述某个目录的整个层级结构；<code>FileTree</code> 继承了 <code>FileCollection</code> 接口。</p>\n<ul>\n<li>FileTree可以通过 <code>Project.fileTree(java.util.Map)</code> 方法来创建。</li>\n<li>在作为 <code>Copy</code> 的参数时，<code>FileCollection</code> 不会保留目录层级结构，造成”平铺”的效果，而 <code>FileTree</code> 则会保留目录层级结构。</li>\n<li><code>Project.fileTree(java.util.Map)</code> 返回的 <code>ConfigurableFileTree</code> 继承了 <code>PatternFilterable</code>，支持 <code>include(String...)</code> 和 <code>exclude(String...)</code> 方法，例如 <code>tree.exclude &#39;**/Abstract*&#39;</code>。</li>\n<li>另外 <code>Project.fileTree(java.util.Map)</code> 的 <code>FileTree</code> 对象应用了一些默认exclude，详见<a href=\"http://ant.apache.org/manual/dirtasks.html#defaultexcludes\">默认exclude列表</a>。</li>\n<li><code>Project.zipTree(java.lang.Object)</code> 和 <code>Project.tarTree(java.lang.Object)</code> 方法可以返回表示 zip 文件、tar 文件的 <code>FileTree</code> 对象。</li>\n</ul>\n<h3 id=\"Util-Tasks\"><a href=\"#Util-Tasks\" class=\"headerlink\" title=\"Util Tasks\"></a>Util Tasks</h3><ul>\n<li>使用 <code>Copy</code> 类型的task来拷贝文件，<code>Copy.from(Object...)</code> 接受 <code>Project.files(Object...)</code> 形式参数，<code>Copy.into(Object)</code> 接受 <code>Project.file(Object)</code> 形式参数。</li>\n<li>也可以使用 <code>Project.copy(Closure closure)</code> 方便来拷贝文件，但是 <code>Copy</code> task 可以提供dependsOn以及增量执行等便利。</li>\n<li><code>Sync</code> 类型 task 继 承自<code>Copy</code>，拷贝后会删除 “into” 目录下的其他文件(不是拷贝过来的)。</li>\n<li>Gradle 提供了<code>Zip</code>、<code>Tar</code>、<code>Jar</code>、<code>War</code>、<code>Ear</code>等一系列task类型来生成压缩文件；使用技巧dig源码为好。</li>\n</ul>\n<h2 id=\"使用-Log\"><a href=\"#使用-Log\" class=\"headerlink\" title=\"使用 Log\"></a>使用 Log</h2><ul>\n<li>Gradle 的 log 从高到低分为6个等级：<ul>\n<li>Error。</li>\n<li>Quiet，筛选运行参数 -q。</li>\n<li>Warning，筛选运行参数 -w。</li>\n<li>Lifecycle，运行 Gradle 时的默认筛选等级。</li>\n<li>Info，筛选运行参数 -i。</li>\n<li>Debug，筛选运行参数 -d。</li>\n</ul>\n</li>\n<li>通过运行参数 -s 可以打印 Gradle 运行的 stacktrace。</li>\n<li>标准输出默认被视为是 Quiet 等级的 log；可以通过 <code>Project.logger</code> 属性或 <code>Scrpit.logger</code> 属性(<code>Logger</code>类型的对象)，来输出特定等级的log。</li>\n<li>通过 <code>Project.logging</code> 属性或 <code>Script.logging</code> 属性，可以获得一个 <code>LoggingManager</code> 对象；使用 <code>LoggingManager</code> 可以修改标准输出&amp;错误输出对应的 log 等级(默认标准输出为 Quiet,错误输出为 Error)。</li>\n<li>通过 <code>Gradle.useLogger(Object)</code> 方法可以替换 Gradle 默认的输出 log 行为(这个方法具体都能干什么还是看源码为好)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Gradle-脚本基础\"><a href=\"#Gradle-脚本基础\" class=\"headerlink\" title=\"Gradle 脚本基础\"></a>Gradle 脚本基础</h2><h3 id=\"Gradle-API\"><a href=\"#Gradle-API\" class=\"headerlink\" title=\"Gradle API\"></a>Gradle API</h3><ul>\n<li>Gradle 脚本是基于 Groovy (或者 kotlin) 的 DSL (domain specific language), Gradle 脚本的默认编码是 utf-8。</li>\n<li>Gradle 为每个工程创建了一个 <code>Project</code> 对象，并将这个 <code>Project</code> 对象 delegate 到 Gradle 脚本；所以未在脚本中定义的<em>方法</em>和<em>变量</em>都会去 <code>Project</code> 的命名空间中去查找，所以 <code>Project</code> 类提供了最基础的 Gradle 脚本 API。</li>\n<li>大部分 Gradle 脚本都会 delegate 到 <code>Project</code> 对象，但是也有例外。例如：settings.gradle 被 delegate 到 <code>Settings</code> 对象，init.gradle 被 delegate 到 <code>Gradle</code> 对象。</li>\n<li><code>Project</code> 提供了 <code>configure(Object o, Closure action)</code>接口，来用更容易阅读的方式来修改对象。</li>\n<li><code>Project</code> 提供了 <code>apply</code> 接口，来用其他 Gradle 脚本来修改对象 (最常见的就是修改 <code>Project</code> 对象)，代码示例：</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task configure &#123;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> pos = <span class=\"keyword\">new</span> java.text.FieldPosition(<span class=\"number\">10</span>)</span><br><span class=\"line\">        <span class=\"comment\">// Apply the script</span></span><br><span class=\"line\">        apply <span class=\"attr\">from:</span> <span class=\"string\">&#x27;other.gradle&#x27;</span>, <span class=\"attr\">to:</span> pos</span><br><span class=\"line\">        println pos.beginIndex</span><br><span class=\"line\">        println pos.endIndex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>other.gradle<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Set properties.</span></span><br><span class=\"line\">beginIndex = <span class=\"number\">1</span></span><br><span class=\"line\">endIndex = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>为了方便，Gradle 在每个脚本中做了一些默认 import。</li>\n</ul>\n<h3 id=\"在-Gradle-脚本中使用变量\"><a href=\"#在-Gradle-脚本中使用变量\" class=\"headerlink\" title=\"在 Gradle 脚本中使用变量\"></a>在 Gradle 脚本中使用变量</h3><p>在 Gradle 脚本中声明变量有两种方式：局部变量和 Ext 属性 (extra properties)。</p>\n<ul>\n<li>局部变量就是单纯的 Groovy 变量，其可见范围也符合 Groovy 语法规则。</li>\n<li>大部分 Gradle domain model 都支持 extra properties；extra properties 通过 model 的 ext 属性来添加和访问。<ul>\n<li>当 extra property 被添加到对象中后，可以使用像对象属性一样的方式来访问(例如 {object referrence}.{property name})。</li>\n<li>Ext 的功能是基于 ExtraPropertiesExtension，ExtraPropertiesExtension 实际上的接口像个 Map；但是基于Groovy酷炫的语法功能，Ext 可以像正常属性一样访问，所以尽量使用访问属性语法(而不是类 Map 函数调用)来访问 Ext 属性。</li>\n<li>project 的 Ext在它的 subprojects 中依然可见。</li>\n</ul>\n</li>\n<li>当访问对象的属性时、无论是正常属性还是通过Ext添加的属性、如果该属性不存在那么 Gradle 会抛出异常。</li>\n</ul>\n<h3 id=\"在-Gradle-脚本中使用第三方库\"><a href=\"#在-Gradle-脚本中使用第三方库\" class=\"headerlink\" title=\"在 Gradle 脚本中使用第三方库\"></a>在 Gradle 脚本中使用第三方库</h3><ul>\n<li>如果想在 gradle 脚本执行时使用一些第三方库，可以使用 <code>buildscript &#123; &#125;</code> 代码块来引入第三方库。</li>\n<li>将第三方库依赖添加到名为 “classpath” 的 configuration 上之后，第三方库中的 class 就可以在 gradle 脚本中被引用到。 </li>\n<li>多工程环境下，某工程通过 <code>buildscript &#123; &#125;</code> 引入的第三方库在其子工程中也能使用。</li>\n<li>每个 project 都会有名为 “buildEnvironment” 的任务，改任务会打印当前 project 的 gradle 脚本的所有第三方依赖 (和打印 java 工程依赖形式相同)。</li>\n<li><code>buildscript &#123; &#125;</code> 的 Closure 被代理到 <code>ScriptHandler</code> 类对象上，更多使用方法可以参照其 api。</li>\n</ul>\n<h3 id=\"一些-Groovy-语法特性\"><a href=\"#一些-Groovy-语法特性\" class=\"headerlink\" title=\"一些 Groovy 语法特性\"></a>一些 Groovy 语法特性</h3><ul>\n<li>可遍历的容器加入了<code>each(Closure action)</code>函数，例如<code>configurations.runtime.each &#123; File f -&gt; println f &#125;</code>。</li>\n<li>属性访问会自动调用get和set方法。</li>\n<li>函数调用不用加括号。</li>\n<li>list和map可以使用字面值：<ul>\n<li>list字面值：<code>[&#39;object1&#39;, &#39;object2&#39;]</code>。</li>\n<li>map字面值：<code>[key1:&#39;value1&#39;, key2: &#39;value2&#39;]</code></li>\n</ul>\n</li>\n<li>每个 Closure 可以 delegate 一个对象，以便在 Closure 可以直接使用对象的属性和方法。</li>\n</ul>\n<h2 id=\"Gradle-的生命周期\"><a href=\"#Gradle-的生命周期\" class=\"headerlink\" title=\"Gradle 的生命周期\"></a>Gradle 的生命周期</h2><p>Gradle 的核心是建立起 task 的有向无环图，并按照顺序执行这些 task ；所以 Gradle 脚本的主要工作就是定义和配置 task。</p>\n<p>一次 Gradle 执行可以被分为三个阶段</p>\n<ul>\n<li>初始化阶段，确定 Project 结构并为每个 Project 生成 <code>Project</code> 对象(settings.gradle)。</li>\n<li>配置阶段，对所有参与这次 Gradle 执行 Project 进行配置(build.gradle)。</li>\n<li>执行阶段，确定 taskGraph，并依次执行 task。</li>\n</ul>\n<h3 id=\"定位-setting-gradle\"><a href=\"#定位-setting-gradle\" class=\"headerlink\" title=\"定位 setting.gradle\"></a>定位 setting.gradle</h3><p>初始化阶段 Gradle 会寻找 setting.gradle 脚本，在执行该脚本后创建 Project 对象(多个)。</p>\n<ul>\n<li>寻找 setting.gradle 是为了确定当次执行是多工程还是单工程，寻找规则如下：<ul>\n<li>在相邻目录中的名为 ‘master’ 的目录中寻找(flat 结构，所以 flat 结构的 rootProject 目录需要被命名为 ‘master’)。</li>\n<li>在父目录中寻找。</li>\n<li>如果没有找到，或者执行目录没有在 setting.gradle 中定义，当次执行为单工程；否则为多工程。</li>\n</ul>\n</li>\n<li>可以在命令行中加入 <code>-u</code> 参数，强制当次执行为单工程；但是如果执行目录中存在 setting.gradle，<code>-u</code> 参数被忽略。</li>\n</ul>\n<h3 id=\"settings-gradle-和多工程结构\"><a href=\"#settings-gradle-和多工程结构\" class=\"headerlink\" title=\"settings.gradle 和多工程结构\"></a>settings.gradle 和多工程结构</h3><ul>\n<li>“Settings文件”用于定义多工程结构，其默认命名是 settings.gradle；多工程构建时，root project 目录下必须存在 settings.gradle；正如 build.gradle 会 delegate 一个 <code>Project</code> 对象，settings.gradle 会 delegate 一个 <code>Settings</code> 对象。</li>\n<li>多工程结构被定为单根树形结构，根节点被称为 rootProject；默认配置下，rootProject 物理路径就是 setting.gradle 文件所在的目录，subProject 物理路径结构的和 Project 树结构相同；这种默认配置可以在 setting.gradle 中修改。</li>\n<li><code>Settings.getRootProject()</code> 和 <code>Settings.project(String)</code> 方法会返回 <code>ProjectDescriptor</code> 对象，可以通过 <code>ProjectDescriptor</code> 对象来修改 Project 的物理路径、build 脚本名字等。</li>\n</ul>\n<h3 id=\"监听生命周期\"><a href=\"#监听生命周期\" class=\"headerlink\" title=\"监听生命周期\"></a>监听生命周期</h3><ul>\n<li><code>Project.beforeEvaluate(Closure)</code>、<code>Project.afterEvaluate(Closure)</code>、<code>Gradle.beforeProject(Closure)</code>、<code>Gradle.afterProject(Closure)</code>等方法可以用于监听 Project 的 evaluate 过程。</li>\n<li>通过 <code>Project.tasks</code> 和 <code>Gradle.taskGraph</code> 的监听方法，可以监听 task 的创建过程和执行过程。</li>\n</ul>\n<h2 id=\"多工程构建\"><a href=\"#多工程构建\" class=\"headerlink\" title=\"多工程构建\"></a>多工程构建</h2><p>多工程构建是 Gradle 的优势之一，Gradle 的多工程结构以单根树形的方式组织。 </p>\n<h2 id=\"文件处理\"><a href=\"#文件处理\" class=\"headerlink\" title=\"文件处理\"></a>文件处理</h2><h3 id=\"Project-file\"><a href=\"#Project-file\" class=\"headerlink\" title=\"Project.file()\"></a><code>Project.file()</code></h3><ul>\n<li><code>Project.file(Object)</code>方法可以用来创建 <code>File</code> 对象，参数可以是相对路径、绝对路径、 <code>File</code> 对象、<code>Path</code> 对象。</li>\n<li><code>Project.file(Object)</code> 方法的相对路径参照永远是 project 目录，而不是当前的 working dir。相对的 <code>new File(relative path)</code> 参照是 working dir，所以使用 <code>Project.file(Object)</code> 方法会获得更好的一致性，文件路径描述不会随命令行路径变化。</li>\n</ul>\n<h3 id=\"FileCollection\"><a href=\"#FileCollection\" class=\"headerlink\" title=\"FileCollection\"></a><code>FileCollection</code></h3><p>Gradle 提供了 <code>FileCollection</code> 接口来描述文件的集合；<code>FileCollection</code> 继承了 <code>Iterable&lt;File&gt;</code> 接口。</p>\n<ul>\n<li><code>FileCollection</code> 可以通过 <code>Project.files(Object...)</code> 方法来创建；这个方法和<code>Project.file(Object)</code> 一样是以 project 的目录为参照目录。</li>\n<li><code>FileCollection</code>支持 <code>+</code> (并集) 和 <code>-</code> (差集) 操作符。</li>\n<li><code>Project.files(Object...)</code>接受很多类型的参数：<ul>\n<li>相对路径&amp;绝对路径&amp;文件对象，以及它们的 Collection 对象。</li>\n<li><code>FileCollection</code>对象。</li>\n<li><code>Task</code>对象，使用task的output中的文件。</li>\n<li><code>TaskOutputs</code>对象，使用其中的文件。</li>\n<li>返回以上参数的 <code>Closure</code>，在每次获得 <code>FileCollection</code> 内容时运行 <code>Closure</code>，获得了延迟性和可变性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"FileTree\"><a href=\"#FileTree\" class=\"headerlink\" title=\"FileTree\"></a><code>FileTree</code></h3><p>Gradle 提供了 <code>FileTree</code> 用来描述某个目录的整个层级结构；<code>FileTree</code> 继承了 <code>FileCollection</code> 接口。</p>\n<ul>\n<li>FileTree可以通过 <code>Project.fileTree(java.util.Map)</code> 方法来创建。</li>\n<li>在作为 <code>Copy</code> 的参数时，<code>FileCollection</code> 不会保留目录层级结构，造成”平铺”的效果，而 <code>FileTree</code> 则会保留目录层级结构。</li>\n<li><code>Project.fileTree(java.util.Map)</code> 返回的 <code>ConfigurableFileTree</code> 继承了 <code>PatternFilterable</code>，支持 <code>include(String...)</code> 和 <code>exclude(String...)</code> 方法，例如 <code>tree.exclude &#39;**/Abstract*&#39;</code>。</li>\n<li>另外 <code>Project.fileTree(java.util.Map)</code> 的 <code>FileTree</code> 对象应用了一些默认exclude，详见<a href=\"http://ant.apache.org/manual/dirtasks.html#defaultexcludes\">默认exclude列表</a>。</li>\n<li><code>Project.zipTree(java.lang.Object)</code> 和 <code>Project.tarTree(java.lang.Object)</code> 方法可以返回表示 zip 文件、tar 文件的 <code>FileTree</code> 对象。</li>\n</ul>\n<h3 id=\"Util-Tasks\"><a href=\"#Util-Tasks\" class=\"headerlink\" title=\"Util Tasks\"></a>Util Tasks</h3><ul>\n<li>使用 <code>Copy</code> 类型的task来拷贝文件，<code>Copy.from(Object...)</code> 接受 <code>Project.files(Object...)</code> 形式参数，<code>Copy.into(Object)</code> 接受 <code>Project.file(Object)</code> 形式参数。</li>\n<li>也可以使用 <code>Project.copy(Closure closure)</code> 方便来拷贝文件，但是 <code>Copy</code> task 可以提供dependsOn以及增量执行等便利。</li>\n<li><code>Sync</code> 类型 task 继 承自<code>Copy</code>，拷贝后会删除 “into” 目录下的其他文件(不是拷贝过来的)。</li>\n<li>Gradle 提供了<code>Zip</code>、<code>Tar</code>、<code>Jar</code>、<code>War</code>、<code>Ear</code>等一系列task类型来生成压缩文件；使用技巧dig源码为好。</li>\n</ul>\n<h2 id=\"使用-Log\"><a href=\"#使用-Log\" class=\"headerlink\" title=\"使用 Log\"></a>使用 Log</h2><ul>\n<li>Gradle 的 log 从高到低分为6个等级：<ul>\n<li>Error。</li>\n<li>Quiet，筛选运行参数 -q。</li>\n<li>Warning，筛选运行参数 -w。</li>\n<li>Lifecycle，运行 Gradle 时的默认筛选等级。</li>\n<li>Info，筛选运行参数 -i。</li>\n<li>Debug，筛选运行参数 -d。</li>\n</ul>\n</li>\n<li>通过运行参数 -s 可以打印 Gradle 运行的 stacktrace。</li>\n<li>标准输出默认被视为是 Quiet 等级的 log；可以通过 <code>Project.logger</code> 属性或 <code>Scrpit.logger</code> 属性(<code>Logger</code>类型的对象)，来输出特定等级的log。</li>\n<li>通过 <code>Project.logging</code> 属性或 <code>Script.logging</code> 属性，可以获得一个 <code>LoggingManager</code> 对象；使用 <code>LoggingManager</code> 可以修改标准输出&amp;错误输出对应的 log 等级(默认标准输出为 Quiet,错误输出为 Error)。</li>\n<li>通过 <code>Gradle.useLogger(Object)</code> 方法可以替换 Gradle 默认的输出 log 行为(这个方法具体都能干什么还是看源码为好)。</li>\n</ul>\n"},{"title":"使用 Task - 编写 Gradle 脚本 (Part2)","subtitle":"Gradle Manual 读书笔记 （2.2）","catalog":true,"header-img":"/img/header_img/tools-note-header.jpg","_content":"\n## Task(稍稍)进阶\n\n* 在执行task时会有以下几种输出\n    - EXECUTED：正常执行。\n    - UP-TO-DATE：由‘增量执行’特性造成，任务的输入输出都没有变化。\n    - FROM-CACHE：由‘build cache’特性造成。\n    - SKIPPED：任务被忽略。\n    - NO-SOURCE：任务的输入不存在。\n* 创建task实际上是通过project.task()方法和project.tasks.create()方法来进行的，project.tasks的类型是TaskContainer；创建task时task名称的字符串可以带引号也可以不带(groovy语法)。\n* task被创建之后会作为project的属性，可以使用project.{taskName}的方式直接访问；也可以通过tproject.tasks(TaskContainer)来访问。\n* 通过project.tasks.getByPath(String path)方法来访问其他工程的task；其中path的格式为`:{projectName}:{taskName}`。\n* task对其他task的依赖，是通过`Task.dependsOn(Object... paths)`方法来设置的，可以依赖当前project的task或者其他project的task；设置task的依赖参数有多种形式：\n    - 当前project的其他task的名字字符串。\n    - 其他project的task的路径字符串(`:{projectName}:{taskName}`)。\n    - 所依赖的task对象。\n    - 返回task对象活task collection的closure，这个closure在evaluated之后才会执行。\n* 可以通过task的description属性给task添加描述。\n* 在创建任务时，通过将overwrite设置为true可以覆盖已有的同名任务；否则创建和已用任务同名任务时，会抛出异常。代码示例：\n```groovy\ntask copy(type: Copy)\n\ntask copy(overwrite: true) {\n    ...\n}\n```\n\n### Task顺序\n\ntask顺序并不规定task之间的依赖关系，而是当一些task在一次gradle run中都要执行的时候，约定task之间的执行顺序。\n\n* task顺序目前包括mustRunAfter和shouldRunAfter两种规则；其区别就是在shouldRunAfter规则在造成环 & 并行执行模式下，会被忽略。\n* task循序通过`Task.mustRunAfter(Object...)`和`Task.shouldRunAfter(Object...)`两个方法设置；他们接受的参数形式和`Task.dependsOn(Object... paths)`一样。\n\n### 忽略任务\n\n* 通过`Task.onlyIf(Closure)`方法忽略任务，当Closure返回false时task会被忽略；Closure的执行时间是在task执行之前。\n* 在task执行代码中抛出StopExecutionException；抛出StopExecutionException后当前task的后续代码会被忽略，**并执行下一个task**。\n* 将task.enabled属性设置为false。\n\n### Finalizer tasks\n\n* 可以通过`Task.finalizedBy(Object...)`方法来定义类似finally语意的task；`Task.finalizedBy(Object...)`接受的参数形式和`Task.dependsOn(Object... paths)`一样。\n* 当task A准备执行之前，A的Finalizer tasks会被加入TaskGraph。\n* 即使task执行失败，其Finalizer tasks也会被执行；但是如果task没有被执行(例如upToDate)，那么Finalizer tasks不会被执行。\n* 和代码中的finally语义相同，Finalizer tasks适合做一些必须被执行的清理工作。\n\n\n## Task的增量执行\n\n在执行task时，如果task的input和output都没有变化，那么task被认为是UP-TO-DATE的并不被执行；会进行增量执行的最低条件时，task至少有一个output。\n\n### 使任务支持增量执行\n\n* 使任务支持增量执行，需要做的就是定义一些getter方法并对这些getter方法进行(input & output)注解。\n* (input & output)相关的注解分为三类：\n    - 简单类型，包括任何实现了Serializable接口的类型；仅适用于输入@Input注解。\n    - 文件类型，包括File、 FileCollection以及任何`Project.file(java.lang.Object)`和`Project.files(java.lang.Object[])`方法的合法输入类型；文件类型在输入输出注解中使用最为广泛，包括@InputFile、@InputFile、@InputFiles、@OutputFile、@OutputDirectory、@OutputDirectory等。\n    - Nested类型，包含 (input & output)注解的自定义类型；仅适用于@Nested注解。\n* 由于注解会被继承(superclass或interface)，所以子类的(input & output)注解会覆盖父类的；同时superclass中的(input & output)注解优先级比interface中的优先级高。\n* 在output目录中的文件增加，依然会被认定为upToDate；`TaskOutputs.upToDateWhen(Closure)`允许自定义一些upToDate检查条件。\n\n\n### 通过API修改输入输出\n\n当不能修改task类的源码时，也就不能使用注解定义输入输出；所以Gradle还提供了一组修改输入输出的API。\n\n* 通过Task.inputs(TaskInputs)和Task.outputs(TaskOutputs)来修改任务的输入输出；TaskInputs提供了property()、file()、dir()等方法，TaskOutputs提供了file()、dir()等方法。\n\n### 定义输入输出的其他影响\n\n* 如果任务A的某个输入被赋值为任务B的某个输出，那么任务A自动dependsOn任务B。\n* 被(input & output)注解的属性，会检查其值的合法性，例如文件&目录是否存在。\n\n## 依赖管理\n\n\n    \n","source":"_drafts/gradle-manual-write-script-2.md","raw":"---\ntitle: 使用 Task - 编写 Gradle 脚本 (Part2)\nsubtitle: Gradle Manual 读书笔记 （2.2）\ncatalog: true\nheader-img: /img/header_img/tools-note-header.jpg\ntags:\n  - Gradle\ncategories:\n  - 读书笔记\n---\n\n## Task(稍稍)进阶\n\n* 在执行task时会有以下几种输出\n    - EXECUTED：正常执行。\n    - UP-TO-DATE：由‘增量执行’特性造成，任务的输入输出都没有变化。\n    - FROM-CACHE：由‘build cache’特性造成。\n    - SKIPPED：任务被忽略。\n    - NO-SOURCE：任务的输入不存在。\n* 创建task实际上是通过project.task()方法和project.tasks.create()方法来进行的，project.tasks的类型是TaskContainer；创建task时task名称的字符串可以带引号也可以不带(groovy语法)。\n* task被创建之后会作为project的属性，可以使用project.{taskName}的方式直接访问；也可以通过tproject.tasks(TaskContainer)来访问。\n* 通过project.tasks.getByPath(String path)方法来访问其他工程的task；其中path的格式为`:{projectName}:{taskName}`。\n* task对其他task的依赖，是通过`Task.dependsOn(Object... paths)`方法来设置的，可以依赖当前project的task或者其他project的task；设置task的依赖参数有多种形式：\n    - 当前project的其他task的名字字符串。\n    - 其他project的task的路径字符串(`:{projectName}:{taskName}`)。\n    - 所依赖的task对象。\n    - 返回task对象活task collection的closure，这个closure在evaluated之后才会执行。\n* 可以通过task的description属性给task添加描述。\n* 在创建任务时，通过将overwrite设置为true可以覆盖已有的同名任务；否则创建和已用任务同名任务时，会抛出异常。代码示例：\n```groovy\ntask copy(type: Copy)\n\ntask copy(overwrite: true) {\n    ...\n}\n```\n\n### Task顺序\n\ntask顺序并不规定task之间的依赖关系，而是当一些task在一次gradle run中都要执行的时候，约定task之间的执行顺序。\n\n* task顺序目前包括mustRunAfter和shouldRunAfter两种规则；其区别就是在shouldRunAfter规则在造成环 & 并行执行模式下，会被忽略。\n* task循序通过`Task.mustRunAfter(Object...)`和`Task.shouldRunAfter(Object...)`两个方法设置；他们接受的参数形式和`Task.dependsOn(Object... paths)`一样。\n\n### 忽略任务\n\n* 通过`Task.onlyIf(Closure)`方法忽略任务，当Closure返回false时task会被忽略；Closure的执行时间是在task执行之前。\n* 在task执行代码中抛出StopExecutionException；抛出StopExecutionException后当前task的后续代码会被忽略，**并执行下一个task**。\n* 将task.enabled属性设置为false。\n\n### Finalizer tasks\n\n* 可以通过`Task.finalizedBy(Object...)`方法来定义类似finally语意的task；`Task.finalizedBy(Object...)`接受的参数形式和`Task.dependsOn(Object... paths)`一样。\n* 当task A准备执行之前，A的Finalizer tasks会被加入TaskGraph。\n* 即使task执行失败，其Finalizer tasks也会被执行；但是如果task没有被执行(例如upToDate)，那么Finalizer tasks不会被执行。\n* 和代码中的finally语义相同，Finalizer tasks适合做一些必须被执行的清理工作。\n\n\n## Task的增量执行\n\n在执行task时，如果task的input和output都没有变化，那么task被认为是UP-TO-DATE的并不被执行；会进行增量执行的最低条件时，task至少有一个output。\n\n### 使任务支持增量执行\n\n* 使任务支持增量执行，需要做的就是定义一些getter方法并对这些getter方法进行(input & output)注解。\n* (input & output)相关的注解分为三类：\n    - 简单类型，包括任何实现了Serializable接口的类型；仅适用于输入@Input注解。\n    - 文件类型，包括File、 FileCollection以及任何`Project.file(java.lang.Object)`和`Project.files(java.lang.Object[])`方法的合法输入类型；文件类型在输入输出注解中使用最为广泛，包括@InputFile、@InputFile、@InputFiles、@OutputFile、@OutputDirectory、@OutputDirectory等。\n    - Nested类型，包含 (input & output)注解的自定义类型；仅适用于@Nested注解。\n* 由于注解会被继承(superclass或interface)，所以子类的(input & output)注解会覆盖父类的；同时superclass中的(input & output)注解优先级比interface中的优先级高。\n* 在output目录中的文件增加，依然会被认定为upToDate；`TaskOutputs.upToDateWhen(Closure)`允许自定义一些upToDate检查条件。\n\n\n### 通过API修改输入输出\n\n当不能修改task类的源码时，也就不能使用注解定义输入输出；所以Gradle还提供了一组修改输入输出的API。\n\n* 通过Task.inputs(TaskInputs)和Task.outputs(TaskOutputs)来修改任务的输入输出；TaskInputs提供了property()、file()、dir()等方法，TaskOutputs提供了file()、dir()等方法。\n\n### 定义输入输出的其他影响\n\n* 如果任务A的某个输入被赋值为任务B的某个输出，那么任务A自动dependsOn任务B。\n* 被(input & output)注解的属性，会检查其值的合法性，例如文件&目录是否存在。\n\n## 依赖管理\n\n\n    \n","slug":"gradle-manual-write-script-2","published":0,"date":"2019-06-13T08:11:06.000Z","updated":"2019-06-13T08:11:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ov00093mrfafiz1nf6","content":"<h2 id=\"Task-稍稍-进阶\"><a href=\"#Task-稍稍-进阶\" class=\"headerlink\" title=\"Task(稍稍)进阶\"></a>Task(稍稍)进阶</h2><ul>\n<li>在执行task时会有以下几种输出<ul>\n<li>EXECUTED：正常执行。</li>\n<li>UP-TO-DATE：由‘增量执行’特性造成，任务的输入输出都没有变化。</li>\n<li>FROM-CACHE：由‘build cache’特性造成。</li>\n<li>SKIPPED：任务被忽略。</li>\n<li>NO-SOURCE：任务的输入不存在。</li>\n</ul>\n</li>\n<li>创建task实际上是通过project.task()方法和project.tasks.create()方法来进行的，project.tasks的类型是TaskContainer；创建task时task名称的字符串可以带引号也可以不带(groovy语法)。</li>\n<li>task被创建之后会作为project的属性，可以使用project.{taskName}的方式直接访问；也可以通过tproject.tasks(TaskContainer)来访问。</li>\n<li>通过project.tasks.getByPath(String path)方法来访问其他工程的task；其中path的格式为<code>:&#123;projectName&#125;:&#123;taskName&#125;</code>。</li>\n<li>task对其他task的依赖，是通过<code>Task.dependsOn(Object... paths)</code>方法来设置的，可以依赖当前project的task或者其他project的task；设置task的依赖参数有多种形式：<ul>\n<li>当前project的其他task的名字字符串。</li>\n<li>其他project的task的路径字符串(<code>:&#123;projectName&#125;:&#123;taskName&#125;</code>)。</li>\n<li>所依赖的task对象。</li>\n<li>返回task对象活task collection的closure，这个closure在evaluated之后才会执行。</li>\n</ul>\n</li>\n<li>可以通过task的description属性给task添加描述。</li>\n<li>在创建任务时，通过将overwrite设置为true可以覆盖已有的同名任务；否则创建和已用任务同名任务时，会抛出异常。代码示例：<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task copy(<span class=\"attr\">type:</span> Copy)</span><br><span class=\"line\"></span><br><span class=\"line\">task copy(<span class=\"attr\">overwrite:</span> <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Task顺序\"><a href=\"#Task顺序\" class=\"headerlink\" title=\"Task顺序\"></a>Task顺序</h3><p>task顺序并不规定task之间的依赖关系，而是当一些task在一次gradle run中都要执行的时候，约定task之间的执行顺序。</p>\n<ul>\n<li>task顺序目前包括mustRunAfter和shouldRunAfter两种规则；其区别就是在shouldRunAfter规则在造成环 &amp; 并行执行模式下，会被忽略。</li>\n<li>task循序通过<code>Task.mustRunAfter(Object...)</code>和<code>Task.shouldRunAfter(Object...)</code>两个方法设置；他们接受的参数形式和<code>Task.dependsOn(Object... paths)</code>一样。</li>\n</ul>\n<h3 id=\"忽略任务\"><a href=\"#忽略任务\" class=\"headerlink\" title=\"忽略任务\"></a>忽略任务</h3><ul>\n<li>通过<code>Task.onlyIf(Closure)</code>方法忽略任务，当Closure返回false时task会被忽略；Closure的执行时间是在task执行之前。</li>\n<li>在task执行代码中抛出StopExecutionException；抛出StopExecutionException后当前task的后续代码会被忽略，<strong>并执行下一个task</strong>。</li>\n<li>将task.enabled属性设置为false。</li>\n</ul>\n<h3 id=\"Finalizer-tasks\"><a href=\"#Finalizer-tasks\" class=\"headerlink\" title=\"Finalizer tasks\"></a>Finalizer tasks</h3><ul>\n<li>可以通过<code>Task.finalizedBy(Object...)</code>方法来定义类似finally语意的task；<code>Task.finalizedBy(Object...)</code>接受的参数形式和<code>Task.dependsOn(Object... paths)</code>一样。</li>\n<li>当task A准备执行之前，A的Finalizer tasks会被加入TaskGraph。</li>\n<li>即使task执行失败，其Finalizer tasks也会被执行；但是如果task没有被执行(例如upToDate)，那么Finalizer tasks不会被执行。</li>\n<li>和代码中的finally语义相同，Finalizer tasks适合做一些必须被执行的清理工作。</li>\n</ul>\n<h2 id=\"Task的增量执行\"><a href=\"#Task的增量执行\" class=\"headerlink\" title=\"Task的增量执行\"></a>Task的增量执行</h2><p>在执行task时，如果task的input和output都没有变化，那么task被认为是UP-TO-DATE的并不被执行；会进行增量执行的最低条件时，task至少有一个output。</p>\n<h3 id=\"使任务支持增量执行\"><a href=\"#使任务支持增量执行\" class=\"headerlink\" title=\"使任务支持增量执行\"></a>使任务支持增量执行</h3><ul>\n<li>使任务支持增量执行，需要做的就是定义一些getter方法并对这些getter方法进行(input &amp; output)注解。</li>\n<li>(input &amp; output)相关的注解分为三类：<ul>\n<li>简单类型，包括任何实现了Serializable接口的类型；仅适用于输入@Input注解。</li>\n<li>文件类型，包括File、 FileCollection以及任何<code>Project.file(java.lang.Object)</code>和<code>Project.files(java.lang.Object[])</code>方法的合法输入类型；文件类型在输入输出注解中使用最为广泛，包括@InputFile、@InputFile、@InputFiles、@OutputFile、@OutputDirectory、@OutputDirectory等。</li>\n<li>Nested类型，包含 (input &amp; output)注解的自定义类型；仅适用于@Nested注解。</li>\n</ul>\n</li>\n<li>由于注解会被继承(superclass或interface)，所以子类的(input &amp; output)注解会覆盖父类的；同时superclass中的(input &amp; output)注解优先级比interface中的优先级高。</li>\n<li>在output目录中的文件增加，依然会被认定为upToDate；<code>TaskOutputs.upToDateWhen(Closure)</code>允许自定义一些upToDate检查条件。</li>\n</ul>\n<h3 id=\"通过API修改输入输出\"><a href=\"#通过API修改输入输出\" class=\"headerlink\" title=\"通过API修改输入输出\"></a>通过API修改输入输出</h3><p>当不能修改task类的源码时，也就不能使用注解定义输入输出；所以Gradle还提供了一组修改输入输出的API。</p>\n<ul>\n<li>通过Task.inputs(TaskInputs)和Task.outputs(TaskOutputs)来修改任务的输入输出；TaskInputs提供了property()、file()、dir()等方法，TaskOutputs提供了file()、dir()等方法。</li>\n</ul>\n<h3 id=\"定义输入输出的其他影响\"><a href=\"#定义输入输出的其他影响\" class=\"headerlink\" title=\"定义输入输出的其他影响\"></a>定义输入输出的其他影响</h3><ul>\n<li>如果任务A的某个输入被赋值为任务B的某个输出，那么任务A自动dependsOn任务B。</li>\n<li>被(input &amp; output)注解的属性，会检查其值的合法性，例如文件&amp;目录是否存在。</li>\n</ul>\n<h2 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Task-稍稍-进阶\"><a href=\"#Task-稍稍-进阶\" class=\"headerlink\" title=\"Task(稍稍)进阶\"></a>Task(稍稍)进阶</h2><ul>\n<li>在执行task时会有以下几种输出<ul>\n<li>EXECUTED：正常执行。</li>\n<li>UP-TO-DATE：由‘增量执行’特性造成，任务的输入输出都没有变化。</li>\n<li>FROM-CACHE：由‘build cache’特性造成。</li>\n<li>SKIPPED：任务被忽略。</li>\n<li>NO-SOURCE：任务的输入不存在。</li>\n</ul>\n</li>\n<li>创建task实际上是通过project.task()方法和project.tasks.create()方法来进行的，project.tasks的类型是TaskContainer；创建task时task名称的字符串可以带引号也可以不带(groovy语法)。</li>\n<li>task被创建之后会作为project的属性，可以使用project.{taskName}的方式直接访问；也可以通过tproject.tasks(TaskContainer)来访问。</li>\n<li>通过project.tasks.getByPath(String path)方法来访问其他工程的task；其中path的格式为<code>:&#123;projectName&#125;:&#123;taskName&#125;</code>。</li>\n<li>task对其他task的依赖，是通过<code>Task.dependsOn(Object... paths)</code>方法来设置的，可以依赖当前project的task或者其他project的task；设置task的依赖参数有多种形式：<ul>\n<li>当前project的其他task的名字字符串。</li>\n<li>其他project的task的路径字符串(<code>:&#123;projectName&#125;:&#123;taskName&#125;</code>)。</li>\n<li>所依赖的task对象。</li>\n<li>返回task对象活task collection的closure，这个closure在evaluated之后才会执行。</li>\n</ul>\n</li>\n<li>可以通过task的description属性给task添加描述。</li>\n<li>在创建任务时，通过将overwrite设置为true可以覆盖已有的同名任务；否则创建和已用任务同名任务时，会抛出异常。代码示例：<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task copy(<span class=\"attr\">type:</span> Copy)</span><br><span class=\"line\"></span><br><span class=\"line\">task copy(<span class=\"attr\">overwrite:</span> <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Task顺序\"><a href=\"#Task顺序\" class=\"headerlink\" title=\"Task顺序\"></a>Task顺序</h3><p>task顺序并不规定task之间的依赖关系，而是当一些task在一次gradle run中都要执行的时候，约定task之间的执行顺序。</p>\n<ul>\n<li>task顺序目前包括mustRunAfter和shouldRunAfter两种规则；其区别就是在shouldRunAfter规则在造成环 &amp; 并行执行模式下，会被忽略。</li>\n<li>task循序通过<code>Task.mustRunAfter(Object...)</code>和<code>Task.shouldRunAfter(Object...)</code>两个方法设置；他们接受的参数形式和<code>Task.dependsOn(Object... paths)</code>一样。</li>\n</ul>\n<h3 id=\"忽略任务\"><a href=\"#忽略任务\" class=\"headerlink\" title=\"忽略任务\"></a>忽略任务</h3><ul>\n<li>通过<code>Task.onlyIf(Closure)</code>方法忽略任务，当Closure返回false时task会被忽略；Closure的执行时间是在task执行之前。</li>\n<li>在task执行代码中抛出StopExecutionException；抛出StopExecutionException后当前task的后续代码会被忽略，<strong>并执行下一个task</strong>。</li>\n<li>将task.enabled属性设置为false。</li>\n</ul>\n<h3 id=\"Finalizer-tasks\"><a href=\"#Finalizer-tasks\" class=\"headerlink\" title=\"Finalizer tasks\"></a>Finalizer tasks</h3><ul>\n<li>可以通过<code>Task.finalizedBy(Object...)</code>方法来定义类似finally语意的task；<code>Task.finalizedBy(Object...)</code>接受的参数形式和<code>Task.dependsOn(Object... paths)</code>一样。</li>\n<li>当task A准备执行之前，A的Finalizer tasks会被加入TaskGraph。</li>\n<li>即使task执行失败，其Finalizer tasks也会被执行；但是如果task没有被执行(例如upToDate)，那么Finalizer tasks不会被执行。</li>\n<li>和代码中的finally语义相同，Finalizer tasks适合做一些必须被执行的清理工作。</li>\n</ul>\n<h2 id=\"Task的增量执行\"><a href=\"#Task的增量执行\" class=\"headerlink\" title=\"Task的增量执行\"></a>Task的增量执行</h2><p>在执行task时，如果task的input和output都没有变化，那么task被认为是UP-TO-DATE的并不被执行；会进行增量执行的最低条件时，task至少有一个output。</p>\n<h3 id=\"使任务支持增量执行\"><a href=\"#使任务支持增量执行\" class=\"headerlink\" title=\"使任务支持增量执行\"></a>使任务支持增量执行</h3><ul>\n<li>使任务支持增量执行，需要做的就是定义一些getter方法并对这些getter方法进行(input &amp; output)注解。</li>\n<li>(input &amp; output)相关的注解分为三类：<ul>\n<li>简单类型，包括任何实现了Serializable接口的类型；仅适用于输入@Input注解。</li>\n<li>文件类型，包括File、 FileCollection以及任何<code>Project.file(java.lang.Object)</code>和<code>Project.files(java.lang.Object[])</code>方法的合法输入类型；文件类型在输入输出注解中使用最为广泛，包括@InputFile、@InputFile、@InputFiles、@OutputFile、@OutputDirectory、@OutputDirectory等。</li>\n<li>Nested类型，包含 (input &amp; output)注解的自定义类型；仅适用于@Nested注解。</li>\n</ul>\n</li>\n<li>由于注解会被继承(superclass或interface)，所以子类的(input &amp; output)注解会覆盖父类的；同时superclass中的(input &amp; output)注解优先级比interface中的优先级高。</li>\n<li>在output目录中的文件增加，依然会被认定为upToDate；<code>TaskOutputs.upToDateWhen(Closure)</code>允许自定义一些upToDate检查条件。</li>\n</ul>\n<h3 id=\"通过API修改输入输出\"><a href=\"#通过API修改输入输出\" class=\"headerlink\" title=\"通过API修改输入输出\"></a>通过API修改输入输出</h3><p>当不能修改task类的源码时，也就不能使用注解定义输入输出；所以Gradle还提供了一组修改输入输出的API。</p>\n<ul>\n<li>通过Task.inputs(TaskInputs)和Task.outputs(TaskOutputs)来修改任务的输入输出；TaskInputs提供了property()、file()、dir()等方法，TaskOutputs提供了file()、dir()等方法。</li>\n</ul>\n<h3 id=\"定义输入输出的其他影响\"><a href=\"#定义输入输出的其他影响\" class=\"headerlink\" title=\"定义输入输出的其他影响\"></a>定义输入输出的其他影响</h3><ul>\n<li>如果任务A的某个输入被赋值为任务B的某个输出，那么任务A自动dependsOn任务B。</li>\n<li>被(input &amp; output)注解的属性，会检查其值的合法性，例如文件&amp;目录是否存在。</li>\n</ul>\n<h2 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h2>"},{"title":"设计模式入门摘要","subtitle":"《Head first design pattern》阅读摘要","catalog":true,"header-img":"/img/header_img/manner-note-header.jpg","_content":"","source":"_drafts/head-first-design-pattern.md","raw":"---\ntitle: 设计模式入门摘要\nsubtitle: 《Head first design pattern》阅读摘要\ncatalog: true\nheader-img: /img/header_img/manner-note-header.jpg\ntags:\n    - design\ncategories:\n  - 读书笔记\n---","slug":"head-first-design-pattern","published":0,"date":"2019-11-01T03:57:20.445Z","updated":"2019-11-01T03:57:20.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ov000a3mrfhkr699zx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Java 泛型:《Thinking in java》","subtitle":"《Thinking in java》微缩笔记 0x01","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","_content":"\n## 简单泛型\n\nJava 泛型的核心概念：告诉编译器想使用的类型，让编译器来检查类型和转型。\n\n## 泛型接口\n\n## 泛型方法\n\n如果能用泛型方法替代，就不要使用泛型类。\n\n泛型函数的泛型参数列表需要写在函数的返回类型**之前**\n\n大部分情况下，泛型方法可以推断出泛型参数；但也可以在 `.` 操作符和方法之间加入 `<>`，显示指明泛型参数类型。  \n\n## 泛型擦除\n\n在泛型代码内部，无法获得任何有关泛型参数类型的信息。\n\n泛型参数将被擦除到它的第一个边界。\n\n\n\n\n","source":"_drafts/thinking-in-java-generic.md","raw":"---\ntitle: Java 泛型:《Thinking in java》\nsubtitle: 《Thinking in java》微缩笔记 0x01\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n    - Java\ncategories:\n  - 读书笔记\n---\n\n## 简单泛型\n\nJava 泛型的核心概念：告诉编译器想使用的类型，让编译器来检查类型和转型。\n\n## 泛型接口\n\n## 泛型方法\n\n如果能用泛型方法替代，就不要使用泛型类。\n\n泛型函数的泛型参数列表需要写在函数的返回类型**之前**\n\n大部分情况下，泛型方法可以推断出泛型参数；但也可以在 `.` 操作符和方法之间加入 `<>`，显示指明泛型参数类型。  \n\n## 泛型擦除\n\n在泛型代码内部，无法获得任何有关泛型参数类型的信息。\n\n泛型参数将被擦除到它的第一个边界。\n\n\n\n\n","slug":"thinking-in-java-generic","published":0,"date":"2019-11-17T09:37:25.034Z","updated":"2019-11-17T09:37:25.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ov000b3mrfdu3o5lec","content":"<h2 id=\"简单泛型\"><a href=\"#简单泛型\" class=\"headerlink\" title=\"简单泛型\"></a>简单泛型</h2><p>Java 泛型的核心概念：告诉编译器想使用的类型，让编译器来检查类型和转型。</p>\n<h2 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h2><h2 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h2><p>如果能用泛型方法替代，就不要使用泛型类。</p>\n<p>泛型函数的泛型参数列表需要写在函数的返回类型<strong>之前</strong></p>\n<p>大部分情况下，泛型方法可以推断出泛型参数；但也可以在 <code>.</code> 操作符和方法之间加入 <code>&lt;&gt;</code>，显示指明泛型参数类型。  </p>\n<h2 id=\"泛型擦除\"><a href=\"#泛型擦除\" class=\"headerlink\" title=\"泛型擦除\"></a>泛型擦除</h2><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>\n<p>泛型参数将被擦除到它的第一个边界。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单泛型\"><a href=\"#简单泛型\" class=\"headerlink\" title=\"简单泛型\"></a>简单泛型</h2><p>Java 泛型的核心概念：告诉编译器想使用的类型，让编译器来检查类型和转型。</p>\n<h2 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h2><h2 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h2><p>如果能用泛型方法替代，就不要使用泛型类。</p>\n<p>泛型函数的泛型参数列表需要写在函数的返回类型<strong>之前</strong></p>\n<p>大部分情况下，泛型方法可以推断出泛型参数；但也可以在 <code>.</code> 操作符和方法之间加入 <code>&lt;&gt;</code>，显示指明泛型参数类型。  </p>\n<h2 id=\"泛型擦除\"><a href=\"#泛型擦除\" class=\"headerlink\" title=\"泛型擦除\"></a>泛型擦除</h2><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>\n<p>泛型参数将被擦除到它的第一个边界。</p>\n"},{"title":"活跃性问题","subtitle":"JCIP读书笔记第十章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-10-05T00:37:09.000Z","_content":"\n\n## 死锁   \n\n再来一次五哲学家用筷子吃饭的例子，解释什么是死锁。数据库系统采用如下方法来避免死锁，在互相死锁的事务中挑选牺牲者并中止该事务。\n\n### 加锁顺序造成的死锁\n\n当线程需要同时获取多个锁时，有可能会发生加锁顺序造成的死锁；如果所有线程，都依照一个全局固定的顺序来依次获取多个锁，那么就可以避免加锁顺序造成的死锁。\n\n要保持全局的加锁顺序固定，看起来是相当脆弱易出错的协议，尤其有动态的锁对象的时候。\n\n### 动态的加锁顺序造成的锁死\n\n当锁对象是动态的--例如将锁对象作为参数传入函数--就很容易发生难以察觉的加锁顺序锁死。\n一种方式是用hashCode来定义动态锁对象的加锁；当锁对象的hashCode一致时使用额外的一个锁(被称为tie锁)在获取锁序列最外层加锁，使整个序列的获取过程变成互斥的。\n\n\n### 当多锁获取发生在不同对象的不同方法中\n\n多锁获取可能不是发生在同一个方法中，而是由多层调用栈造成，在这种情况下就很难注意到多锁获取的发生，更不用说保持顺序。\n\n在持有锁的情况下调用外部方法，很容易发生活跃性问题。外部方法可能会去获取另一个锁，从而诱发加锁顺序死锁；外部方法可能会很久才返回，导致持有锁的时间过长。\n\n### Open call\n\n当在调用外部方法时不持有锁，这次调用被称为Open call。尽量使用Open call可以减少死锁发生的风险，并在死锁发生的时候使得问题变得容易被分析。\n\n### 资源死锁\n\n## 避免和诊断死锁\n\n同时最多持有一个锁的代码不会发生死锁，虽然有时这样做无法满足需求。如果需要同时持有多个锁，那么需要先定位这些多锁获取场景，然后应用全局加锁顺序；全部使用Open Call有利于这些多锁获取场景的定位。\n\n### 限时获取锁\n\n使用tryLock可以让程序从死锁中恢复过来。\n\n### 使用Thread Dump分析死锁\n\nThread Dump可以输出JVM中所有线程持有锁的情况和等待锁的情况，包括锁是在那个stack frame获取的，如果有死锁存在还是提示死锁信息。在Java5.0中，Thread Dump无法输出显式锁的信息；Java6.0中Thread Dump包含了显示锁的信息，但无法准确定位显示锁获取的stack frame。\n\n## 其他活跃性问题\n\n### Starvation\n\n当一个线程理论上可以获取所需资源，但在实际情况下它永远不可能获得所需资源，就发生了Starvation；例如不合理的设置线程优先级，可能造成某些线程永远无法使用Cpu。\nJava的线程API定义了10个线程优先级，在执行时这些线程优先级会被映射为系统线程优先级；在不同平台上设置线程优先级会有不同的效果，有些平台的系统线程优先级可能不足10个。\n因为线程优先级的效果具有平台依赖性，所以非必要情况下不要调整线程优先级；UI线程和后台线程是一个适合使用线程优先级的场景。\n\n### 活锁\n\n活锁通常是由某种死循环逻辑，或者几个线程由于不良设计处于永久的逻辑冲突造成的。假设两个线程在同时请求某种资源时发生逻辑冲突，并且两个线程冲突后等待重试的时间相同，那么这两个线程就发生了活锁。\n\n\n\n\n\n","source":"_posts/JCIP-chapter10-avoiding-liveness-hazards.md","raw":"---\ntitle: 活跃性问题\nsubtitle: JCIP读书笔记第十章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-10-05 08:37:09\n---\n\n\n## 死锁   \n\n再来一次五哲学家用筷子吃饭的例子，解释什么是死锁。数据库系统采用如下方法来避免死锁，在互相死锁的事务中挑选牺牲者并中止该事务。\n\n### 加锁顺序造成的死锁\n\n当线程需要同时获取多个锁时，有可能会发生加锁顺序造成的死锁；如果所有线程，都依照一个全局固定的顺序来依次获取多个锁，那么就可以避免加锁顺序造成的死锁。\n\n要保持全局的加锁顺序固定，看起来是相当脆弱易出错的协议，尤其有动态的锁对象的时候。\n\n### 动态的加锁顺序造成的锁死\n\n当锁对象是动态的--例如将锁对象作为参数传入函数--就很容易发生难以察觉的加锁顺序锁死。\n一种方式是用hashCode来定义动态锁对象的加锁；当锁对象的hashCode一致时使用额外的一个锁(被称为tie锁)在获取锁序列最外层加锁，使整个序列的获取过程变成互斥的。\n\n\n### 当多锁获取发生在不同对象的不同方法中\n\n多锁获取可能不是发生在同一个方法中，而是由多层调用栈造成，在这种情况下就很难注意到多锁获取的发生，更不用说保持顺序。\n\n在持有锁的情况下调用外部方法，很容易发生活跃性问题。外部方法可能会去获取另一个锁，从而诱发加锁顺序死锁；外部方法可能会很久才返回，导致持有锁的时间过长。\n\n### Open call\n\n当在调用外部方法时不持有锁，这次调用被称为Open call。尽量使用Open call可以减少死锁发生的风险，并在死锁发生的时候使得问题变得容易被分析。\n\n### 资源死锁\n\n## 避免和诊断死锁\n\n同时最多持有一个锁的代码不会发生死锁，虽然有时这样做无法满足需求。如果需要同时持有多个锁，那么需要先定位这些多锁获取场景，然后应用全局加锁顺序；全部使用Open Call有利于这些多锁获取场景的定位。\n\n### 限时获取锁\n\n使用tryLock可以让程序从死锁中恢复过来。\n\n### 使用Thread Dump分析死锁\n\nThread Dump可以输出JVM中所有线程持有锁的情况和等待锁的情况，包括锁是在那个stack frame获取的，如果有死锁存在还是提示死锁信息。在Java5.0中，Thread Dump无法输出显式锁的信息；Java6.0中Thread Dump包含了显示锁的信息，但无法准确定位显示锁获取的stack frame。\n\n## 其他活跃性问题\n\n### Starvation\n\n当一个线程理论上可以获取所需资源，但在实际情况下它永远不可能获得所需资源，就发生了Starvation；例如不合理的设置线程优先级，可能造成某些线程永远无法使用Cpu。\nJava的线程API定义了10个线程优先级，在执行时这些线程优先级会被映射为系统线程优先级；在不同平台上设置线程优先级会有不同的效果，有些平台的系统线程优先级可能不足10个。\n因为线程优先级的效果具有平台依赖性，所以非必要情况下不要调整线程优先级；UI线程和后台线程是一个适合使用线程优先级的场景。\n\n### 活锁\n\n活锁通常是由某种死循环逻辑，或者几个线程由于不良设计处于永久的逻辑冲突造成的。假设两个线程在同时请求某种资源时发生逻辑冲突，并且两个线程冲突后等待重试的时间相同，那么这两个线程就发生了活锁。\n\n\n\n\n\n","slug":"JCIP-chapter10-avoiding-liveness-hazards","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ow000c3mrf4at855u9","content":"<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>再来一次五哲学家用筷子吃饭的例子，解释什么是死锁。数据库系统采用如下方法来避免死锁，在互相死锁的事务中挑选牺牲者并中止该事务。</p>\n<h3 id=\"加锁顺序造成的死锁\"><a href=\"#加锁顺序造成的死锁\" class=\"headerlink\" title=\"加锁顺序造成的死锁\"></a>加锁顺序造成的死锁</h3><p>当线程需要同时获取多个锁时，有可能会发生加锁顺序造成的死锁；如果所有线程，都依照一个全局固定的顺序来依次获取多个锁，那么就可以避免加锁顺序造成的死锁。</p>\n<p>要保持全局的加锁顺序固定，看起来是相当脆弱易出错的协议，尤其有动态的锁对象的时候。</p>\n<h3 id=\"动态的加锁顺序造成的锁死\"><a href=\"#动态的加锁顺序造成的锁死\" class=\"headerlink\" title=\"动态的加锁顺序造成的锁死\"></a>动态的加锁顺序造成的锁死</h3><p>当锁对象是动态的–例如将锁对象作为参数传入函数–就很容易发生难以察觉的加锁顺序锁死。<br>一种方式是用hashCode来定义动态锁对象的加锁；当锁对象的hashCode一致时使用额外的一个锁(被称为tie锁)在获取锁序列最外层加锁，使整个序列的获取过程变成互斥的。</p>\n<h3 id=\"当多锁获取发生在不同对象的不同方法中\"><a href=\"#当多锁获取发生在不同对象的不同方法中\" class=\"headerlink\" title=\"当多锁获取发生在不同对象的不同方法中\"></a>当多锁获取发生在不同对象的不同方法中</h3><p>多锁获取可能不是发生在同一个方法中，而是由多层调用栈造成，在这种情况下就很难注意到多锁获取的发生，更不用说保持顺序。</p>\n<p>在持有锁的情况下调用外部方法，很容易发生活跃性问题。外部方法可能会去获取另一个锁，从而诱发加锁顺序死锁；外部方法可能会很久才返回，导致持有锁的时间过长。</p>\n<h3 id=\"Open-call\"><a href=\"#Open-call\" class=\"headerlink\" title=\"Open call\"></a>Open call</h3><p>当在调用外部方法时不持有锁，这次调用被称为Open call。尽量使用Open call可以减少死锁发生的风险，并在死锁发生的时候使得问题变得容易被分析。</p>\n<h3 id=\"资源死锁\"><a href=\"#资源死锁\" class=\"headerlink\" title=\"资源死锁\"></a>资源死锁</h3><h2 id=\"避免和诊断死锁\"><a href=\"#避免和诊断死锁\" class=\"headerlink\" title=\"避免和诊断死锁\"></a>避免和诊断死锁</h2><p>同时最多持有一个锁的代码不会发生死锁，虽然有时这样做无法满足需求。如果需要同时持有多个锁，那么需要先定位这些多锁获取场景，然后应用全局加锁顺序；全部使用Open Call有利于这些多锁获取场景的定位。</p>\n<h3 id=\"限时获取锁\"><a href=\"#限时获取锁\" class=\"headerlink\" title=\"限时获取锁\"></a>限时获取锁</h3><p>使用tryLock可以让程序从死锁中恢复过来。</p>\n<h3 id=\"使用Thread-Dump分析死锁\"><a href=\"#使用Thread-Dump分析死锁\" class=\"headerlink\" title=\"使用Thread Dump分析死锁\"></a>使用Thread Dump分析死锁</h3><p>Thread Dump可以输出JVM中所有线程持有锁的情况和等待锁的情况，包括锁是在那个stack frame获取的，如果有死锁存在还是提示死锁信息。在Java5.0中，Thread Dump无法输出显式锁的信息；Java6.0中Thread Dump包含了显示锁的信息，但无法准确定位显示锁获取的stack frame。</p>\n<h2 id=\"其他活跃性问题\"><a href=\"#其他活跃性问题\" class=\"headerlink\" title=\"其他活跃性问题\"></a>其他活跃性问题</h2><h3 id=\"Starvation\"><a href=\"#Starvation\" class=\"headerlink\" title=\"Starvation\"></a>Starvation</h3><p>当一个线程理论上可以获取所需资源，但在实际情况下它永远不可能获得所需资源，就发生了Starvation；例如不合理的设置线程优先级，可能造成某些线程永远无法使用Cpu。<br>Java的线程API定义了10个线程优先级，在执行时这些线程优先级会被映射为系统线程优先级；在不同平台上设置线程优先级会有不同的效果，有些平台的系统线程优先级可能不足10个。<br>因为线程优先级的效果具有平台依赖性，所以非必要情况下不要调整线程优先级；UI线程和后台线程是一个适合使用线程优先级的场景。</p>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><p>活锁通常是由某种死循环逻辑，或者几个线程由于不良设计处于永久的逻辑冲突造成的。假设两个线程在同时请求某种资源时发生逻辑冲突，并且两个线程冲突后等待重试的时间相同，那么这两个线程就发生了活锁。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>再来一次五哲学家用筷子吃饭的例子，解释什么是死锁。数据库系统采用如下方法来避免死锁，在互相死锁的事务中挑选牺牲者并中止该事务。</p>\n<h3 id=\"加锁顺序造成的死锁\"><a href=\"#加锁顺序造成的死锁\" class=\"headerlink\" title=\"加锁顺序造成的死锁\"></a>加锁顺序造成的死锁</h3><p>当线程需要同时获取多个锁时，有可能会发生加锁顺序造成的死锁；如果所有线程，都依照一个全局固定的顺序来依次获取多个锁，那么就可以避免加锁顺序造成的死锁。</p>\n<p>要保持全局的加锁顺序固定，看起来是相当脆弱易出错的协议，尤其有动态的锁对象的时候。</p>\n<h3 id=\"动态的加锁顺序造成的锁死\"><a href=\"#动态的加锁顺序造成的锁死\" class=\"headerlink\" title=\"动态的加锁顺序造成的锁死\"></a>动态的加锁顺序造成的锁死</h3><p>当锁对象是动态的–例如将锁对象作为参数传入函数–就很容易发生难以察觉的加锁顺序锁死。<br>一种方式是用hashCode来定义动态锁对象的加锁；当锁对象的hashCode一致时使用额外的一个锁(被称为tie锁)在获取锁序列最外层加锁，使整个序列的获取过程变成互斥的。</p>\n<h3 id=\"当多锁获取发生在不同对象的不同方法中\"><a href=\"#当多锁获取发生在不同对象的不同方法中\" class=\"headerlink\" title=\"当多锁获取发生在不同对象的不同方法中\"></a>当多锁获取发生在不同对象的不同方法中</h3><p>多锁获取可能不是发生在同一个方法中，而是由多层调用栈造成，在这种情况下就很难注意到多锁获取的发生，更不用说保持顺序。</p>\n<p>在持有锁的情况下调用外部方法，很容易发生活跃性问题。外部方法可能会去获取另一个锁，从而诱发加锁顺序死锁；外部方法可能会很久才返回，导致持有锁的时间过长。</p>\n<h3 id=\"Open-call\"><a href=\"#Open-call\" class=\"headerlink\" title=\"Open call\"></a>Open call</h3><p>当在调用外部方法时不持有锁，这次调用被称为Open call。尽量使用Open call可以减少死锁发生的风险，并在死锁发生的时候使得问题变得容易被分析。</p>\n<h3 id=\"资源死锁\"><a href=\"#资源死锁\" class=\"headerlink\" title=\"资源死锁\"></a>资源死锁</h3><h2 id=\"避免和诊断死锁\"><a href=\"#避免和诊断死锁\" class=\"headerlink\" title=\"避免和诊断死锁\"></a>避免和诊断死锁</h2><p>同时最多持有一个锁的代码不会发生死锁，虽然有时这样做无法满足需求。如果需要同时持有多个锁，那么需要先定位这些多锁获取场景，然后应用全局加锁顺序；全部使用Open Call有利于这些多锁获取场景的定位。</p>\n<h3 id=\"限时获取锁\"><a href=\"#限时获取锁\" class=\"headerlink\" title=\"限时获取锁\"></a>限时获取锁</h3><p>使用tryLock可以让程序从死锁中恢复过来。</p>\n<h3 id=\"使用Thread-Dump分析死锁\"><a href=\"#使用Thread-Dump分析死锁\" class=\"headerlink\" title=\"使用Thread Dump分析死锁\"></a>使用Thread Dump分析死锁</h3><p>Thread Dump可以输出JVM中所有线程持有锁的情况和等待锁的情况，包括锁是在那个stack frame获取的，如果有死锁存在还是提示死锁信息。在Java5.0中，Thread Dump无法输出显式锁的信息；Java6.0中Thread Dump包含了显示锁的信息，但无法准确定位显示锁获取的stack frame。</p>\n<h2 id=\"其他活跃性问题\"><a href=\"#其他活跃性问题\" class=\"headerlink\" title=\"其他活跃性问题\"></a>其他活跃性问题</h2><h3 id=\"Starvation\"><a href=\"#Starvation\" class=\"headerlink\" title=\"Starvation\"></a>Starvation</h3><p>当一个线程理论上可以获取所需资源，但在实际情况下它永远不可能获得所需资源，就发生了Starvation；例如不合理的设置线程优先级，可能造成某些线程永远无法使用Cpu。<br>Java的线程API定义了10个线程优先级，在执行时这些线程优先级会被映射为系统线程优先级；在不同平台上设置线程优先级会有不同的效果，有些平台的系统线程优先级可能不足10个。<br>因为线程优先级的效果具有平台依赖性，所以非必要情况下不要调整线程优先级；UI线程和后台线程是一个适合使用线程优先级的场景。</p>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><p>活锁通常是由某种死循环逻辑，或者几个线程由于不良设计处于永久的逻辑冲突造成的。假设两个线程在同时请求某种资源时发生逻辑冲突，并且两个线程冲突后等待重试的时间相同，那么这两个线程就发生了活锁。</p>\n"},{"title":"测试并发程序","subtitle":"JCIP读书笔记第十二章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-10-06T03:50:07.000Z","_content":"\n\n## 展开点\n\n* aspect-oriented programming (AOP) 。\n\n## 概述\n\n并发相关的测试通常可以归类为线程安全测试和线程活跃性测试。\n线程安全测试通常需要验证变量的一致性，所以测试代码本身也需要时线程安全的；但有时候加入这样的测试代码之后会隐藏原有的线程安全类bug。\n线程活跃性测试的难点在于，如何界定活跃性问题(例如死锁)真的发生了和程序运行效率低之间的区别。\n并发相关的性能测试包含如下指标：\n\n* 吞吐量：一组并发任务的完成速率。\n* 响应速度：单个任务提交到完成之间的时间跨度。\n* 伸缩性：吞吐量随并发数增长的幅度。\n\n## 正确性测试\n\n并发程序的正确性测试和非并发程序一样，需要找出所有的一致性条件进行验证，这一章用一个BlockingQueue的实现作为例子来做正确性测试。\n\n### 基本单元测试\n\n与非并发程序相同，验证基本的一致性。\n\n### 测试阻塞方法\n\n测试阻塞方法在条件满足时能否正确的阻塞，借助interrupt()和Thread.join()来完成测试。\n\n通过Thread.getState()方法可以返回线程是否在WAITING状态，但是通过这种方法来验证阻塞并不可靠。首先阻塞并不意味线程状态为WAITING，JVM可能使用自旋来实现阻塞；其次执行了Object.wait()的线程肯能会被唤醒进入RUNNING状态，但这不意味着等待条件成立；再次Thread从发生阻塞到进入WAITING状态需要一定时间。\n总体来说Thread.getState()方法并不是用于状态控制或者测试的，其主要应用场景是输出调试信息。\n\n### 线程安全性测试\n\n线程安全性的测试代码需要多线程并发执行，来确定是否有竞态条件等情况；但书写正确的并发测试代码也很有难度，同时要防止额外的测试代码同步影响被测试代码的同步情况。\n\n线程安全性的测试程序最好不要引入新的同步。\n\n本章使用了一个生产者消费者模式的实现，来作为线程安全性测试的例子，细节较多可以看原文。\n\n线程安全性测试理应运行在多核系统上，为了尽可能发现竞态条件运行线程数量应该多于Cpu数量。\n\n并发测试程序应当设置超时，以防止因为错误造成的程序无法结束。\n\n### 测试资源管理\n\n测试是否有内存泄漏。\n\n### 增加线程切换\n\n线程安全问题能否出线也许依赖运气，但是增加线程切换可以增加线程安全问题被暴露的几率。\n在适当的位置调用Thread.yield()可以增加线程切换的机会。\n\n## 性能测试\n\n略\n\n## 避免性能测试中的干扰\n\n### GC干扰\n\n是否触发GC会对性能测试结果产生明显的影响。避免GC干扰的主要方式就是确保测试过程中不触发GC(这个似乎很难保证)；或者使用足够多的内存申请，并运行足够长的时间，确保在测试过程中总是触发适当的GC(可以通过log来检查GC是否真的发生)。\n\n### 动态编译干扰\n\n由于JIT的存在，解释器执行字节码的效率远低于JIT后直接执行汇编。JIT干扰性能测试主要有两种因素：动态编译本身耗时，无法预测动态编译何时发生就无法确定测试究竟是执行的字节码还是汇编。\n\n避免动态编译干扰的一种方法是，先让被测试代码进行“热身”(预执行N个循环)，在进行性能测试。有些JVM在动态编译发生时会输出log。\n\n由于JVM会执行很多额外工作，如果一次运行中包含几组不相干的性能测试时，在几组测试之间加入Thread.Sleep()来防止JVM后台线程的干扰。\n\n### 代码优化(忽略无用)造成的干扰\n\n在性能测试中，需要防止编译器将测试代码视为无用代码进行删除优化，导致测试结果过于乐观。这就要求一些出于测试目的的运算的结果在后续代码中被使用。\n\n一种做法是打印测试运算的结果，但是额外的IO也会干扰性能测试；一种trick的方法是：使用运算结果的hashCode和一个随机值做比较，相等时打印一些信息，这个比较几乎不会成功所以对测试干扰非常小，例如下面的代码：\n\n```java\nif (foo.x.hashCode() == System.nanoTime()) \n    System.out.print(\" \");\n```\n\n同时在性能测试的运算中，要防止运算结果可以被编译器预测从而进行优化；加入时间变量可以做到这一点。\n\n## 辅助测试的方法\n\n无论怎样，单元测试不会找到代码中所有的Bug，也许需要借助单元测试以外的方法来增加找到Bug的概率。\n\n### Code Review\n\n即便并发专家在写并发代码时也会犯错误，同时在单元测试中揭露线程安全错误是有运气成分的，所以CR总是必要的。\n\n### 静态代码分析工具\n\n例如FindBugs。\n\n###  aspect-oriented programming (AOP) \n\n展开点。\n\n### Profile工具\n\n\n\n","source":"_posts/JCIP-chapter12-testing-concurrent-programs.md","raw":"---\ntitle: 测试并发程序\nsubtitle: JCIP读书笔记第十二章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-10-06 11:50:07\n---\n\n\n## 展开点\n\n* aspect-oriented programming (AOP) 。\n\n## 概述\n\n并发相关的测试通常可以归类为线程安全测试和线程活跃性测试。\n线程安全测试通常需要验证变量的一致性，所以测试代码本身也需要时线程安全的；但有时候加入这样的测试代码之后会隐藏原有的线程安全类bug。\n线程活跃性测试的难点在于，如何界定活跃性问题(例如死锁)真的发生了和程序运行效率低之间的区别。\n并发相关的性能测试包含如下指标：\n\n* 吞吐量：一组并发任务的完成速率。\n* 响应速度：单个任务提交到完成之间的时间跨度。\n* 伸缩性：吞吐量随并发数增长的幅度。\n\n## 正确性测试\n\n并发程序的正确性测试和非并发程序一样，需要找出所有的一致性条件进行验证，这一章用一个BlockingQueue的实现作为例子来做正确性测试。\n\n### 基本单元测试\n\n与非并发程序相同，验证基本的一致性。\n\n### 测试阻塞方法\n\n测试阻塞方法在条件满足时能否正确的阻塞，借助interrupt()和Thread.join()来完成测试。\n\n通过Thread.getState()方法可以返回线程是否在WAITING状态，但是通过这种方法来验证阻塞并不可靠。首先阻塞并不意味线程状态为WAITING，JVM可能使用自旋来实现阻塞；其次执行了Object.wait()的线程肯能会被唤醒进入RUNNING状态，但这不意味着等待条件成立；再次Thread从发生阻塞到进入WAITING状态需要一定时间。\n总体来说Thread.getState()方法并不是用于状态控制或者测试的，其主要应用场景是输出调试信息。\n\n### 线程安全性测试\n\n线程安全性的测试代码需要多线程并发执行，来确定是否有竞态条件等情况；但书写正确的并发测试代码也很有难度，同时要防止额外的测试代码同步影响被测试代码的同步情况。\n\n线程安全性的测试程序最好不要引入新的同步。\n\n本章使用了一个生产者消费者模式的实现，来作为线程安全性测试的例子，细节较多可以看原文。\n\n线程安全性测试理应运行在多核系统上，为了尽可能发现竞态条件运行线程数量应该多于Cpu数量。\n\n并发测试程序应当设置超时，以防止因为错误造成的程序无法结束。\n\n### 测试资源管理\n\n测试是否有内存泄漏。\n\n### 增加线程切换\n\n线程安全问题能否出线也许依赖运气，但是增加线程切换可以增加线程安全问题被暴露的几率。\n在适当的位置调用Thread.yield()可以增加线程切换的机会。\n\n## 性能测试\n\n略\n\n## 避免性能测试中的干扰\n\n### GC干扰\n\n是否触发GC会对性能测试结果产生明显的影响。避免GC干扰的主要方式就是确保测试过程中不触发GC(这个似乎很难保证)；或者使用足够多的内存申请，并运行足够长的时间，确保在测试过程中总是触发适当的GC(可以通过log来检查GC是否真的发生)。\n\n### 动态编译干扰\n\n由于JIT的存在，解释器执行字节码的效率远低于JIT后直接执行汇编。JIT干扰性能测试主要有两种因素：动态编译本身耗时，无法预测动态编译何时发生就无法确定测试究竟是执行的字节码还是汇编。\n\n避免动态编译干扰的一种方法是，先让被测试代码进行“热身”(预执行N个循环)，在进行性能测试。有些JVM在动态编译发生时会输出log。\n\n由于JVM会执行很多额外工作，如果一次运行中包含几组不相干的性能测试时，在几组测试之间加入Thread.Sleep()来防止JVM后台线程的干扰。\n\n### 代码优化(忽略无用)造成的干扰\n\n在性能测试中，需要防止编译器将测试代码视为无用代码进行删除优化，导致测试结果过于乐观。这就要求一些出于测试目的的运算的结果在后续代码中被使用。\n\n一种做法是打印测试运算的结果，但是额外的IO也会干扰性能测试；一种trick的方法是：使用运算结果的hashCode和一个随机值做比较，相等时打印一些信息，这个比较几乎不会成功所以对测试干扰非常小，例如下面的代码：\n\n```java\nif (foo.x.hashCode() == System.nanoTime()) \n    System.out.print(\" \");\n```\n\n同时在性能测试的运算中，要防止运算结果可以被编译器预测从而进行优化；加入时间变量可以做到这一点。\n\n## 辅助测试的方法\n\n无论怎样，单元测试不会找到代码中所有的Bug，也许需要借助单元测试以外的方法来增加找到Bug的概率。\n\n### Code Review\n\n即便并发专家在写并发代码时也会犯错误，同时在单元测试中揭露线程安全错误是有运气成分的，所以CR总是必要的。\n\n### 静态代码分析工具\n\n例如FindBugs。\n\n###  aspect-oriented programming (AOP) \n\n展开点。\n\n### Profile工具\n\n\n\n","slug":"JCIP-chapter12-testing-concurrent-programs","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ow000d3mrf4vqo2vzc","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>aspect-oriented programming (AOP) 。</li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>并发相关的测试通常可以归类为线程安全测试和线程活跃性测试。<br>线程安全测试通常需要验证变量的一致性，所以测试代码本身也需要时线程安全的；但有时候加入这样的测试代码之后会隐藏原有的线程安全类bug。<br>线程活跃性测试的难点在于，如何界定活跃性问题(例如死锁)真的发生了和程序运行效率低之间的区别。<br>并发相关的性能测试包含如下指标：</p>\n<ul>\n<li>吞吐量：一组并发任务的完成速率。</li>\n<li>响应速度：单个任务提交到完成之间的时间跨度。</li>\n<li>伸缩性：吞吐量随并发数增长的幅度。</li>\n</ul>\n<h2 id=\"正确性测试\"><a href=\"#正确性测试\" class=\"headerlink\" title=\"正确性测试\"></a>正确性测试</h2><p>并发程序的正确性测试和非并发程序一样，需要找出所有的一致性条件进行验证，这一章用一个BlockingQueue的实现作为例子来做正确性测试。</p>\n<h3 id=\"基本单元测试\"><a href=\"#基本单元测试\" class=\"headerlink\" title=\"基本单元测试\"></a>基本单元测试</h3><p>与非并发程序相同，验证基本的一致性。</p>\n<h3 id=\"测试阻塞方法\"><a href=\"#测试阻塞方法\" class=\"headerlink\" title=\"测试阻塞方法\"></a>测试阻塞方法</h3><p>测试阻塞方法在条件满足时能否正确的阻塞，借助interrupt()和Thread.join()来完成测试。</p>\n<p>通过Thread.getState()方法可以返回线程是否在WAITING状态，但是通过这种方法来验证阻塞并不可靠。首先阻塞并不意味线程状态为WAITING，JVM可能使用自旋来实现阻塞；其次执行了Object.wait()的线程肯能会被唤醒进入RUNNING状态，但这不意味着等待条件成立；再次Thread从发生阻塞到进入WAITING状态需要一定时间。<br>总体来说Thread.getState()方法并不是用于状态控制或者测试的，其主要应用场景是输出调试信息。</p>\n<h3 id=\"线程安全性测试\"><a href=\"#线程安全性测试\" class=\"headerlink\" title=\"线程安全性测试\"></a>线程安全性测试</h3><p>线程安全性的测试代码需要多线程并发执行，来确定是否有竞态条件等情况；但书写正确的并发测试代码也很有难度，同时要防止额外的测试代码同步影响被测试代码的同步情况。</p>\n<p>线程安全性的测试程序最好不要引入新的同步。</p>\n<p>本章使用了一个生产者消费者模式的实现，来作为线程安全性测试的例子，细节较多可以看原文。</p>\n<p>线程安全性测试理应运行在多核系统上，为了尽可能发现竞态条件运行线程数量应该多于Cpu数量。</p>\n<p>并发测试程序应当设置超时，以防止因为错误造成的程序无法结束。</p>\n<h3 id=\"测试资源管理\"><a href=\"#测试资源管理\" class=\"headerlink\" title=\"测试资源管理\"></a>测试资源管理</h3><p>测试是否有内存泄漏。</p>\n<h3 id=\"增加线程切换\"><a href=\"#增加线程切换\" class=\"headerlink\" title=\"增加线程切换\"></a>增加线程切换</h3><p>线程安全问题能否出线也许依赖运气，但是增加线程切换可以增加线程安全问题被暴露的几率。<br>在适当的位置调用Thread.yield()可以增加线程切换的机会。</p>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p>略</p>\n<h2 id=\"避免性能测试中的干扰\"><a href=\"#避免性能测试中的干扰\" class=\"headerlink\" title=\"避免性能测试中的干扰\"></a>避免性能测试中的干扰</h2><h3 id=\"GC干扰\"><a href=\"#GC干扰\" class=\"headerlink\" title=\"GC干扰\"></a>GC干扰</h3><p>是否触发GC会对性能测试结果产生明显的影响。避免GC干扰的主要方式就是确保测试过程中不触发GC(这个似乎很难保证)；或者使用足够多的内存申请，并运行足够长的时间，确保在测试过程中总是触发适当的GC(可以通过log来检查GC是否真的发生)。</p>\n<h3 id=\"动态编译干扰\"><a href=\"#动态编译干扰\" class=\"headerlink\" title=\"动态编译干扰\"></a>动态编译干扰</h3><p>由于JIT的存在，解释器执行字节码的效率远低于JIT后直接执行汇编。JIT干扰性能测试主要有两种因素：动态编译本身耗时，无法预测动态编译何时发生就无法确定测试究竟是执行的字节码还是汇编。</p>\n<p>避免动态编译干扰的一种方法是，先让被测试代码进行“热身”(预执行N个循环)，在进行性能测试。有些JVM在动态编译发生时会输出log。</p>\n<p>由于JVM会执行很多额外工作，如果一次运行中包含几组不相干的性能测试时，在几组测试之间加入Thread.Sleep()来防止JVM后台线程的干扰。</p>\n<h3 id=\"代码优化-忽略无用-造成的干扰\"><a href=\"#代码优化-忽略无用-造成的干扰\" class=\"headerlink\" title=\"代码优化(忽略无用)造成的干扰\"></a>代码优化(忽略无用)造成的干扰</h3><p>在性能测试中，需要防止编译器将测试代码视为无用代码进行删除优化，导致测试结果过于乐观。这就要求一些出于测试目的的运算的结果在后续代码中被使用。</p>\n<p>一种做法是打印测试运算的结果，但是额外的IO也会干扰性能测试；一种trick的方法是：使用运算结果的hashCode和一个随机值做比较，相等时打印一些信息，这个比较几乎不会成功所以对测试干扰非常小，例如下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (foo.x.hashCode() == System.nanoTime()) </span><br><span class=\"line\">    System.out.print(<span class=\"string\">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>同时在性能测试的运算中，要防止运算结果可以被编译器预测从而进行优化；加入时间变量可以做到这一点。</p>\n<h2 id=\"辅助测试的方法\"><a href=\"#辅助测试的方法\" class=\"headerlink\" title=\"辅助测试的方法\"></a>辅助测试的方法</h2><p>无论怎样，单元测试不会找到代码中所有的Bug，也许需要借助单元测试以外的方法来增加找到Bug的概率。</p>\n<h3 id=\"Code-Review\"><a href=\"#Code-Review\" class=\"headerlink\" title=\"Code Review\"></a>Code Review</h3><p>即便并发专家在写并发代码时也会犯错误，同时在单元测试中揭露线程安全错误是有运气成分的，所以CR总是必要的。</p>\n<h3 id=\"静态代码分析工具\"><a href=\"#静态代码分析工具\" class=\"headerlink\" title=\"静态代码分析工具\"></a>静态代码分析工具</h3><p>例如FindBugs。</p>\n<h3 id=\"aspect-oriented-programming-AOP\"><a href=\"#aspect-oriented-programming-AOP\" class=\"headerlink\" title=\"aspect-oriented programming (AOP)\"></a>aspect-oriented programming (AOP)</h3><p>展开点。</p>\n<h3 id=\"Profile工具\"><a href=\"#Profile工具\" class=\"headerlink\" title=\"Profile工具\"></a>Profile工具</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>aspect-oriented programming (AOP) 。</li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>并发相关的测试通常可以归类为线程安全测试和线程活跃性测试。<br>线程安全测试通常需要验证变量的一致性，所以测试代码本身也需要时线程安全的；但有时候加入这样的测试代码之后会隐藏原有的线程安全类bug。<br>线程活跃性测试的难点在于，如何界定活跃性问题(例如死锁)真的发生了和程序运行效率低之间的区别。<br>并发相关的性能测试包含如下指标：</p>\n<ul>\n<li>吞吐量：一组并发任务的完成速率。</li>\n<li>响应速度：单个任务提交到完成之间的时间跨度。</li>\n<li>伸缩性：吞吐量随并发数增长的幅度。</li>\n</ul>\n<h2 id=\"正确性测试\"><a href=\"#正确性测试\" class=\"headerlink\" title=\"正确性测试\"></a>正确性测试</h2><p>并发程序的正确性测试和非并发程序一样，需要找出所有的一致性条件进行验证，这一章用一个BlockingQueue的实现作为例子来做正确性测试。</p>\n<h3 id=\"基本单元测试\"><a href=\"#基本单元测试\" class=\"headerlink\" title=\"基本单元测试\"></a>基本单元测试</h3><p>与非并发程序相同，验证基本的一致性。</p>\n<h3 id=\"测试阻塞方法\"><a href=\"#测试阻塞方法\" class=\"headerlink\" title=\"测试阻塞方法\"></a>测试阻塞方法</h3><p>测试阻塞方法在条件满足时能否正确的阻塞，借助interrupt()和Thread.join()来完成测试。</p>\n<p>通过Thread.getState()方法可以返回线程是否在WAITING状态，但是通过这种方法来验证阻塞并不可靠。首先阻塞并不意味线程状态为WAITING，JVM可能使用自旋来实现阻塞；其次执行了Object.wait()的线程肯能会被唤醒进入RUNNING状态，但这不意味着等待条件成立；再次Thread从发生阻塞到进入WAITING状态需要一定时间。<br>总体来说Thread.getState()方法并不是用于状态控制或者测试的，其主要应用场景是输出调试信息。</p>\n<h3 id=\"线程安全性测试\"><a href=\"#线程安全性测试\" class=\"headerlink\" title=\"线程安全性测试\"></a>线程安全性测试</h3><p>线程安全性的测试代码需要多线程并发执行，来确定是否有竞态条件等情况；但书写正确的并发测试代码也很有难度，同时要防止额外的测试代码同步影响被测试代码的同步情况。</p>\n<p>线程安全性的测试程序最好不要引入新的同步。</p>\n<p>本章使用了一个生产者消费者模式的实现，来作为线程安全性测试的例子，细节较多可以看原文。</p>\n<p>线程安全性测试理应运行在多核系统上，为了尽可能发现竞态条件运行线程数量应该多于Cpu数量。</p>\n<p>并发测试程序应当设置超时，以防止因为错误造成的程序无法结束。</p>\n<h3 id=\"测试资源管理\"><a href=\"#测试资源管理\" class=\"headerlink\" title=\"测试资源管理\"></a>测试资源管理</h3><p>测试是否有内存泄漏。</p>\n<h3 id=\"增加线程切换\"><a href=\"#增加线程切换\" class=\"headerlink\" title=\"增加线程切换\"></a>增加线程切换</h3><p>线程安全问题能否出线也许依赖运气，但是增加线程切换可以增加线程安全问题被暴露的几率。<br>在适当的位置调用Thread.yield()可以增加线程切换的机会。</p>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p>略</p>\n<h2 id=\"避免性能测试中的干扰\"><a href=\"#避免性能测试中的干扰\" class=\"headerlink\" title=\"避免性能测试中的干扰\"></a>避免性能测试中的干扰</h2><h3 id=\"GC干扰\"><a href=\"#GC干扰\" class=\"headerlink\" title=\"GC干扰\"></a>GC干扰</h3><p>是否触发GC会对性能测试结果产生明显的影响。避免GC干扰的主要方式就是确保测试过程中不触发GC(这个似乎很难保证)；或者使用足够多的内存申请，并运行足够长的时间，确保在测试过程中总是触发适当的GC(可以通过log来检查GC是否真的发生)。</p>\n<h3 id=\"动态编译干扰\"><a href=\"#动态编译干扰\" class=\"headerlink\" title=\"动态编译干扰\"></a>动态编译干扰</h3><p>由于JIT的存在，解释器执行字节码的效率远低于JIT后直接执行汇编。JIT干扰性能测试主要有两种因素：动态编译本身耗时，无法预测动态编译何时发生就无法确定测试究竟是执行的字节码还是汇编。</p>\n<p>避免动态编译干扰的一种方法是，先让被测试代码进行“热身”(预执行N个循环)，在进行性能测试。有些JVM在动态编译发生时会输出log。</p>\n<p>由于JVM会执行很多额外工作，如果一次运行中包含几组不相干的性能测试时，在几组测试之间加入Thread.Sleep()来防止JVM后台线程的干扰。</p>\n<h3 id=\"代码优化-忽略无用-造成的干扰\"><a href=\"#代码优化-忽略无用-造成的干扰\" class=\"headerlink\" title=\"代码优化(忽略无用)造成的干扰\"></a>代码优化(忽略无用)造成的干扰</h3><p>在性能测试中，需要防止编译器将测试代码视为无用代码进行删除优化，导致测试结果过于乐观。这就要求一些出于测试目的的运算的结果在后续代码中被使用。</p>\n<p>一种做法是打印测试运算的结果，但是额外的IO也会干扰性能测试；一种trick的方法是：使用运算结果的hashCode和一个随机值做比较，相等时打印一些信息，这个比较几乎不会成功所以对测试干扰非常小，例如下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (foo.x.hashCode() == System.nanoTime()) </span><br><span class=\"line\">    System.out.print(<span class=\"string\">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>同时在性能测试的运算中，要防止运算结果可以被编译器预测从而进行优化；加入时间变量可以做到这一点。</p>\n<h2 id=\"辅助测试的方法\"><a href=\"#辅助测试的方法\" class=\"headerlink\" title=\"辅助测试的方法\"></a>辅助测试的方法</h2><p>无论怎样，单元测试不会找到代码中所有的Bug，也许需要借助单元测试以外的方法来增加找到Bug的概率。</p>\n<h3 id=\"Code-Review\"><a href=\"#Code-Review\" class=\"headerlink\" title=\"Code Review\"></a>Code Review</h3><p>即便并发专家在写并发代码时也会犯错误，同时在单元测试中揭露线程安全错误是有运气成分的，所以CR总是必要的。</p>\n<h3 id=\"静态代码分析工具\"><a href=\"#静态代码分析工具\" class=\"headerlink\" title=\"静态代码分析工具\"></a>静态代码分析工具</h3><p>例如FindBugs。</p>\n<h3 id=\"aspect-oriented-programming-AOP\"><a href=\"#aspect-oriented-programming-AOP\" class=\"headerlink\" title=\"aspect-oriented programming (AOP)\"></a>aspect-oriented programming (AOP)</h3><p>展开点。</p>\n<h3 id=\"Profile工具\"><a href=\"#Profile工具\" class=\"headerlink\" title=\"Profile工具\"></a>Profile工具</h3>"},{"title":"显式锁","subtitle":"JCIP读书笔记第十三章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-09-29T07:58:59.000Z","_content":"\n\n## caution\n\n## 开头\n\nJava 5.0之前，Java只有内置锁和volatile；从Java 5.0开始，引入了显式锁来提供一些内置锁所不具备的功能。\n\n## Lock和ReentrantLock\n\nLock是个接口，定义了显式锁的基本行为；ReentrantLock是Lock的常用实现，其同步语意和内置锁基本相同。\n\nReentrantLock相对于内置锁提供了更多的功能：可中断的获取锁的方法、如果失败立即返回(或超时返回)的获取锁的方法；可以在代码的任意部分释放锁，而不用局限在synchronized代码块中。\n由于显式锁必须显示释放，所以绝大多数情况下，unlock()方法要写在finally代码块中以保证安全；如果不这样做，由于某种原因造成没有执行unlock()的错误，将十分难以追查。\n\nLock接口如下:\n\n```java\npublic interface Lock { \n    void lock();\n    void lockInterruptibly() throws InterruptedException; boolean tryLock();\n    boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException; \n    void unlock();\n    Condition newCondition(); \n}\n```\n\n## 性能对比\n\n在Java 5.0时，ReentrantLock的性能比内置锁好很多；但从Java 6.0内置锁的性能被改进之后，ReentrantLock和内置锁就没有明显的性能差异了。\n\n## 公平性\n\nReentrantLock提供了公平锁和非公平锁的功能选择。\n公平锁会将请求锁的线程排队，然后实行先到先得方案；非公平锁在某个线程请求锁时会插队尝试是否能直接获取成功，只有请求不成功时才会将线程排队。(即便是公平锁，在使用tryLock()操作时也会插队)\n。\n在竞争较多时公平锁的性能远差于非公平锁；公平锁更适用于持有锁和获取锁时间都很长的情况。\n\n## 内置锁还是ReentrantLock\n\n除非需要使用ReentrantLock提供能附加功能(响应中断、公平性等等)，那么请选择内置锁。\n\n## 读写锁\n\n读写锁允许多个线程同时持有“读锁”，但仅有一个线程持有\"写锁“(当然持有\"写锁\"时其他线程也不能获取\"读锁\")。其接口定义如下:\n\n```java\npublic interface ReadWriteLock { \n    Lock readLock();\n    Lock writeLock();\n}\n```\n\nReentrantReadWriteLock是读写锁的一个实现。\n读写锁的使用是出于性能考虑，在读操作明显多于写操作、读操作执行时间较长的情况下，读写锁的性能优于独占锁；在其他情况下，读写锁的性能不及独占锁。当然，使用读写锁能否提升性能，还得看profiling的结果。\n\n","source":"_posts/JCIP-chapter13-explicit-locks.md","raw":"---\ntitle: 显式锁\nsubtitle: JCIP读书笔记第十三章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-09-29 15:58:59\n---\n\n\n## caution\n\n## 开头\n\nJava 5.0之前，Java只有内置锁和volatile；从Java 5.0开始，引入了显式锁来提供一些内置锁所不具备的功能。\n\n## Lock和ReentrantLock\n\nLock是个接口，定义了显式锁的基本行为；ReentrantLock是Lock的常用实现，其同步语意和内置锁基本相同。\n\nReentrantLock相对于内置锁提供了更多的功能：可中断的获取锁的方法、如果失败立即返回(或超时返回)的获取锁的方法；可以在代码的任意部分释放锁，而不用局限在synchronized代码块中。\n由于显式锁必须显示释放，所以绝大多数情况下，unlock()方法要写在finally代码块中以保证安全；如果不这样做，由于某种原因造成没有执行unlock()的错误，将十分难以追查。\n\nLock接口如下:\n\n```java\npublic interface Lock { \n    void lock();\n    void lockInterruptibly() throws InterruptedException; boolean tryLock();\n    boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException; \n    void unlock();\n    Condition newCondition(); \n}\n```\n\n## 性能对比\n\n在Java 5.0时，ReentrantLock的性能比内置锁好很多；但从Java 6.0内置锁的性能被改进之后，ReentrantLock和内置锁就没有明显的性能差异了。\n\n## 公平性\n\nReentrantLock提供了公平锁和非公平锁的功能选择。\n公平锁会将请求锁的线程排队，然后实行先到先得方案；非公平锁在某个线程请求锁时会插队尝试是否能直接获取成功，只有请求不成功时才会将线程排队。(即便是公平锁，在使用tryLock()操作时也会插队)\n。\n在竞争较多时公平锁的性能远差于非公平锁；公平锁更适用于持有锁和获取锁时间都很长的情况。\n\n## 内置锁还是ReentrantLock\n\n除非需要使用ReentrantLock提供能附加功能(响应中断、公平性等等)，那么请选择内置锁。\n\n## 读写锁\n\n读写锁允许多个线程同时持有“读锁”，但仅有一个线程持有\"写锁“(当然持有\"写锁\"时其他线程也不能获取\"读锁\")。其接口定义如下:\n\n```java\npublic interface ReadWriteLock { \n    Lock readLock();\n    Lock writeLock();\n}\n```\n\nReentrantReadWriteLock是读写锁的一个实现。\n读写锁的使用是出于性能考虑，在读操作明显多于写操作、读操作执行时间较长的情况下，读写锁的性能优于独占锁；在其他情况下，读写锁的性能不及独占锁。当然，使用读写锁能否提升性能，还得看profiling的结果。\n\n","slug":"JCIP-chapter13-explicit-locks","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ox000e3mrffsemfh8n","content":"<h2 id=\"caution\"><a href=\"#caution\" class=\"headerlink\" title=\"caution\"></a>caution</h2><h2 id=\"开头\"><a href=\"#开头\" class=\"headerlink\" title=\"开头\"></a>开头</h2><p>Java 5.0之前，Java只有内置锁和volatile；从Java 5.0开始，引入了显式锁来提供一些内置锁所不具备的功能。</p>\n<h2 id=\"Lock和ReentrantLock\"><a href=\"#Lock和ReentrantLock\" class=\"headerlink\" title=\"Lock和ReentrantLock\"></a>Lock和ReentrantLock</h2><p>Lock是个接口，定义了显式锁的基本行为；ReentrantLock是Lock的常用实现，其同步语意和内置锁基本相同。</p>\n<p>ReentrantLock相对于内置锁提供了更多的功能：可中断的获取锁的方法、如果失败立即返回(或超时返回)的获取锁的方法；可以在代码的任意部分释放锁，而不用局限在synchronized代码块中。<br>由于显式锁必须显示释放，所以绝大多数情况下，unlock()方法要写在finally代码块中以保证安全；如果不这样做，由于某种原因造成没有执行unlock()的错误，将十分难以追查。</p>\n<p>Lock接口如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lock</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException</span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h2><p>在Java 5.0时，ReentrantLock的性能比内置锁好很多；但从Java 6.0内置锁的性能被改进之后，ReentrantLock和内置锁就没有明显的性能差异了。</p>\n<h2 id=\"公平性\"><a href=\"#公平性\" class=\"headerlink\" title=\"公平性\"></a>公平性</h2><p>ReentrantLock提供了公平锁和非公平锁的功能选择。<br>公平锁会将请求锁的线程排队，然后实行先到先得方案；非公平锁在某个线程请求锁时会插队尝试是否能直接获取成功，只有请求不成功时才会将线程排队。(即便是公平锁，在使用tryLock()操作时也会插队)<br>。<br>在竞争较多时公平锁的性能远差于非公平锁；公平锁更适用于持有锁和获取锁时间都很长的情况。</p>\n<h2 id=\"内置锁还是ReentrantLock\"><a href=\"#内置锁还是ReentrantLock\" class=\"headerlink\" title=\"内置锁还是ReentrantLock\"></a>内置锁还是ReentrantLock</h2><p>除非需要使用ReentrantLock提供能附加功能(响应中断、公平性等等)，那么请选择内置锁。</p>\n<h2 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h2><p>读写锁允许多个线程同时持有“读锁”，但仅有一个线程持有”写锁“(当然持有”写锁”时其他线程也不能获取”读锁”)。其接口定义如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadWriteLock</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\">Lock <span class=\"title\">readLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Lock <span class=\"title\">writeLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ReentrantReadWriteLock是读写锁的一个实现。<br>读写锁的使用是出于性能考虑，在读操作明显多于写操作、读操作执行时间较长的情况下，读写锁的性能优于独占锁；在其他情况下，读写锁的性能不及独占锁。当然，使用读写锁能否提升性能，还得看profiling的结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"caution\"><a href=\"#caution\" class=\"headerlink\" title=\"caution\"></a>caution</h2><h2 id=\"开头\"><a href=\"#开头\" class=\"headerlink\" title=\"开头\"></a>开头</h2><p>Java 5.0之前，Java只有内置锁和volatile；从Java 5.0开始，引入了显式锁来提供一些内置锁所不具备的功能。</p>\n<h2 id=\"Lock和ReentrantLock\"><a href=\"#Lock和ReentrantLock\" class=\"headerlink\" title=\"Lock和ReentrantLock\"></a>Lock和ReentrantLock</h2><p>Lock是个接口，定义了显式锁的基本行为；ReentrantLock是Lock的常用实现，其同步语意和内置锁基本相同。</p>\n<p>ReentrantLock相对于内置锁提供了更多的功能：可中断的获取锁的方法、如果失败立即返回(或超时返回)的获取锁的方法；可以在代码的任意部分释放锁，而不用局限在synchronized代码块中。<br>由于显式锁必须显示释放，所以绝大多数情况下，unlock()方法要写在finally代码块中以保证安全；如果不这样做，由于某种原因造成没有执行unlock()的错误，将十分难以追查。</p>\n<p>Lock接口如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lock</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException</span>; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h2><p>在Java 5.0时，ReentrantLock的性能比内置锁好很多；但从Java 6.0内置锁的性能被改进之后，ReentrantLock和内置锁就没有明显的性能差异了。</p>\n<h2 id=\"公平性\"><a href=\"#公平性\" class=\"headerlink\" title=\"公平性\"></a>公平性</h2><p>ReentrantLock提供了公平锁和非公平锁的功能选择。<br>公平锁会将请求锁的线程排队，然后实行先到先得方案；非公平锁在某个线程请求锁时会插队尝试是否能直接获取成功，只有请求不成功时才会将线程排队。(即便是公平锁，在使用tryLock()操作时也会插队)<br>。<br>在竞争较多时公平锁的性能远差于非公平锁；公平锁更适用于持有锁和获取锁时间都很长的情况。</p>\n<h2 id=\"内置锁还是ReentrantLock\"><a href=\"#内置锁还是ReentrantLock\" class=\"headerlink\" title=\"内置锁还是ReentrantLock\"></a>内置锁还是ReentrantLock</h2><p>除非需要使用ReentrantLock提供能附加功能(响应中断、公平性等等)，那么请选择内置锁。</p>\n<h2 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h2><p>读写锁允许多个线程同时持有“读锁”，但仅有一个线程持有”写锁“(当然持有”写锁”时其他线程也不能获取”读锁”)。其接口定义如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadWriteLock</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\">Lock <span class=\"title\">readLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Lock <span class=\"title\">writeLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ReentrantReadWriteLock是读写锁的一个实现。<br>读写锁的使用是出于性能考虑，在读操作明显多于写操作、读操作执行时间较长的情况下，读写锁的性能优于独占锁；在其他情况下，读写锁的性能不及独占锁。当然，使用读写锁能否提升性能，还得看profiling的结果。</p>\n"},{"title":"自定义同步工具类","subtitle":"JCIP读书笔记第十四章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-09-29T06:05:13.000Z","_content":"\n\n## caution\n\n## 概述\n\n自定义同步工具类最简单的方式就是基于已有的同步工具类；当然你也可以借助\"内置Condition Queue\"、\"显示Condition Queue\"以及AQS(AbstractQueuedSynchronizer)。\n\n## 条件依赖操作与同步\n\n如果不借助Condition Queue，Blocking等待条件成立写起来往往很麻烦，比如：\n\n```java\n    acquire lock on object state\n    while (precondition does not hold) {\n        release lock\n        wait until precondition might hold\n        optionally fail if interrupted or timeout expires reacquire lock\n    }\n    perform action release lock\n```\n\n在依赖条件不满足时，可以选择抛出异常、返回错误码、等待条件成立等不同策略。\n\n### 当没有Condition Queue\n\n这里在不使用Condition Queue的情况下，提供两个BlockingQueue的简单实现，并指出其不方便或没效率的缺点。\n\n### 当有了Condition Queue\n\nCondition Queue提供了“挂起线程，等待条件成立”和“提醒等待线程条件成立”的一组操作。所以在Condition Queue这个概念中，Queue中的元素是等待的线程。\n\n就如同Object可以作为内置锁一样，Object也可以作为内置的Condition Queue，并提供了wait()、notify()、notifyAll等API。\n同时内置锁和内置CQ有紧密的联系，在调用内置CQ的API时必须持有同一个对象的内置锁。\n在调用wait()之后，当前线程自动释放了相同对象的内置锁，并要求操作系统挂起当前线程；当从wait()返回时，回自动获取相同对象的内置锁。\n\n使用CQ实现Blocking可以获得更高的效率、更快的响应速度；使用fair CQ还可以获得额外的调度策略。\n\n## CQ的使用\n\n这一章介绍一些使用CQ的模式和准则，以防止开发者错误的使用CQ。\n\n### 等待条件\n\nCQ往往是在等待某个条件成立，为了正确使用CQ，应当用文档(注释)记录与CQ相关的条件，以及会影响这些条件(使条件成立)的操作。\nCQ和等待条件与锁紧密相关，在执行wait()时必须持有相关的锁，而这个锁往往是用来保护等待条件中的变量的。\n\n### CQ被反复唤醒\n\n与一个CQ关联的等待条件可能有多个，所以CQ被唤醒(并重新活得锁)不意味着等待条件一定成立。等待CQ的经典写法如下:\n\n```java\nvoid stateDependentMethod() throws InterruptedException {\n    // condition predicate must be guarded by lock\n    synchronized(lock) {\n        while (!conditionPredicate())\n            lock.wait();\n        // object is now in desired state\n    } \n}\n```\n\n在编写等待CQ的代码注意如下条件:\n\n* 一定要拥有一个等待条件。\n* CQ每次被唤醒时需要检查等待条件。\n* 将等待操作和条件检查置于循环中。\n* 确保保护等待条件的锁和CQ关联的锁是同一个。\n* 在调用CQ相关API时必须持有CQ关联的锁。\n\n### 唤醒CQ\n\n当某个操作会让CQ的一个等待条件变为成立时，记得在操作的同时唤醒CQ。(在开发中，这件事情似乎很容易发生疏漏)\nnotify()会选择唤醒一个等待线程；notifyAll会唤醒全部的等待线程。\n使用notify()时容易出错，例如当CQ关联多个等待条件时，条件A发出的提醒可能唤醒等待条件B的线程，而等待条件A的线程会错过这次提醒。所以使用notify()而不是notifyAll()时要格外谨慎，以下是使用notify()的准则：\n\n* CQ仅仅关联一个等待条件，并且等待线程都执行相同的操作。\n* 每次提醒能且仅能满足一个等待线程完成操作。\n\n### 继承和CQ/封装和CQ\n\n当继承发生在使用CQ的类上时有两种选择：父类将等待策略(等待条件、提醒策略)和相关对象(CQ对象、锁对象、状态对象)完整的暴露给子类，并提供足够的文档(注释)；或者可以选择，禁止继承/对子类隐藏所有和相关对象(CQ对象、锁对象、状态对象)。\n\n和继承同理，使用CQ的类应该将CQ相关对象封装在类内部，以防止类的使用者干扰等待策略。\n\n## 显式的CQ对象\n\n内置CQ的一个缺陷是一个内置锁只能关联一个内置CQ，这样导致了一个CQ关联多个等待条件的情况十分常见，也就难以满足使用notify()的条件。\n显式CQ被称为Condition，它与一个显式锁Lock相关联；Condition可以通过Lock.newCondition()方法创建，一个Lock可以关联多个Condition；Condition的公平性与其关联锁的公平性一致(公平锁创建的Condition也是公平的)。\n\n**注意：不要误用Condition对象自身的内置CQ。**\n\n这一节还给出了一个用显式CQ实现的BlockingQueue的例子，可以发现当有等待条件时Condition比内置CQ有更好的可读性，切更容易使用单一提醒来提升效率。\n\n## AQS(AbstractQueuedSynchronizer)\n\nAQS是大多同步工具类的基础组件，通过继承AQS来实现同步工具。\n在AQS内部存在一个整数变了，用于表示同步工具的状态；AQS提供了一组方法，包括原子读写状态、原子CAS状态用于修改状态，线程独占或线程共享的Acquire/Release方法用于提供安全方法；开发者需要继承tryAcquire/tryAcquireShared和tryRelease/tryReleaseShared来决定同步工具的具体行为。\n\n本章没有展开介绍AQS的使用细节，如果想深入了解的话，参考`java.util.concurrent`包中同步工具类的实现。\n\n## 在Java标准库中的AQS\n\n本章介绍了一些`java.util.concurrent`中类的实现，这些类是基于AQS的。\n\n\n\n\n\n\n\n\n","source":"_posts/JCIP-chapter14-building-custom-synchronizers.md","raw":"---\ntitle: 自定义同步工具类\nsubtitle: JCIP读书笔记第十四章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-09-29 14:05:13\n---\n\n\n## caution\n\n## 概述\n\n自定义同步工具类最简单的方式就是基于已有的同步工具类；当然你也可以借助\"内置Condition Queue\"、\"显示Condition Queue\"以及AQS(AbstractQueuedSynchronizer)。\n\n## 条件依赖操作与同步\n\n如果不借助Condition Queue，Blocking等待条件成立写起来往往很麻烦，比如：\n\n```java\n    acquire lock on object state\n    while (precondition does not hold) {\n        release lock\n        wait until precondition might hold\n        optionally fail if interrupted or timeout expires reacquire lock\n    }\n    perform action release lock\n```\n\n在依赖条件不满足时，可以选择抛出异常、返回错误码、等待条件成立等不同策略。\n\n### 当没有Condition Queue\n\n这里在不使用Condition Queue的情况下，提供两个BlockingQueue的简单实现，并指出其不方便或没效率的缺点。\n\n### 当有了Condition Queue\n\nCondition Queue提供了“挂起线程，等待条件成立”和“提醒等待线程条件成立”的一组操作。所以在Condition Queue这个概念中，Queue中的元素是等待的线程。\n\n就如同Object可以作为内置锁一样，Object也可以作为内置的Condition Queue，并提供了wait()、notify()、notifyAll等API。\n同时内置锁和内置CQ有紧密的联系，在调用内置CQ的API时必须持有同一个对象的内置锁。\n在调用wait()之后，当前线程自动释放了相同对象的内置锁，并要求操作系统挂起当前线程；当从wait()返回时，回自动获取相同对象的内置锁。\n\n使用CQ实现Blocking可以获得更高的效率、更快的响应速度；使用fair CQ还可以获得额外的调度策略。\n\n## CQ的使用\n\n这一章介绍一些使用CQ的模式和准则，以防止开发者错误的使用CQ。\n\n### 等待条件\n\nCQ往往是在等待某个条件成立，为了正确使用CQ，应当用文档(注释)记录与CQ相关的条件，以及会影响这些条件(使条件成立)的操作。\nCQ和等待条件与锁紧密相关，在执行wait()时必须持有相关的锁，而这个锁往往是用来保护等待条件中的变量的。\n\n### CQ被反复唤醒\n\n与一个CQ关联的等待条件可能有多个，所以CQ被唤醒(并重新活得锁)不意味着等待条件一定成立。等待CQ的经典写法如下:\n\n```java\nvoid stateDependentMethod() throws InterruptedException {\n    // condition predicate must be guarded by lock\n    synchronized(lock) {\n        while (!conditionPredicate())\n            lock.wait();\n        // object is now in desired state\n    } \n}\n```\n\n在编写等待CQ的代码注意如下条件:\n\n* 一定要拥有一个等待条件。\n* CQ每次被唤醒时需要检查等待条件。\n* 将等待操作和条件检查置于循环中。\n* 确保保护等待条件的锁和CQ关联的锁是同一个。\n* 在调用CQ相关API时必须持有CQ关联的锁。\n\n### 唤醒CQ\n\n当某个操作会让CQ的一个等待条件变为成立时，记得在操作的同时唤醒CQ。(在开发中，这件事情似乎很容易发生疏漏)\nnotify()会选择唤醒一个等待线程；notifyAll会唤醒全部的等待线程。\n使用notify()时容易出错，例如当CQ关联多个等待条件时，条件A发出的提醒可能唤醒等待条件B的线程，而等待条件A的线程会错过这次提醒。所以使用notify()而不是notifyAll()时要格外谨慎，以下是使用notify()的准则：\n\n* CQ仅仅关联一个等待条件，并且等待线程都执行相同的操作。\n* 每次提醒能且仅能满足一个等待线程完成操作。\n\n### 继承和CQ/封装和CQ\n\n当继承发生在使用CQ的类上时有两种选择：父类将等待策略(等待条件、提醒策略)和相关对象(CQ对象、锁对象、状态对象)完整的暴露给子类，并提供足够的文档(注释)；或者可以选择，禁止继承/对子类隐藏所有和相关对象(CQ对象、锁对象、状态对象)。\n\n和继承同理，使用CQ的类应该将CQ相关对象封装在类内部，以防止类的使用者干扰等待策略。\n\n## 显式的CQ对象\n\n内置CQ的一个缺陷是一个内置锁只能关联一个内置CQ，这样导致了一个CQ关联多个等待条件的情况十分常见，也就难以满足使用notify()的条件。\n显式CQ被称为Condition，它与一个显式锁Lock相关联；Condition可以通过Lock.newCondition()方法创建，一个Lock可以关联多个Condition；Condition的公平性与其关联锁的公平性一致(公平锁创建的Condition也是公平的)。\n\n**注意：不要误用Condition对象自身的内置CQ。**\n\n这一节还给出了一个用显式CQ实现的BlockingQueue的例子，可以发现当有等待条件时Condition比内置CQ有更好的可读性，切更容易使用单一提醒来提升效率。\n\n## AQS(AbstractQueuedSynchronizer)\n\nAQS是大多同步工具类的基础组件，通过继承AQS来实现同步工具。\n在AQS内部存在一个整数变了，用于表示同步工具的状态；AQS提供了一组方法，包括原子读写状态、原子CAS状态用于修改状态，线程独占或线程共享的Acquire/Release方法用于提供安全方法；开发者需要继承tryAcquire/tryAcquireShared和tryRelease/tryReleaseShared来决定同步工具的具体行为。\n\n本章没有展开介绍AQS的使用细节，如果想深入了解的话，参考`java.util.concurrent`包中同步工具类的实现。\n\n## 在Java标准库中的AQS\n\n本章介绍了一些`java.util.concurrent`中类的实现，这些类是基于AQS的。\n\n\n\n\n\n\n\n\n","slug":"JCIP-chapter14-building-custom-synchronizers","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4ox000f3mrf3zbobrq7","content":"<h2 id=\"caution\"><a href=\"#caution\" class=\"headerlink\" title=\"caution\"></a>caution</h2><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>自定义同步工具类最简单的方式就是基于已有的同步工具类；当然你也可以借助”内置Condition Queue”、”显示Condition Queue”以及AQS(AbstractQueuedSynchronizer)。</p>\n<h2 id=\"条件依赖操作与同步\"><a href=\"#条件依赖操作与同步\" class=\"headerlink\" title=\"条件依赖操作与同步\"></a>条件依赖操作与同步</h2><p>如果不借助Condition Queue，Blocking等待条件成立写起来往往很麻烦，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">acquire lock on object state</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">while</span> <span class=\"params\">(precondition does not hold)</span> </span>&#123;</span><br><span class=\"line\">    release lock</span><br><span class=\"line\">    wait until precondition might hold</span><br><span class=\"line\">    optionally fail <span class=\"keyword\">if</span> interrupted or timeout expires reacquire lock</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">perform action release lock</span><br></pre></td></tr></table></figure>\n<p>在依赖条件不满足时，可以选择抛出异常、返回错误码、等待条件成立等不同策略。</p>\n<h3 id=\"当没有Condition-Queue\"><a href=\"#当没有Condition-Queue\" class=\"headerlink\" title=\"当没有Condition Queue\"></a>当没有Condition Queue</h3><p>这里在不使用Condition Queue的情况下，提供两个BlockingQueue的简单实现，并指出其不方便或没效率的缺点。</p>\n<h3 id=\"当有了Condition-Queue\"><a href=\"#当有了Condition-Queue\" class=\"headerlink\" title=\"当有了Condition Queue\"></a>当有了Condition Queue</h3><p>Condition Queue提供了“挂起线程，等待条件成立”和“提醒等待线程条件成立”的一组操作。所以在Condition Queue这个概念中，Queue中的元素是等待的线程。</p>\n<p>就如同Object可以作为内置锁一样，Object也可以作为内置的Condition Queue，并提供了wait()、notify()、notifyAll等API。<br>同时内置锁和内置CQ有紧密的联系，在调用内置CQ的API时必须持有同一个对象的内置锁。<br>在调用wait()之后，当前线程自动释放了相同对象的内置锁，并要求操作系统挂起当前线程；当从wait()返回时，回自动获取相同对象的内置锁。</p>\n<p>使用CQ实现Blocking可以获得更高的效率、更快的响应速度；使用fair CQ还可以获得额外的调度策略。</p>\n<h2 id=\"CQ的使用\"><a href=\"#CQ的使用\" class=\"headerlink\" title=\"CQ的使用\"></a>CQ的使用</h2><p>这一章介绍一些使用CQ的模式和准则，以防止开发者错误的使用CQ。</p>\n<h3 id=\"等待条件\"><a href=\"#等待条件\" class=\"headerlink\" title=\"等待条件\"></a>等待条件</h3><p>CQ往往是在等待某个条件成立，为了正确使用CQ，应当用文档(注释)记录与CQ相关的条件，以及会影响这些条件(使条件成立)的操作。<br>CQ和等待条件与锁紧密相关，在执行wait()时必须持有相关的锁，而这个锁往往是用来保护等待条件中的变量的。</p>\n<h3 id=\"CQ被反复唤醒\"><a href=\"#CQ被反复唤醒\" class=\"headerlink\" title=\"CQ被反复唤醒\"></a>CQ被反复唤醒</h3><p>与一个CQ关联的等待条件可能有多个，所以CQ被唤醒(并重新活得锁)不意味着等待条件一定成立。等待CQ的经典写法如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stateDependentMethod</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// condition predicate must be guarded by lock</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!conditionPredicate())</span><br><span class=\"line\">            lock.wait();</span><br><span class=\"line\">        <span class=\"comment\">// object is now in desired state</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编写等待CQ的代码注意如下条件:</p>\n<ul>\n<li>一定要拥有一个等待条件。</li>\n<li>CQ每次被唤醒时需要检查等待条件。</li>\n<li>将等待操作和条件检查置于循环中。</li>\n<li>确保保护等待条件的锁和CQ关联的锁是同一个。</li>\n<li>在调用CQ相关API时必须持有CQ关联的锁。</li>\n</ul>\n<h3 id=\"唤醒CQ\"><a href=\"#唤醒CQ\" class=\"headerlink\" title=\"唤醒CQ\"></a>唤醒CQ</h3><p>当某个操作会让CQ的一个等待条件变为成立时，记得在操作的同时唤醒CQ。(在开发中，这件事情似乎很容易发生疏漏)<br>notify()会选择唤醒一个等待线程；notifyAll会唤醒全部的等待线程。<br>使用notify()时容易出错，例如当CQ关联多个等待条件时，条件A发出的提醒可能唤醒等待条件B的线程，而等待条件A的线程会错过这次提醒。所以使用notify()而不是notifyAll()时要格外谨慎，以下是使用notify()的准则：</p>\n<ul>\n<li>CQ仅仅关联一个等待条件，并且等待线程都执行相同的操作。</li>\n<li>每次提醒能且仅能满足一个等待线程完成操作。</li>\n</ul>\n<h3 id=\"继承和CQ-封装和CQ\"><a href=\"#继承和CQ-封装和CQ\" class=\"headerlink\" title=\"继承和CQ/封装和CQ\"></a>继承和CQ/封装和CQ</h3><p>当继承发生在使用CQ的类上时有两种选择：父类将等待策略(等待条件、提醒策略)和相关对象(CQ对象、锁对象、状态对象)完整的暴露给子类，并提供足够的文档(注释)；或者可以选择，禁止继承/对子类隐藏所有和相关对象(CQ对象、锁对象、状态对象)。</p>\n<p>和继承同理，使用CQ的类应该将CQ相关对象封装在类内部，以防止类的使用者干扰等待策略。</p>\n<h2 id=\"显式的CQ对象\"><a href=\"#显式的CQ对象\" class=\"headerlink\" title=\"显式的CQ对象\"></a>显式的CQ对象</h2><p>内置CQ的一个缺陷是一个内置锁只能关联一个内置CQ，这样导致了一个CQ关联多个等待条件的情况十分常见，也就难以满足使用notify()的条件。<br>显式CQ被称为Condition，它与一个显式锁Lock相关联；Condition可以通过Lock.newCondition()方法创建，一个Lock可以关联多个Condition；Condition的公平性与其关联锁的公平性一致(公平锁创建的Condition也是公平的)。</p>\n<p><strong>注意：不要误用Condition对象自身的内置CQ。</strong></p>\n<p>这一节还给出了一个用显式CQ实现的BlockingQueue的例子，可以发现当有等待条件时Condition比内置CQ有更好的可读性，切更容易使用单一提醒来提升效率。</p>\n<h2 id=\"AQS-AbstractQueuedSynchronizer\"><a href=\"#AQS-AbstractQueuedSynchronizer\" class=\"headerlink\" title=\"AQS(AbstractQueuedSynchronizer)\"></a>AQS(AbstractQueuedSynchronizer)</h2><p>AQS是大多同步工具类的基础组件，通过继承AQS来实现同步工具。<br>在AQS内部存在一个整数变了，用于表示同步工具的状态；AQS提供了一组方法，包括原子读写状态、原子CAS状态用于修改状态，线程独占或线程共享的Acquire/Release方法用于提供安全方法；开发者需要继承tryAcquire/tryAcquireShared和tryRelease/tryReleaseShared来决定同步工具的具体行为。</p>\n<p>本章没有展开介绍AQS的使用细节，如果想深入了解的话，参考<code>java.util.concurrent</code>包中同步工具类的实现。</p>\n<h2 id=\"在Java标准库中的AQS\"><a href=\"#在Java标准库中的AQS\" class=\"headerlink\" title=\"在Java标准库中的AQS\"></a>在Java标准库中的AQS</h2><p>本章介绍了一些<code>java.util.concurrent</code>中类的实现，这些类是基于AQS的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"caution\"><a href=\"#caution\" class=\"headerlink\" title=\"caution\"></a>caution</h2><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>自定义同步工具类最简单的方式就是基于已有的同步工具类；当然你也可以借助”内置Condition Queue”、”显示Condition Queue”以及AQS(AbstractQueuedSynchronizer)。</p>\n<h2 id=\"条件依赖操作与同步\"><a href=\"#条件依赖操作与同步\" class=\"headerlink\" title=\"条件依赖操作与同步\"></a>条件依赖操作与同步</h2><p>如果不借助Condition Queue，Blocking等待条件成立写起来往往很麻烦，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">acquire lock on object state</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">while</span> <span class=\"params\">(precondition does not hold)</span> </span>&#123;</span><br><span class=\"line\">    release lock</span><br><span class=\"line\">    wait until precondition might hold</span><br><span class=\"line\">    optionally fail <span class=\"keyword\">if</span> interrupted or timeout expires reacquire lock</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">perform action release lock</span><br></pre></td></tr></table></figure>\n<p>在依赖条件不满足时，可以选择抛出异常、返回错误码、等待条件成立等不同策略。</p>\n<h3 id=\"当没有Condition-Queue\"><a href=\"#当没有Condition-Queue\" class=\"headerlink\" title=\"当没有Condition Queue\"></a>当没有Condition Queue</h3><p>这里在不使用Condition Queue的情况下，提供两个BlockingQueue的简单实现，并指出其不方便或没效率的缺点。</p>\n<h3 id=\"当有了Condition-Queue\"><a href=\"#当有了Condition-Queue\" class=\"headerlink\" title=\"当有了Condition Queue\"></a>当有了Condition Queue</h3><p>Condition Queue提供了“挂起线程，等待条件成立”和“提醒等待线程条件成立”的一组操作。所以在Condition Queue这个概念中，Queue中的元素是等待的线程。</p>\n<p>就如同Object可以作为内置锁一样，Object也可以作为内置的Condition Queue，并提供了wait()、notify()、notifyAll等API。<br>同时内置锁和内置CQ有紧密的联系，在调用内置CQ的API时必须持有同一个对象的内置锁。<br>在调用wait()之后，当前线程自动释放了相同对象的内置锁，并要求操作系统挂起当前线程；当从wait()返回时，回自动获取相同对象的内置锁。</p>\n<p>使用CQ实现Blocking可以获得更高的效率、更快的响应速度；使用fair CQ还可以获得额外的调度策略。</p>\n<h2 id=\"CQ的使用\"><a href=\"#CQ的使用\" class=\"headerlink\" title=\"CQ的使用\"></a>CQ的使用</h2><p>这一章介绍一些使用CQ的模式和准则，以防止开发者错误的使用CQ。</p>\n<h3 id=\"等待条件\"><a href=\"#等待条件\" class=\"headerlink\" title=\"等待条件\"></a>等待条件</h3><p>CQ往往是在等待某个条件成立，为了正确使用CQ，应当用文档(注释)记录与CQ相关的条件，以及会影响这些条件(使条件成立)的操作。<br>CQ和等待条件与锁紧密相关，在执行wait()时必须持有相关的锁，而这个锁往往是用来保护等待条件中的变量的。</p>\n<h3 id=\"CQ被反复唤醒\"><a href=\"#CQ被反复唤醒\" class=\"headerlink\" title=\"CQ被反复唤醒\"></a>CQ被反复唤醒</h3><p>与一个CQ关联的等待条件可能有多个，所以CQ被唤醒(并重新活得锁)不意味着等待条件一定成立。等待CQ的经典写法如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stateDependentMethod</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// condition predicate must be guarded by lock</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!conditionPredicate())</span><br><span class=\"line\">            lock.wait();</span><br><span class=\"line\">        <span class=\"comment\">// object is now in desired state</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编写等待CQ的代码注意如下条件:</p>\n<ul>\n<li>一定要拥有一个等待条件。</li>\n<li>CQ每次被唤醒时需要检查等待条件。</li>\n<li>将等待操作和条件检查置于循环中。</li>\n<li>确保保护等待条件的锁和CQ关联的锁是同一个。</li>\n<li>在调用CQ相关API时必须持有CQ关联的锁。</li>\n</ul>\n<h3 id=\"唤醒CQ\"><a href=\"#唤醒CQ\" class=\"headerlink\" title=\"唤醒CQ\"></a>唤醒CQ</h3><p>当某个操作会让CQ的一个等待条件变为成立时，记得在操作的同时唤醒CQ。(在开发中，这件事情似乎很容易发生疏漏)<br>notify()会选择唤醒一个等待线程；notifyAll会唤醒全部的等待线程。<br>使用notify()时容易出错，例如当CQ关联多个等待条件时，条件A发出的提醒可能唤醒等待条件B的线程，而等待条件A的线程会错过这次提醒。所以使用notify()而不是notifyAll()时要格外谨慎，以下是使用notify()的准则：</p>\n<ul>\n<li>CQ仅仅关联一个等待条件，并且等待线程都执行相同的操作。</li>\n<li>每次提醒能且仅能满足一个等待线程完成操作。</li>\n</ul>\n<h3 id=\"继承和CQ-封装和CQ\"><a href=\"#继承和CQ-封装和CQ\" class=\"headerlink\" title=\"继承和CQ/封装和CQ\"></a>继承和CQ/封装和CQ</h3><p>当继承发生在使用CQ的类上时有两种选择：父类将等待策略(等待条件、提醒策略)和相关对象(CQ对象、锁对象、状态对象)完整的暴露给子类，并提供足够的文档(注释)；或者可以选择，禁止继承/对子类隐藏所有和相关对象(CQ对象、锁对象、状态对象)。</p>\n<p>和继承同理，使用CQ的类应该将CQ相关对象封装在类内部，以防止类的使用者干扰等待策略。</p>\n<h2 id=\"显式的CQ对象\"><a href=\"#显式的CQ对象\" class=\"headerlink\" title=\"显式的CQ对象\"></a>显式的CQ对象</h2><p>内置CQ的一个缺陷是一个内置锁只能关联一个内置CQ，这样导致了一个CQ关联多个等待条件的情况十分常见，也就难以满足使用notify()的条件。<br>显式CQ被称为Condition，它与一个显式锁Lock相关联；Condition可以通过Lock.newCondition()方法创建，一个Lock可以关联多个Condition；Condition的公平性与其关联锁的公平性一致(公平锁创建的Condition也是公平的)。</p>\n<p><strong>注意：不要误用Condition对象自身的内置CQ。</strong></p>\n<p>这一节还给出了一个用显式CQ实现的BlockingQueue的例子，可以发现当有等待条件时Condition比内置CQ有更好的可读性，切更容易使用单一提醒来提升效率。</p>\n<h2 id=\"AQS-AbstractQueuedSynchronizer\"><a href=\"#AQS-AbstractQueuedSynchronizer\" class=\"headerlink\" title=\"AQS(AbstractQueuedSynchronizer)\"></a>AQS(AbstractQueuedSynchronizer)</h2><p>AQS是大多同步工具类的基础组件，通过继承AQS来实现同步工具。<br>在AQS内部存在一个整数变了，用于表示同步工具的状态；AQS提供了一组方法，包括原子读写状态、原子CAS状态用于修改状态，线程独占或线程共享的Acquire/Release方法用于提供安全方法；开发者需要继承tryAcquire/tryAcquireShared和tryRelease/tryReleaseShared来决定同步工具的具体行为。</p>\n<p>本章没有展开介绍AQS的使用细节，如果想深入了解的话，参考<code>java.util.concurrent</code>包中同步工具类的实现。</p>\n<h2 id=\"在Java标准库中的AQS\"><a href=\"#在Java标准库中的AQS\" class=\"headerlink\" title=\"在Java标准库中的AQS\"></a>在Java标准库中的AQS</h2><p>本章介绍了一些<code>java.util.concurrent</code>中类的实现，这些类是基于AQS的。</p>\n"},{"title":"原子变量与非阻塞同步","subtitle":"JCIP读书笔记第十五章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-09-21T10:44:18.000Z","_content":"\n\n## Caution\n\n* Float.floatToIntBits()/Double.doubleToLongBits()。\n* AtomicFieldUpdater。\n\n## 前言\n\n`java.util.concurrent`中的一些线程安全类/同步工具类声称自己有更好的性能和伸缩性，这一章将介绍这种性能提升的基础——非阻塞同步。\n\n**非阻塞同步算法的特点**\n非阻塞同步基于硬件提供的一些原子指令(例如CAS)；非阻塞同步算法在操作系统、JVM这种高端大气的项目中很常见；非阻塞同步算法往往很难设计。\n\n**非阻塞同步算法的好处**\n没有锁，没有阻塞，大幅减少性能消耗；对死锁以及很多活跃性问题天然免疫。\n\n## 锁的缺陷\n\n**用锁同步可能会加重负载**。当获取锁失败后，线程会被挂起并在之后再恢复，当竞争严重时会反复的挂起与恢复，这中间涉及到了大量的中断和与性能消耗。对容器加锁时这种状况很容易出现。\n**线程在等待锁时无法进行任何事**。同时因为等待锁的原因，线程的优先级也无法得到保证：高优先级的线程会因为低优先级的线程长时间持有锁而被挂起。\n**volatile不提供原子性**。volatile变量没有过高的性能消耗，但是它不能保证原子性，例如`++i`对于`volatile i`就不是原子操作。\n\n## 非阻塞同步的硬件支持  \n\n如果说互斥锁是一种“悲观的”的技术：确保独占内存之后再去读写内存；那么非阻塞相关的指令就是“乐观的”技术：先去尝试修改内存，发生冲突再退回重试。\n现代处理器提供了一些原子指令，例如CAS、load-linked/store-conditional，帮助实现非阻塞同步。\n\n### CAS\n\n就是CAS。\n\n### 一个非阻塞计数器\n\n这一节用仿造的CAS操作实现了一个非阻塞的递增计数器，并强调虽然写法复杂其实际性能比加锁递增好很多。当然在实际应用中无需这样写，使用Atomic变量就行了。\nCAS的劣势是要求开发者自己处理冲突(重试、等待还是放弃)；实际上CAS最大的缺点是很难正确编写。\n\n## 原子变量 \n\n原子变量为开发者提供了非阻塞同步的基本工具，基于CAS的原理，原子变量提供了更好的性能，在无竞争情况下原子变量不差于加锁，在中等竞争时原子变量明显优于加锁。\n\n由于Atomic变量只提供了AtomicInteger、AtomicLong、AtomicBoolean，如果要使用浮点型的原子变量需要借助floatToIntBits()／floatToIntBits()等方法。\n\n### 原子变量是更好的volatile\n\n因为原子变量提供了很多原子性接口，基于之前状态的符合操作(例如++i)，在使用原子变量时其原子性才能实现；仅仅使用volatile而不加锁无法实现原子性的复合操作。\n\n### 锁和原子变量的性能对比\n\n结论：在低竞争和中等竞争的情况下，原子变量的性能远好于锁；在竞争极高的情况下锁的戏能，锁的性能会优于原子变量。在高竞争情况下，锁的挂起线程机制会比使用CAS的CPU自旋机制性能更好。\n\n## 非阻塞算法\n\n非阻塞同步不会造成诸如死锁的活跃性问题，也不会造成线程优先级反转...文章开头说过了。\n非阻塞同步算法常见于各种数据结构中，这一章介绍了一些非阻塞同步的例子。\n\n### 非阻塞栈\n\n```java\n@ThreadSafe\npublic class ConcurrentStack <E> {\n  AtomicReference<Node<E>> top = new AtomicReference<Node<E>>();\n   \n  public void push(E item) {\n    Node<E> newHead = new Node<E>(item); Node<E> oldHead;\n    do {\n      oldHead = top.get();\n      newHead.next = oldHead;\n    } while (!top.compareAndSet(oldHead, newHead));\n  }\n    \n  public E pop() {\n    Node<E> oldHead;\n    Node<E> newHead;\n    do {\n      oldHead = top.get(); if (oldHead == null) return null;\n      newHead = oldHead.next;\n    } while (!top.compareAndSet(oldHead, newHead)); return oldHead.item;\n  }\n\n  private static class Node <E> { \n    public final E item;\n    public Node<E> next;\n    public Node(E item) {\n      this.item = item;\n    } \n  }\n} \n```\n\n### 非阻塞链表\n\n果然很难写，充满了trick，关键需要理清需一次操作要更新哪些Atomic变量，并保持对多个Atomic更新的一致性。如果下面算法看不懂，可以回去阅读原文的解释。\n\n```java\n@ThreadSafe\npublic class LinkedQueue <E> {\n    private static class Node <E> { \n        final E item;\n        final AtomicReference<Node<E>> next;\n        public Node(E item, Node<E> next) {\n            this.item = item;\n            this.next = new AtomicReference<Node<E>>(next);\n        }\n    }\n\n    private final Node<E> dummy = new Node<E>(null, null); \n    private final AtomicReference<Node<E>> head = new AtomicReference<Node<E>>(dummy);\n    private final AtomicReference<Node<E>> tail = new AtomicReference<Node<E>>(dummy);\n\n    public boolean put(E item) {\n        Node<E> newNode = new Node<E>(item, null); \n        while (true) {\n            Node<E> curTail = tail.get();\n            Node<E> tailNext = curTail.next.get(); \n            if (curTail == tail.get()) {\n                if (tailNext != null) {  \n                    // Queue in intermediate state, advance tail \n                    tail.compareAndSet(curTail, tailNext); \n                } else {\n                    // In quiescent state, try inserting new node\n                    if (curTail.next.compareAndSet(null, newNode)) {\n                        // Insertion succeeded, try advancing tail\n                        tail.compareAndSet(curTail, newNode);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Atomic field updater\n\nAtomicFieldUpdater作为一个“Helper类”，可以为一般的volatile变量提供CAS操作。\n与上一节的实现不同，在Java库中的非阻塞链表的实现里，Node类的next字段是一个volatile引用，并使用AtomicFieldUpdater更新；因为Node类对象会频繁的创建和销毁，这样做可以避免创建Atomic对象的消耗。\n\n### ABA错误\n\n在CAS类操作中出现的ABA错误可以描述如下：从变量中取出值位A -> 变量值从A变为B又变回A -> 通过CAS并没有发现变量经历的变化。在一些情况下只要变量值保持不变，就可以认为变量没有发生变化；但在另一些情况下，需要观察到这个变化。\n比如说，想象一下在使用对象池的时候，对象地址虽然没变但可能在逻辑上已经是一个新的对象了。\n通常解决方案就是在对象引用里加入一个tag，以标记引用是否经历过改变，`AtomicStampedReference`就提供了这个功能。","source":"_posts/JCIP-chapter15-atomic-variable-and-nonblocking-synchronization.md","raw":"---\ntitle: 原子变量与非阻塞同步\nsubtitle: JCIP读书笔记第十五章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-09-21 18:44:18\n---\n\n\n## Caution\n\n* Float.floatToIntBits()/Double.doubleToLongBits()。\n* AtomicFieldUpdater。\n\n## 前言\n\n`java.util.concurrent`中的一些线程安全类/同步工具类声称自己有更好的性能和伸缩性，这一章将介绍这种性能提升的基础——非阻塞同步。\n\n**非阻塞同步算法的特点**\n非阻塞同步基于硬件提供的一些原子指令(例如CAS)；非阻塞同步算法在操作系统、JVM这种高端大气的项目中很常见；非阻塞同步算法往往很难设计。\n\n**非阻塞同步算法的好处**\n没有锁，没有阻塞，大幅减少性能消耗；对死锁以及很多活跃性问题天然免疫。\n\n## 锁的缺陷\n\n**用锁同步可能会加重负载**。当获取锁失败后，线程会被挂起并在之后再恢复，当竞争严重时会反复的挂起与恢复，这中间涉及到了大量的中断和与性能消耗。对容器加锁时这种状况很容易出现。\n**线程在等待锁时无法进行任何事**。同时因为等待锁的原因，线程的优先级也无法得到保证：高优先级的线程会因为低优先级的线程长时间持有锁而被挂起。\n**volatile不提供原子性**。volatile变量没有过高的性能消耗，但是它不能保证原子性，例如`++i`对于`volatile i`就不是原子操作。\n\n## 非阻塞同步的硬件支持  \n\n如果说互斥锁是一种“悲观的”的技术：确保独占内存之后再去读写内存；那么非阻塞相关的指令就是“乐观的”技术：先去尝试修改内存，发生冲突再退回重试。\n现代处理器提供了一些原子指令，例如CAS、load-linked/store-conditional，帮助实现非阻塞同步。\n\n### CAS\n\n就是CAS。\n\n### 一个非阻塞计数器\n\n这一节用仿造的CAS操作实现了一个非阻塞的递增计数器，并强调虽然写法复杂其实际性能比加锁递增好很多。当然在实际应用中无需这样写，使用Atomic变量就行了。\nCAS的劣势是要求开发者自己处理冲突(重试、等待还是放弃)；实际上CAS最大的缺点是很难正确编写。\n\n## 原子变量 \n\n原子变量为开发者提供了非阻塞同步的基本工具，基于CAS的原理，原子变量提供了更好的性能，在无竞争情况下原子变量不差于加锁，在中等竞争时原子变量明显优于加锁。\n\n由于Atomic变量只提供了AtomicInteger、AtomicLong、AtomicBoolean，如果要使用浮点型的原子变量需要借助floatToIntBits()／floatToIntBits()等方法。\n\n### 原子变量是更好的volatile\n\n因为原子变量提供了很多原子性接口，基于之前状态的符合操作(例如++i)，在使用原子变量时其原子性才能实现；仅仅使用volatile而不加锁无法实现原子性的复合操作。\n\n### 锁和原子变量的性能对比\n\n结论：在低竞争和中等竞争的情况下，原子变量的性能远好于锁；在竞争极高的情况下锁的戏能，锁的性能会优于原子变量。在高竞争情况下，锁的挂起线程机制会比使用CAS的CPU自旋机制性能更好。\n\n## 非阻塞算法\n\n非阻塞同步不会造成诸如死锁的活跃性问题，也不会造成线程优先级反转...文章开头说过了。\n非阻塞同步算法常见于各种数据结构中，这一章介绍了一些非阻塞同步的例子。\n\n### 非阻塞栈\n\n```java\n@ThreadSafe\npublic class ConcurrentStack <E> {\n  AtomicReference<Node<E>> top = new AtomicReference<Node<E>>();\n   \n  public void push(E item) {\n    Node<E> newHead = new Node<E>(item); Node<E> oldHead;\n    do {\n      oldHead = top.get();\n      newHead.next = oldHead;\n    } while (!top.compareAndSet(oldHead, newHead));\n  }\n    \n  public E pop() {\n    Node<E> oldHead;\n    Node<E> newHead;\n    do {\n      oldHead = top.get(); if (oldHead == null) return null;\n      newHead = oldHead.next;\n    } while (!top.compareAndSet(oldHead, newHead)); return oldHead.item;\n  }\n\n  private static class Node <E> { \n    public final E item;\n    public Node<E> next;\n    public Node(E item) {\n      this.item = item;\n    } \n  }\n} \n```\n\n### 非阻塞链表\n\n果然很难写，充满了trick，关键需要理清需一次操作要更新哪些Atomic变量，并保持对多个Atomic更新的一致性。如果下面算法看不懂，可以回去阅读原文的解释。\n\n```java\n@ThreadSafe\npublic class LinkedQueue <E> {\n    private static class Node <E> { \n        final E item;\n        final AtomicReference<Node<E>> next;\n        public Node(E item, Node<E> next) {\n            this.item = item;\n            this.next = new AtomicReference<Node<E>>(next);\n        }\n    }\n\n    private final Node<E> dummy = new Node<E>(null, null); \n    private final AtomicReference<Node<E>> head = new AtomicReference<Node<E>>(dummy);\n    private final AtomicReference<Node<E>> tail = new AtomicReference<Node<E>>(dummy);\n\n    public boolean put(E item) {\n        Node<E> newNode = new Node<E>(item, null); \n        while (true) {\n            Node<E> curTail = tail.get();\n            Node<E> tailNext = curTail.next.get(); \n            if (curTail == tail.get()) {\n                if (tailNext != null) {  \n                    // Queue in intermediate state, advance tail \n                    tail.compareAndSet(curTail, tailNext); \n                } else {\n                    // In quiescent state, try inserting new node\n                    if (curTail.next.compareAndSet(null, newNode)) {\n                        // Insertion succeeded, try advancing tail\n                        tail.compareAndSet(curTail, newNode);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Atomic field updater\n\nAtomicFieldUpdater作为一个“Helper类”，可以为一般的volatile变量提供CAS操作。\n与上一节的实现不同，在Java库中的非阻塞链表的实现里，Node类的next字段是一个volatile引用，并使用AtomicFieldUpdater更新；因为Node类对象会频繁的创建和销毁，这样做可以避免创建Atomic对象的消耗。\n\n### ABA错误\n\n在CAS类操作中出现的ABA错误可以描述如下：从变量中取出值位A -> 变量值从A变为B又变回A -> 通过CAS并没有发现变量经历的变化。在一些情况下只要变量值保持不变，就可以认为变量没有发生变化；但在另一些情况下，需要观察到这个变化。\n比如说，想象一下在使用对象池的时候，对象地址虽然没变但可能在逻辑上已经是一个新的对象了。\n通常解决方案就是在对象引用里加入一个tag，以标记引用是否经历过改变，`AtomicStampedReference`就提供了这个功能。","slug":"JCIP-chapter15-atomic-variable-and-nonblocking-synchronization","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4oy000g3mrfgrac3axr","content":"<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>Float.floatToIntBits()/Double.doubleToLongBits()。</li>\n<li>AtomicFieldUpdater。</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>java.util.concurrent</code>中的一些线程安全类/同步工具类声称自己有更好的性能和伸缩性，这一章将介绍这种性能提升的基础——非阻塞同步。</p>\n<p><strong>非阻塞同步算法的特点</strong><br>非阻塞同步基于硬件提供的一些原子指令(例如CAS)；非阻塞同步算法在操作系统、JVM这种高端大气的项目中很常见；非阻塞同步算法往往很难设计。</p>\n<p><strong>非阻塞同步算法的好处</strong><br>没有锁，没有阻塞，大幅减少性能消耗；对死锁以及很多活跃性问题天然免疫。</p>\n<h2 id=\"锁的缺陷\"><a href=\"#锁的缺陷\" class=\"headerlink\" title=\"锁的缺陷\"></a>锁的缺陷</h2><p><strong>用锁同步可能会加重负载</strong>。当获取锁失败后，线程会被挂起并在之后再恢复，当竞争严重时会反复的挂起与恢复，这中间涉及到了大量的中断和与性能消耗。对容器加锁时这种状况很容易出现。<br><strong>线程在等待锁时无法进行任何事</strong>。同时因为等待锁的原因，线程的优先级也无法得到保证：高优先级的线程会因为低优先级的线程长时间持有锁而被挂起。<br><strong>volatile不提供原子性</strong>。volatile变量没有过高的性能消耗，但是它不能保证原子性，例如<code>++i</code>对于<code>volatile i</code>就不是原子操作。</p>\n<h2 id=\"非阻塞同步的硬件支持\"><a href=\"#非阻塞同步的硬件支持\" class=\"headerlink\" title=\"非阻塞同步的硬件支持\"></a>非阻塞同步的硬件支持</h2><p>如果说互斥锁是一种“悲观的”的技术：确保独占内存之后再去读写内存；那么非阻塞相关的指令就是“乐观的”技术：先去尝试修改内存，发生冲突再退回重试。<br>现代处理器提供了一些原子指令，例如CAS、load-linked/store-conditional，帮助实现非阻塞同步。</p>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>就是CAS。</p>\n<h3 id=\"一个非阻塞计数器\"><a href=\"#一个非阻塞计数器\" class=\"headerlink\" title=\"一个非阻塞计数器\"></a>一个非阻塞计数器</h3><p>这一节用仿造的CAS操作实现了一个非阻塞的递增计数器，并强调虽然写法复杂其实际性能比加锁递增好很多。当然在实际应用中无需这样写，使用Atomic变量就行了。<br>CAS的劣势是要求开发者自己处理冲突(重试、等待还是放弃)；实际上CAS最大的缺点是很难正确编写。</p>\n<h2 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h2><p>原子变量为开发者提供了非阻塞同步的基本工具，基于CAS的原理，原子变量提供了更好的性能，在无竞争情况下原子变量不差于加锁，在中等竞争时原子变量明显优于加锁。</p>\n<p>由于Atomic变量只提供了AtomicInteger、AtomicLong、AtomicBoolean，如果要使用浮点型的原子变量需要借助floatToIntBits()／floatToIntBits()等方法。</p>\n<h3 id=\"原子变量是更好的volatile\"><a href=\"#原子变量是更好的volatile\" class=\"headerlink\" title=\"原子变量是更好的volatile\"></a>原子变量是更好的volatile</h3><p>因为原子变量提供了很多原子性接口，基于之前状态的符合操作(例如++i)，在使用原子变量时其原子性才能实现；仅仅使用volatile而不加锁无法实现原子性的复合操作。</p>\n<h3 id=\"锁和原子变量的性能对比\"><a href=\"#锁和原子变量的性能对比\" class=\"headerlink\" title=\"锁和原子变量的性能对比\"></a>锁和原子变量的性能对比</h3><p>结论：在低竞争和中等竞争的情况下，原子变量的性能远好于锁；在竞争极高的情况下锁的戏能，锁的性能会优于原子变量。在高竞争情况下，锁的挂起线程机制会比使用CAS的CPU自旋机制性能更好。</p>\n<h2 id=\"非阻塞算法\"><a href=\"#非阻塞算法\" class=\"headerlink\" title=\"非阻塞算法\"></a>非阻塞算法</h2><p>非阻塞同步不会造成诸如死锁的活跃性问题，也不会造成线程优先级反转…文章开头说过了。<br>非阻塞同步算法常见于各种数据结构中，这一章介绍了一些非阻塞同步的例子。</p>\n<h3 id=\"非阻塞栈\"><a href=\"#非阻塞栈\" class=\"headerlink\" title=\"非阻塞栈\"></a>非阻塞栈</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ThreadSafe</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentStack</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;();</span><br><span class=\"line\">   </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(E item)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;E&gt; newHead = <span class=\"keyword\">new</span> Node&lt;E&gt;(item); Node&lt;E&gt; oldHead;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      oldHead = top.get();</span><br><span class=\"line\">      newHead.next = oldHead;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!top.compareAndSet(oldHead, newHead));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;E&gt; oldHead;</span><br><span class=\"line\">    Node&lt;E&gt; newHead;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      oldHead = top.get(); <span class=\"keyword\">if</span> (oldHead == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      newHead = oldHead.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!top.compareAndSet(oldHead, newHead)); <span class=\"keyword\">return</span> oldHead.item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> E item;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node&lt;E&gt; next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(E item)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.item = item;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h3 id=\"非阻塞链表\"><a href=\"#非阻塞链表\" class=\"headerlink\" title=\"非阻塞链表\"></a>非阻塞链表</h3><p>果然很难写，充满了trick，关键需要理清需一次操作要更新哪些Atomic变量，并保持对多个Atomic更新的一致性。如果下面算法看不懂，可以回去阅读原文的解释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ThreadSafe</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedQueue</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">final</span> E item;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; next;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(E item, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = item;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;E&gt; dummy = <span class=\"keyword\">new</span> Node&lt;E&gt;(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>); </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; head = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;(dummy);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; tail = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;(dummy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">put</span><span class=\"params\">(E item)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;E&gt;(item, <span class=\"keyword\">null</span>); </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; curTail = tail.get();</span><br><span class=\"line\">            Node&lt;E&gt; tailNext = curTail.next.get(); </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curTail == tail.get()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tailNext != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    <span class=\"comment\">// Queue in intermediate state, advance tail </span></span><br><span class=\"line\">                    tail.compareAndSet(curTail, tailNext); </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// In quiescent state, try inserting new node</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (curTail.next.compareAndSet(<span class=\"keyword\">null</span>, newNode)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Insertion succeeded, try advancing tail</span></span><br><span class=\"line\">                        tail.compareAndSet(curTail, newNode);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Atomic-field-updater\"><a href=\"#Atomic-field-updater\" class=\"headerlink\" title=\"Atomic field updater\"></a>Atomic field updater</h3><p>AtomicFieldUpdater作为一个“Helper类”，可以为一般的volatile变量提供CAS操作。<br>与上一节的实现不同，在Java库中的非阻塞链表的实现里，Node类的next字段是一个volatile引用，并使用AtomicFieldUpdater更新；因为Node类对象会频繁的创建和销毁，这样做可以避免创建Atomic对象的消耗。</p>\n<h3 id=\"ABA错误\"><a href=\"#ABA错误\" class=\"headerlink\" title=\"ABA错误\"></a>ABA错误</h3><p>在CAS类操作中出现的ABA错误可以描述如下：从变量中取出值位A -&gt; 变量值从A变为B又变回A -&gt; 通过CAS并没有发现变量经历的变化。在一些情况下只要变量值保持不变，就可以认为变量没有发生变化；但在另一些情况下，需要观察到这个变化。<br>比如说，想象一下在使用对象池的时候，对象地址虽然没变但可能在逻辑上已经是一个新的对象了。<br>通常解决方案就是在对象引用里加入一个tag，以标记引用是否经历过改变，<code>AtomicStampedReference</code>就提供了这个功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>Float.floatToIntBits()/Double.doubleToLongBits()。</li>\n<li>AtomicFieldUpdater。</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>java.util.concurrent</code>中的一些线程安全类/同步工具类声称自己有更好的性能和伸缩性，这一章将介绍这种性能提升的基础——非阻塞同步。</p>\n<p><strong>非阻塞同步算法的特点</strong><br>非阻塞同步基于硬件提供的一些原子指令(例如CAS)；非阻塞同步算法在操作系统、JVM这种高端大气的项目中很常见；非阻塞同步算法往往很难设计。</p>\n<p><strong>非阻塞同步算法的好处</strong><br>没有锁，没有阻塞，大幅减少性能消耗；对死锁以及很多活跃性问题天然免疫。</p>\n<h2 id=\"锁的缺陷\"><a href=\"#锁的缺陷\" class=\"headerlink\" title=\"锁的缺陷\"></a>锁的缺陷</h2><p><strong>用锁同步可能会加重负载</strong>。当获取锁失败后，线程会被挂起并在之后再恢复，当竞争严重时会反复的挂起与恢复，这中间涉及到了大量的中断和与性能消耗。对容器加锁时这种状况很容易出现。<br><strong>线程在等待锁时无法进行任何事</strong>。同时因为等待锁的原因，线程的优先级也无法得到保证：高优先级的线程会因为低优先级的线程长时间持有锁而被挂起。<br><strong>volatile不提供原子性</strong>。volatile变量没有过高的性能消耗，但是它不能保证原子性，例如<code>++i</code>对于<code>volatile i</code>就不是原子操作。</p>\n<h2 id=\"非阻塞同步的硬件支持\"><a href=\"#非阻塞同步的硬件支持\" class=\"headerlink\" title=\"非阻塞同步的硬件支持\"></a>非阻塞同步的硬件支持</h2><p>如果说互斥锁是一种“悲观的”的技术：确保独占内存之后再去读写内存；那么非阻塞相关的指令就是“乐观的”技术：先去尝试修改内存，发生冲突再退回重试。<br>现代处理器提供了一些原子指令，例如CAS、load-linked/store-conditional，帮助实现非阻塞同步。</p>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>就是CAS。</p>\n<h3 id=\"一个非阻塞计数器\"><a href=\"#一个非阻塞计数器\" class=\"headerlink\" title=\"一个非阻塞计数器\"></a>一个非阻塞计数器</h3><p>这一节用仿造的CAS操作实现了一个非阻塞的递增计数器，并强调虽然写法复杂其实际性能比加锁递增好很多。当然在实际应用中无需这样写，使用Atomic变量就行了。<br>CAS的劣势是要求开发者自己处理冲突(重试、等待还是放弃)；实际上CAS最大的缺点是很难正确编写。</p>\n<h2 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h2><p>原子变量为开发者提供了非阻塞同步的基本工具，基于CAS的原理，原子变量提供了更好的性能，在无竞争情况下原子变量不差于加锁，在中等竞争时原子变量明显优于加锁。</p>\n<p>由于Atomic变量只提供了AtomicInteger、AtomicLong、AtomicBoolean，如果要使用浮点型的原子变量需要借助floatToIntBits()／floatToIntBits()等方法。</p>\n<h3 id=\"原子变量是更好的volatile\"><a href=\"#原子变量是更好的volatile\" class=\"headerlink\" title=\"原子变量是更好的volatile\"></a>原子变量是更好的volatile</h3><p>因为原子变量提供了很多原子性接口，基于之前状态的符合操作(例如++i)，在使用原子变量时其原子性才能实现；仅仅使用volatile而不加锁无法实现原子性的复合操作。</p>\n<h3 id=\"锁和原子变量的性能对比\"><a href=\"#锁和原子变量的性能对比\" class=\"headerlink\" title=\"锁和原子变量的性能对比\"></a>锁和原子变量的性能对比</h3><p>结论：在低竞争和中等竞争的情况下，原子变量的性能远好于锁；在竞争极高的情况下锁的戏能，锁的性能会优于原子变量。在高竞争情况下，锁的挂起线程机制会比使用CAS的CPU自旋机制性能更好。</p>\n<h2 id=\"非阻塞算法\"><a href=\"#非阻塞算法\" class=\"headerlink\" title=\"非阻塞算法\"></a>非阻塞算法</h2><p>非阻塞同步不会造成诸如死锁的活跃性问题，也不会造成线程优先级反转…文章开头说过了。<br>非阻塞同步算法常见于各种数据结构中，这一章介绍了一些非阻塞同步的例子。</p>\n<h3 id=\"非阻塞栈\"><a href=\"#非阻塞栈\" class=\"headerlink\" title=\"非阻塞栈\"></a>非阻塞栈</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ThreadSafe</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentStack</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;();</span><br><span class=\"line\">   </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(E item)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;E&gt; newHead = <span class=\"keyword\">new</span> Node&lt;E&gt;(item); Node&lt;E&gt; oldHead;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      oldHead = top.get();</span><br><span class=\"line\">      newHead.next = oldHead;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!top.compareAndSet(oldHead, newHead));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;E&gt; oldHead;</span><br><span class=\"line\">    Node&lt;E&gt; newHead;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      oldHead = top.get(); <span class=\"keyword\">if</span> (oldHead == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      newHead = oldHead.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!top.compareAndSet(oldHead, newHead)); <span class=\"keyword\">return</span> oldHead.item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> E item;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node&lt;E&gt; next;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(E item)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.item = item;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h3 id=\"非阻塞链表\"><a href=\"#非阻塞链表\" class=\"headerlink\" title=\"非阻塞链表\"></a>非阻塞链表</h3><p>果然很难写，充满了trick，关键需要理清需一次操作要更新哪些Atomic变量，并保持对多个Atomic更新的一致性。如果下面算法看不懂，可以回去阅读原文的解释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ThreadSafe</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedQueue</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> &lt;<span class=\"title\">E</span>&gt; </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">final</span> E item;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; next;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(E item, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = item;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;E&gt; dummy = <span class=\"keyword\">new</span> Node&lt;E&gt;(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>); </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; head = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;(dummy);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; tail = <span class=\"keyword\">new</span> AtomicReference&lt;Node&lt;E&gt;&gt;(dummy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">put</span><span class=\"params\">(E item)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;E&gt;(item, <span class=\"keyword\">null</span>); </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; curTail = tail.get();</span><br><span class=\"line\">            Node&lt;E&gt; tailNext = curTail.next.get(); </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curTail == tail.get()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tailNext != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    <span class=\"comment\">// Queue in intermediate state, advance tail </span></span><br><span class=\"line\">                    tail.compareAndSet(curTail, tailNext); </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// In quiescent state, try inserting new node</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (curTail.next.compareAndSet(<span class=\"keyword\">null</span>, newNode)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Insertion succeeded, try advancing tail</span></span><br><span class=\"line\">                        tail.compareAndSet(curTail, newNode);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Atomic-field-updater\"><a href=\"#Atomic-field-updater\" class=\"headerlink\" title=\"Atomic field updater\"></a>Atomic field updater</h3><p>AtomicFieldUpdater作为一个“Helper类”，可以为一般的volatile变量提供CAS操作。<br>与上一节的实现不同，在Java库中的非阻塞链表的实现里，Node类的next字段是一个volatile引用，并使用AtomicFieldUpdater更新；因为Node类对象会频繁的创建和销毁，这样做可以避免创建Atomic对象的消耗。</p>\n<h3 id=\"ABA错误\"><a href=\"#ABA错误\" class=\"headerlink\" title=\"ABA错误\"></a>ABA错误</h3><p>在CAS类操作中出现的ABA错误可以描述如下：从变量中取出值位A -&gt; 变量值从A变为B又变回A -&gt; 通过CAS并没有发现变量经历的变化。在一些情况下只要变量值保持不变，就可以认为变量没有发生变化；但在另一些情况下，需要观察到这个变化。<br>比如说，想象一下在使用对象池的时候，对象地址虽然没变但可能在逻辑上已经是一个新的对象了。<br>通常解决方案就是在对象引用里加入一个tag，以标记引用是否经历过改变，<code>AtomicStampedReference</code>就提供了这个功能。</p>\n"},{"title":"Java内存模型","subtitle":"JCIP读书笔记第十六章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-09-09T07:57:37.000Z","_content":"\n\n## Caution \n\n* 现代系统中，volatile变量读操作和普通变量读操作的代价几乎一样。\n\n整本JCIP都在避免直接讲述Java内存模型，但是线程安全机制是以内存模型为基础的，所以了解一些内存模型的知识有利于明白线程安全规则为何要那样规定。\n\n## Java内存模型概述(JMM)   \n\n### 什么是Java内存模型\n\n为什需要Java内存模型？\n因为现代CPU的复杂优化，导致仅仅在单一线程上保证变量(抽象内存位置)的可见性；并且仅仅在单一线程上，指令的执行是可以等效成顺序执行(指令重排)的。\n\nJava内存模型规定了什么？\nJava内存模型规定了JVM的行为，描述JVM在什么情况下必须保证变量的修改对其他线程是可见的。\n\n### 平台的内存模型   \n\n平台(或者说cpu)会提供自己内存模型以及控制可见性特殊指令(例如memory barrier)。JVM会代理不同平台的内存模型，并抽象为统一的Java内存模型；各个平台的控制指令，也被抽象成了Java的同步机制。\n\n### 指令重排   \n\n众所周知，指令会重排；加上从缓存写会内存的时机不确定，跨线程分析变量的值可谓举步维艰(没有同步)。\n\n### 所以Java内存模型是怎么说的\n\nJava内存模型通过一种偏序关系来描述内存可见性规则，在这个规则中定义一种关系叫happens-before，如果语句A(或者说指令，在JMM规则里叫action)对于语句B是happens-before的关系，那么语句A对变量的修改对于语句B是可见的。\n\n下面用一些规则什么情况下两条语句(指令，whatever)具有happens-before关系：   \n\n* Program order rule。在同一线程上，所有语句按照代码顺序具有自然的happens-before关系；即同一线程上，直观上先执行的代码happens-before直观上后执行的代码。\n* Monitor lock rule。对一个锁的释放操作happens-before对**同一个锁**的获取操作。注意两点，一定要求是同一个锁对象；规则同时适用于显式锁和内置锁。\n* Volatile variable rule。对volatile属性的写操作happens-before对**同一个volatile属性**的读操作。注意两点，一定要求是同一个volatile属性；这条规则同时atomic变量。\n* Thread start rule。启动线程操作happens-before被启动线程上的所有语句。\n* Thread termination rule。一个线程上的所有语句happens-before发现这个线程结束的语句(发现线程结束的语句例如Thread.join()返回或者Thread.isAlive()返回false)。\n* Interruption rule。线程A调用线程B的interrupt()happens-before线程B发现发现interrupt(例如调用isInterrupted)。\n* Finalizer rule。对象构造函数的结束happens-before对象finalizer的开始。\n* Transitivity。如果A事件happens-before B事件，且B事件happens-before C事件，那么A事件happens-before C事件。\n\n也许Java内存模型的规则会让第一次看的人觉得晦涩，事实上整个规则就是以单线程的顺序可见性为基础，通过一些保证顺序可见行的关键操作(例如线程的开始结束，锁的获取和释放，volatile变量的读写)加上传递性，来维持多线程代码的偏序关系。进而通过这个偏序关系来描述可见性规则，即偏序关系在前的操作对偏序关系在后的操作可见。\n\n### piggybacking on JMM(Trick的利用Java内存模型)\n\n借助Java内存模型规则，可以利用微妙的happens-before传递来确保可见性，这种可见性保证不易发现并且需要推理，本书将这种现象叫piggybacking同步。\n\n作者以FutureTask的实现为例(在最新的jdk中这个实现已经改变)，展示了piggybacking同步。简单来说可以表述为：\n\n> `Thread A :`\n>      `变量 X 的写操作`\n>      `synchronized (变量 Y)` \n>          `操作变量 Y`\n>          \n> `Thread B :`\n>     `synchronized (变量 Y)`\n>         `操作变量 Y`\n>     `变量 X 的读操作`   \n\n变量X在A线程上的读操作对B线程是可见的，尽管并没有针对X作任何同步，但是通过happens-before规则来保证了可见性。\npiggybacking同步有时很显而易见(例如通过同步队列传递对象)，有时却很晦涩(例如上面的例子)。**piggybacking同步要求操作微妙的顺序，因此非常的脆弱易出错，除非非常追求性能否则不要使用**。\n\n## 安全发布与安全构造\n\n第三章讨论过安全发布，这一章借由Java内存模型旧话重提，来看看之前提到安全发布方式/安全构造方式是如何被Java内存模型保证的。顺便批判一下Double-checked实现的单例模式(被称为臭名昭注)，不是真的线程安全。\n\n安全发布和安全构造都与可见性相关，且往往联系紧密，因为一般来说发布将紧随构造之后，但我们还是给这两个术语。安全发布是指，其他线程能够正确变量被修改；安全构造是指，其他线程不会看到未完成构造的对象。\n\n### 不安全的发布 \n\n先将竞态条件放到一边，仅仅讨论可见性。由于指令重排的存在，在其他线程看来，对发布引用的写入操作，可能会先于被发布对象的构造函数中的某些指令，于是导致其他线程读到未完成构造的对象。\n\n必须通过happens-before规则来保证发布对象可见性和完整性(安全构造)；不可变对象是个例外，参见第三章。\n\n### 安全发布\n\nhappens-before规则是第三章中介绍的安全发布规则的基础，但是那些规则比happens-before规则看起来更直观。\n\n### 安全构造的一种方式(单例)\n\nJVM保证了静态初始化的线程安全，被静态代码构造的变量对所有线程都是可见的，但是单纯的静态构造不能满足使用时才初始化的要求(lazy)；单纯的加锁构造 & 加锁访问也许会拖累线程。\n借助class第一次被使用才会被JVM加载的规则，可以实现双赢(lazy、线程安全、不必每次都加锁)也较为优美的安全构造：\n\n>`@ThreadSafe`\n>`public class ResourceFactory {`\n>&emsp;&emsp;`private static class ResourceHolder {`\n>&emsp;&emsp;&emsp;&emsp;`public static Resource resource = new Resource();`\n>&emsp;&emsp;`}`\n>&emsp;&emsp;`public static Resource getResource() {` \n>&emsp;&emsp;&emsp;&emsp;`return ResourceHolder.resource;`\n>&emsp;&emsp;`}` \n>`}`\n\n### (批判)Double-checked单例构造\n\nDouble-checked的单例构造经常出现于各种面试题中，然而它实际上不是线程安全的，也不优美。其线程不安全的原因是，在第一次判没有使用同步，所以没有安全构造的保证，可能返回未完全构造的对象。尽管把对象的引用声明为volatile可以解决这个问题(如果对象是不可变的也不会有问题)，但这个写法远不如static-holder方式(上一节所述)简洁明了。\n\n### Java构造安全规则\n\nJava构造安全规则描述了在对象的构造过程中，什么样的属性的构造过程对其他线程是保证可见的，事实上这个规则在第三章也被提起过。这个规则和final属性息息相关。\n\n当对象被正确构造时(对象没有在构造函数中逸出)，Java构造安全规则保证，其他线程能正确看到这个对象的所有final属性构造结果，并保证能正确看到由这些final属性可达的所有对象的构造结果。\n\n这个规则的一个直观效果：不可变对象(所有属性都是final的)一定会被安全构造。\n\n啊，上面话有点抽象了，换一种说法：JVM保证了在构造函数中所有对final属性可见性(即使没有使用同步)，并且JVM保证对final属性的所有操作不会被重排到构造函数返回之后。\n\n啊，还是觉得很抽象的话，请看原文：\n\n> Initialization safety guarantees that for properly constructed objects, all \n> threads will see the correct values of final fields that were set by  \n> the constructor, regardless of how the object is published. Further, any \n> variables that can be reached through a final field of a properly \n> constructed object (such as the elements of a final array or the contents of \n> a HashMap refer- enced by a final field) are also guaranteed to be visible \n> to other threads.\n\n> Initialization safety makes visibility guarantees only for the values that \n> are reachable through final fields as of the time the constructor finishes. \n> For values reachable through nonfinal fields, or values that may change \n> after construction, you must use synchronization to ensure visibility.\n","source":"_posts/JCIP-chapter16-java-memory-model.md","raw":"---\ntitle: Java内存模型\nsubtitle: JCIP读书笔记第十六章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-09-09 15:57:37\n---\n\n\n## Caution \n\n* 现代系统中，volatile变量读操作和普通变量读操作的代价几乎一样。\n\n整本JCIP都在避免直接讲述Java内存模型，但是线程安全机制是以内存模型为基础的，所以了解一些内存模型的知识有利于明白线程安全规则为何要那样规定。\n\n## Java内存模型概述(JMM)   \n\n### 什么是Java内存模型\n\n为什需要Java内存模型？\n因为现代CPU的复杂优化，导致仅仅在单一线程上保证变量(抽象内存位置)的可见性；并且仅仅在单一线程上，指令的执行是可以等效成顺序执行(指令重排)的。\n\nJava内存模型规定了什么？\nJava内存模型规定了JVM的行为，描述JVM在什么情况下必须保证变量的修改对其他线程是可见的。\n\n### 平台的内存模型   \n\n平台(或者说cpu)会提供自己内存模型以及控制可见性特殊指令(例如memory barrier)。JVM会代理不同平台的内存模型，并抽象为统一的Java内存模型；各个平台的控制指令，也被抽象成了Java的同步机制。\n\n### 指令重排   \n\n众所周知，指令会重排；加上从缓存写会内存的时机不确定，跨线程分析变量的值可谓举步维艰(没有同步)。\n\n### 所以Java内存模型是怎么说的\n\nJava内存模型通过一种偏序关系来描述内存可见性规则，在这个规则中定义一种关系叫happens-before，如果语句A(或者说指令，在JMM规则里叫action)对于语句B是happens-before的关系，那么语句A对变量的修改对于语句B是可见的。\n\n下面用一些规则什么情况下两条语句(指令，whatever)具有happens-before关系：   \n\n* Program order rule。在同一线程上，所有语句按照代码顺序具有自然的happens-before关系；即同一线程上，直观上先执行的代码happens-before直观上后执行的代码。\n* Monitor lock rule。对一个锁的释放操作happens-before对**同一个锁**的获取操作。注意两点，一定要求是同一个锁对象；规则同时适用于显式锁和内置锁。\n* Volatile variable rule。对volatile属性的写操作happens-before对**同一个volatile属性**的读操作。注意两点，一定要求是同一个volatile属性；这条规则同时atomic变量。\n* Thread start rule。启动线程操作happens-before被启动线程上的所有语句。\n* Thread termination rule。一个线程上的所有语句happens-before发现这个线程结束的语句(发现线程结束的语句例如Thread.join()返回或者Thread.isAlive()返回false)。\n* Interruption rule。线程A调用线程B的interrupt()happens-before线程B发现发现interrupt(例如调用isInterrupted)。\n* Finalizer rule。对象构造函数的结束happens-before对象finalizer的开始。\n* Transitivity。如果A事件happens-before B事件，且B事件happens-before C事件，那么A事件happens-before C事件。\n\n也许Java内存模型的规则会让第一次看的人觉得晦涩，事实上整个规则就是以单线程的顺序可见性为基础，通过一些保证顺序可见行的关键操作(例如线程的开始结束，锁的获取和释放，volatile变量的读写)加上传递性，来维持多线程代码的偏序关系。进而通过这个偏序关系来描述可见性规则，即偏序关系在前的操作对偏序关系在后的操作可见。\n\n### piggybacking on JMM(Trick的利用Java内存模型)\n\n借助Java内存模型规则，可以利用微妙的happens-before传递来确保可见性，这种可见性保证不易发现并且需要推理，本书将这种现象叫piggybacking同步。\n\n作者以FutureTask的实现为例(在最新的jdk中这个实现已经改变)，展示了piggybacking同步。简单来说可以表述为：\n\n> `Thread A :`\n>      `变量 X 的写操作`\n>      `synchronized (变量 Y)` \n>          `操作变量 Y`\n>          \n> `Thread B :`\n>     `synchronized (变量 Y)`\n>         `操作变量 Y`\n>     `变量 X 的读操作`   \n\n变量X在A线程上的读操作对B线程是可见的，尽管并没有针对X作任何同步，但是通过happens-before规则来保证了可见性。\npiggybacking同步有时很显而易见(例如通过同步队列传递对象)，有时却很晦涩(例如上面的例子)。**piggybacking同步要求操作微妙的顺序，因此非常的脆弱易出错，除非非常追求性能否则不要使用**。\n\n## 安全发布与安全构造\n\n第三章讨论过安全发布，这一章借由Java内存模型旧话重提，来看看之前提到安全发布方式/安全构造方式是如何被Java内存模型保证的。顺便批判一下Double-checked实现的单例模式(被称为臭名昭注)，不是真的线程安全。\n\n安全发布和安全构造都与可见性相关，且往往联系紧密，因为一般来说发布将紧随构造之后，但我们还是给这两个术语。安全发布是指，其他线程能够正确变量被修改；安全构造是指，其他线程不会看到未完成构造的对象。\n\n### 不安全的发布 \n\n先将竞态条件放到一边，仅仅讨论可见性。由于指令重排的存在，在其他线程看来，对发布引用的写入操作，可能会先于被发布对象的构造函数中的某些指令，于是导致其他线程读到未完成构造的对象。\n\n必须通过happens-before规则来保证发布对象可见性和完整性(安全构造)；不可变对象是个例外，参见第三章。\n\n### 安全发布\n\nhappens-before规则是第三章中介绍的安全发布规则的基础，但是那些规则比happens-before规则看起来更直观。\n\n### 安全构造的一种方式(单例)\n\nJVM保证了静态初始化的线程安全，被静态代码构造的变量对所有线程都是可见的，但是单纯的静态构造不能满足使用时才初始化的要求(lazy)；单纯的加锁构造 & 加锁访问也许会拖累线程。\n借助class第一次被使用才会被JVM加载的规则，可以实现双赢(lazy、线程安全、不必每次都加锁)也较为优美的安全构造：\n\n>`@ThreadSafe`\n>`public class ResourceFactory {`\n>&emsp;&emsp;`private static class ResourceHolder {`\n>&emsp;&emsp;&emsp;&emsp;`public static Resource resource = new Resource();`\n>&emsp;&emsp;`}`\n>&emsp;&emsp;`public static Resource getResource() {` \n>&emsp;&emsp;&emsp;&emsp;`return ResourceHolder.resource;`\n>&emsp;&emsp;`}` \n>`}`\n\n### (批判)Double-checked单例构造\n\nDouble-checked的单例构造经常出现于各种面试题中，然而它实际上不是线程安全的，也不优美。其线程不安全的原因是，在第一次判没有使用同步，所以没有安全构造的保证，可能返回未完全构造的对象。尽管把对象的引用声明为volatile可以解决这个问题(如果对象是不可变的也不会有问题)，但这个写法远不如static-holder方式(上一节所述)简洁明了。\n\n### Java构造安全规则\n\nJava构造安全规则描述了在对象的构造过程中，什么样的属性的构造过程对其他线程是保证可见的，事实上这个规则在第三章也被提起过。这个规则和final属性息息相关。\n\n当对象被正确构造时(对象没有在构造函数中逸出)，Java构造安全规则保证，其他线程能正确看到这个对象的所有final属性构造结果，并保证能正确看到由这些final属性可达的所有对象的构造结果。\n\n这个规则的一个直观效果：不可变对象(所有属性都是final的)一定会被安全构造。\n\n啊，上面话有点抽象了，换一种说法：JVM保证了在构造函数中所有对final属性可见性(即使没有使用同步)，并且JVM保证对final属性的所有操作不会被重排到构造函数返回之后。\n\n啊，还是觉得很抽象的话，请看原文：\n\n> Initialization safety guarantees that for properly constructed objects, all \n> threads will see the correct values of final fields that were set by  \n> the constructor, regardless of how the object is published. Further, any \n> variables that can be reached through a final field of a properly \n> constructed object (such as the elements of a final array or the contents of \n> a HashMap refer- enced by a final field) are also guaranteed to be visible \n> to other threads.\n\n> Initialization safety makes visibility guarantees only for the values that \n> are reachable through final fields as of the time the constructor finishes. \n> For values reachable through nonfinal fields, or values that may change \n> after construction, you must use synchronization to ensure visibility.\n","slug":"JCIP-chapter16-java-memory-model","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4oy000h3mrfbn50ckhn","content":"<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>现代系统中，volatile变量读操作和普通变量读操作的代价几乎一样。</li>\n</ul>\n<p>整本JCIP都在避免直接讲述Java内存模型，但是线程安全机制是以内存模型为基础的，所以了解一些内存模型的知识有利于明白线程安全规则为何要那样规定。</p>\n<h2 id=\"Java内存模型概述-JMM\"><a href=\"#Java内存模型概述-JMM\" class=\"headerlink\" title=\"Java内存模型概述(JMM)\"></a>Java内存模型概述(JMM)</h2><h3 id=\"什么是Java内存模型\"><a href=\"#什么是Java内存模型\" class=\"headerlink\" title=\"什么是Java内存模型\"></a>什么是Java内存模型</h3><p>为什需要Java内存模型？<br>因为现代CPU的复杂优化，导致仅仅在单一线程上保证变量(抽象内存位置)的可见性；并且仅仅在单一线程上，指令的执行是可以等效成顺序执行(指令重排)的。</p>\n<p>Java内存模型规定了什么？<br>Java内存模型规定了JVM的行为，描述JVM在什么情况下必须保证变量的修改对其他线程是可见的。</p>\n<h3 id=\"平台的内存模型\"><a href=\"#平台的内存模型\" class=\"headerlink\" title=\"平台的内存模型\"></a>平台的内存模型</h3><p>平台(或者说cpu)会提供自己内存模型以及控制可见性特殊指令(例如memory barrier)。JVM会代理不同平台的内存模型，并抽象为统一的Java内存模型；各个平台的控制指令，也被抽象成了Java的同步机制。</p>\n<h3 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h3><p>众所周知，指令会重排；加上从缓存写会内存的时机不确定，跨线程分析变量的值可谓举步维艰(没有同步)。</p>\n<h3 id=\"所以Java内存模型是怎么说的\"><a href=\"#所以Java内存模型是怎么说的\" class=\"headerlink\" title=\"所以Java内存模型是怎么说的\"></a>所以Java内存模型是怎么说的</h3><p>Java内存模型通过一种偏序关系来描述内存可见性规则，在这个规则中定义一种关系叫happens-before，如果语句A(或者说指令，在JMM规则里叫action)对于语句B是happens-before的关系，那么语句A对变量的修改对于语句B是可见的。</p>\n<p>下面用一些规则什么情况下两条语句(指令，whatever)具有happens-before关系：   </p>\n<ul>\n<li>Program order rule。在同一线程上，所有语句按照代码顺序具有自然的happens-before关系；即同一线程上，直观上先执行的代码happens-before直观上后执行的代码。</li>\n<li>Monitor lock rule。对一个锁的释放操作happens-before对<strong>同一个锁</strong>的获取操作。注意两点，一定要求是同一个锁对象；规则同时适用于显式锁和内置锁。</li>\n<li>Volatile variable rule。对volatile属性的写操作happens-before对<strong>同一个volatile属性</strong>的读操作。注意两点，一定要求是同一个volatile属性；这条规则同时atomic变量。</li>\n<li>Thread start rule。启动线程操作happens-before被启动线程上的所有语句。</li>\n<li>Thread termination rule。一个线程上的所有语句happens-before发现这个线程结束的语句(发现线程结束的语句例如Thread.join()返回或者Thread.isAlive()返回false)。</li>\n<li>Interruption rule。线程A调用线程B的interrupt()happens-before线程B发现发现interrupt(例如调用isInterrupted)。</li>\n<li>Finalizer rule。对象构造函数的结束happens-before对象finalizer的开始。</li>\n<li>Transitivity。如果A事件happens-before B事件，且B事件happens-before C事件，那么A事件happens-before C事件。</li>\n</ul>\n<p>也许Java内存模型的规则会让第一次看的人觉得晦涩，事实上整个规则就是以单线程的顺序可见性为基础，通过一些保证顺序可见行的关键操作(例如线程的开始结束，锁的获取和释放，volatile变量的读写)加上传递性，来维持多线程代码的偏序关系。进而通过这个偏序关系来描述可见性规则，即偏序关系在前的操作对偏序关系在后的操作可见。</p>\n<h3 id=\"piggybacking-on-JMM-Trick的利用Java内存模型\"><a href=\"#piggybacking-on-JMM-Trick的利用Java内存模型\" class=\"headerlink\" title=\"piggybacking on JMM(Trick的利用Java内存模型)\"></a>piggybacking on JMM(Trick的利用Java内存模型)</h3><p>借助Java内存模型规则，可以利用微妙的happens-before传递来确保可见性，这种可见性保证不易发现并且需要推理，本书将这种现象叫piggybacking同步。</p>\n<p>作者以FutureTask的实现为例(在最新的jdk中这个实现已经改变)，展示了piggybacking同步。简单来说可以表述为：</p>\n<blockquote>\n<p><code>Thread A :</code><br>     <code>变量 X 的写操作</code><br>     <code>synchronized (变量 Y)</code><br>         <code>操作变量 Y</code></p>\n<p><code>Thread B :</code><br>    <code>synchronized (变量 Y)</code><br>        <code>操作变量 Y</code><br>    <code>变量 X 的读操作</code>   </p>\n</blockquote>\n<p>变量X在A线程上的读操作对B线程是可见的，尽管并没有针对X作任何同步，但是通过happens-before规则来保证了可见性。<br>piggybacking同步有时很显而易见(例如通过同步队列传递对象)，有时却很晦涩(例如上面的例子)。<strong>piggybacking同步要求操作微妙的顺序，因此非常的脆弱易出错，除非非常追求性能否则不要使用</strong>。</p>\n<h2 id=\"安全发布与安全构造\"><a href=\"#安全发布与安全构造\" class=\"headerlink\" title=\"安全发布与安全构造\"></a>安全发布与安全构造</h2><p>第三章讨论过安全发布，这一章借由Java内存模型旧话重提，来看看之前提到安全发布方式/安全构造方式是如何被Java内存模型保证的。顺便批判一下Double-checked实现的单例模式(被称为臭名昭注)，不是真的线程安全。</p>\n<p>安全发布和安全构造都与可见性相关，且往往联系紧密，因为一般来说发布将紧随构造之后，但我们还是给这两个术语。安全发布是指，其他线程能够正确变量被修改；安全构造是指，其他线程不会看到未完成构造的对象。</p>\n<h3 id=\"不安全的发布\"><a href=\"#不安全的发布\" class=\"headerlink\" title=\"不安全的发布\"></a>不安全的发布</h3><p>先将竞态条件放到一边，仅仅讨论可见性。由于指令重排的存在，在其他线程看来，对发布引用的写入操作，可能会先于被发布对象的构造函数中的某些指令，于是导致其他线程读到未完成构造的对象。</p>\n<p>必须通过happens-before规则来保证发布对象可见性和完整性(安全构造)；不可变对象是个例外，参见第三章。</p>\n<h3 id=\"安全发布\"><a href=\"#安全发布\" class=\"headerlink\" title=\"安全发布\"></a>安全发布</h3><p>happens-before规则是第三章中介绍的安全发布规则的基础，但是那些规则比happens-before规则看起来更直观。</p>\n<h3 id=\"安全构造的一种方式-单例\"><a href=\"#安全构造的一种方式-单例\" class=\"headerlink\" title=\"安全构造的一种方式(单例)\"></a>安全构造的一种方式(单例)</h3><p>JVM保证了静态初始化的线程安全，被静态代码构造的变量对所有线程都是可见的，但是单纯的静态构造不能满足使用时才初始化的要求(lazy)；单纯的加锁构造 &amp; 加锁访问也许会拖累线程。<br>借助class第一次被使用才会被JVM加载的规则，可以实现双赢(lazy、线程安全、不必每次都加锁)也较为优美的安全构造：</p>\n<blockquote>\n<p><code>@ThreadSafe</code><br><code>public class ResourceFactory &#123;</code><br>&emsp;&emsp;<code>private static class ResourceHolder &#123;</code><br>&emsp;&emsp;&emsp;&emsp;<code>public static Resource resource = new Resource();</code><br>&emsp;&emsp;<code>&#125;</code><br>&emsp;&emsp;<code>public static Resource getResource() &#123;</code><br>&emsp;&emsp;&emsp;&emsp;<code>return ResourceHolder.resource;</code><br>&emsp;&emsp;<code>&#125;</code><br><code>&#125;</code></p>\n</blockquote>\n<h3 id=\"批判-Double-checked单例构造\"><a href=\"#批判-Double-checked单例构造\" class=\"headerlink\" title=\"(批判)Double-checked单例构造\"></a>(批判)Double-checked单例构造</h3><p>Double-checked的单例构造经常出现于各种面试题中，然而它实际上不是线程安全的，也不优美。其线程不安全的原因是，在第一次判没有使用同步，所以没有安全构造的保证，可能返回未完全构造的对象。尽管把对象的引用声明为volatile可以解决这个问题(如果对象是不可变的也不会有问题)，但这个写法远不如static-holder方式(上一节所述)简洁明了。</p>\n<h3 id=\"Java构造安全规则\"><a href=\"#Java构造安全规则\" class=\"headerlink\" title=\"Java构造安全规则\"></a>Java构造安全规则</h3><p>Java构造安全规则描述了在对象的构造过程中，什么样的属性的构造过程对其他线程是保证可见的，事实上这个规则在第三章也被提起过。这个规则和final属性息息相关。</p>\n<p>当对象被正确构造时(对象没有在构造函数中逸出)，Java构造安全规则保证，其他线程能正确看到这个对象的所有final属性构造结果，并保证能正确看到由这些final属性可达的所有对象的构造结果。</p>\n<p>这个规则的一个直观效果：不可变对象(所有属性都是final的)一定会被安全构造。</p>\n<p>啊，上面话有点抽象了，换一种说法：JVM保证了在构造函数中所有对final属性可见性(即使没有使用同步)，并且JVM保证对final属性的所有操作不会被重排到构造函数返回之后。</p>\n<p>啊，还是觉得很抽象的话，请看原文：</p>\n<blockquote>\n<p>Initialization safety guarantees that for properly constructed objects, all<br>threads will see the correct values of final fields that were set by<br>the constructor, regardless of how the object is published. Further, any<br>variables that can be reached through a final field of a properly<br>constructed object (such as the elements of a final array or the contents of<br>a HashMap refer- enced by a final field) are also guaranteed to be visible<br>to other threads.</p>\n<p>Initialization safety makes visibility guarantees only for the values that<br>are reachable through final fields as of the time the constructor finishes.<br>For values reachable through nonfinal fields, or values that may change<br>after construction, you must use synchronization to ensure visibility.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>现代系统中，volatile变量读操作和普通变量读操作的代价几乎一样。</li>\n</ul>\n<p>整本JCIP都在避免直接讲述Java内存模型，但是线程安全机制是以内存模型为基础的，所以了解一些内存模型的知识有利于明白线程安全规则为何要那样规定。</p>\n<h2 id=\"Java内存模型概述-JMM\"><a href=\"#Java内存模型概述-JMM\" class=\"headerlink\" title=\"Java内存模型概述(JMM)\"></a>Java内存模型概述(JMM)</h2><h3 id=\"什么是Java内存模型\"><a href=\"#什么是Java内存模型\" class=\"headerlink\" title=\"什么是Java内存模型\"></a>什么是Java内存模型</h3><p>为什需要Java内存模型？<br>因为现代CPU的复杂优化，导致仅仅在单一线程上保证变量(抽象内存位置)的可见性；并且仅仅在单一线程上，指令的执行是可以等效成顺序执行(指令重排)的。</p>\n<p>Java内存模型规定了什么？<br>Java内存模型规定了JVM的行为，描述JVM在什么情况下必须保证变量的修改对其他线程是可见的。</p>\n<h3 id=\"平台的内存模型\"><a href=\"#平台的内存模型\" class=\"headerlink\" title=\"平台的内存模型\"></a>平台的内存模型</h3><p>平台(或者说cpu)会提供自己内存模型以及控制可见性特殊指令(例如memory barrier)。JVM会代理不同平台的内存模型，并抽象为统一的Java内存模型；各个平台的控制指令，也被抽象成了Java的同步机制。</p>\n<h3 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h3><p>众所周知，指令会重排；加上从缓存写会内存的时机不确定，跨线程分析变量的值可谓举步维艰(没有同步)。</p>\n<h3 id=\"所以Java内存模型是怎么说的\"><a href=\"#所以Java内存模型是怎么说的\" class=\"headerlink\" title=\"所以Java内存模型是怎么说的\"></a>所以Java内存模型是怎么说的</h3><p>Java内存模型通过一种偏序关系来描述内存可见性规则，在这个规则中定义一种关系叫happens-before，如果语句A(或者说指令，在JMM规则里叫action)对于语句B是happens-before的关系，那么语句A对变量的修改对于语句B是可见的。</p>\n<p>下面用一些规则什么情况下两条语句(指令，whatever)具有happens-before关系：   </p>\n<ul>\n<li>Program order rule。在同一线程上，所有语句按照代码顺序具有自然的happens-before关系；即同一线程上，直观上先执行的代码happens-before直观上后执行的代码。</li>\n<li>Monitor lock rule。对一个锁的释放操作happens-before对<strong>同一个锁</strong>的获取操作。注意两点，一定要求是同一个锁对象；规则同时适用于显式锁和内置锁。</li>\n<li>Volatile variable rule。对volatile属性的写操作happens-before对<strong>同一个volatile属性</strong>的读操作。注意两点，一定要求是同一个volatile属性；这条规则同时atomic变量。</li>\n<li>Thread start rule。启动线程操作happens-before被启动线程上的所有语句。</li>\n<li>Thread termination rule。一个线程上的所有语句happens-before发现这个线程结束的语句(发现线程结束的语句例如Thread.join()返回或者Thread.isAlive()返回false)。</li>\n<li>Interruption rule。线程A调用线程B的interrupt()happens-before线程B发现发现interrupt(例如调用isInterrupted)。</li>\n<li>Finalizer rule。对象构造函数的结束happens-before对象finalizer的开始。</li>\n<li>Transitivity。如果A事件happens-before B事件，且B事件happens-before C事件，那么A事件happens-before C事件。</li>\n</ul>\n<p>也许Java内存模型的规则会让第一次看的人觉得晦涩，事实上整个规则就是以单线程的顺序可见性为基础，通过一些保证顺序可见行的关键操作(例如线程的开始结束，锁的获取和释放，volatile变量的读写)加上传递性，来维持多线程代码的偏序关系。进而通过这个偏序关系来描述可见性规则，即偏序关系在前的操作对偏序关系在后的操作可见。</p>\n<h3 id=\"piggybacking-on-JMM-Trick的利用Java内存模型\"><a href=\"#piggybacking-on-JMM-Trick的利用Java内存模型\" class=\"headerlink\" title=\"piggybacking on JMM(Trick的利用Java内存模型)\"></a>piggybacking on JMM(Trick的利用Java内存模型)</h3><p>借助Java内存模型规则，可以利用微妙的happens-before传递来确保可见性，这种可见性保证不易发现并且需要推理，本书将这种现象叫piggybacking同步。</p>\n<p>作者以FutureTask的实现为例(在最新的jdk中这个实现已经改变)，展示了piggybacking同步。简单来说可以表述为：</p>\n<blockquote>\n<p><code>Thread A :</code><br>     <code>变量 X 的写操作</code><br>     <code>synchronized (变量 Y)</code><br>         <code>操作变量 Y</code></p>\n<p><code>Thread B :</code><br>    <code>synchronized (变量 Y)</code><br>        <code>操作变量 Y</code><br>    <code>变量 X 的读操作</code>   </p>\n</blockquote>\n<p>变量X在A线程上的读操作对B线程是可见的，尽管并没有针对X作任何同步，但是通过happens-before规则来保证了可见性。<br>piggybacking同步有时很显而易见(例如通过同步队列传递对象)，有时却很晦涩(例如上面的例子)。<strong>piggybacking同步要求操作微妙的顺序，因此非常的脆弱易出错，除非非常追求性能否则不要使用</strong>。</p>\n<h2 id=\"安全发布与安全构造\"><a href=\"#安全发布与安全构造\" class=\"headerlink\" title=\"安全发布与安全构造\"></a>安全发布与安全构造</h2><p>第三章讨论过安全发布，这一章借由Java内存模型旧话重提，来看看之前提到安全发布方式/安全构造方式是如何被Java内存模型保证的。顺便批判一下Double-checked实现的单例模式(被称为臭名昭注)，不是真的线程安全。</p>\n<p>安全发布和安全构造都与可见性相关，且往往联系紧密，因为一般来说发布将紧随构造之后，但我们还是给这两个术语。安全发布是指，其他线程能够正确变量被修改；安全构造是指，其他线程不会看到未完成构造的对象。</p>\n<h3 id=\"不安全的发布\"><a href=\"#不安全的发布\" class=\"headerlink\" title=\"不安全的发布\"></a>不安全的发布</h3><p>先将竞态条件放到一边，仅仅讨论可见性。由于指令重排的存在，在其他线程看来，对发布引用的写入操作，可能会先于被发布对象的构造函数中的某些指令，于是导致其他线程读到未完成构造的对象。</p>\n<p>必须通过happens-before规则来保证发布对象可见性和完整性(安全构造)；不可变对象是个例外，参见第三章。</p>\n<h3 id=\"安全发布\"><a href=\"#安全发布\" class=\"headerlink\" title=\"安全发布\"></a>安全发布</h3><p>happens-before规则是第三章中介绍的安全发布规则的基础，但是那些规则比happens-before规则看起来更直观。</p>\n<h3 id=\"安全构造的一种方式-单例\"><a href=\"#安全构造的一种方式-单例\" class=\"headerlink\" title=\"安全构造的一种方式(单例)\"></a>安全构造的一种方式(单例)</h3><p>JVM保证了静态初始化的线程安全，被静态代码构造的变量对所有线程都是可见的，但是单纯的静态构造不能满足使用时才初始化的要求(lazy)；单纯的加锁构造 &amp; 加锁访问也许会拖累线程。<br>借助class第一次被使用才会被JVM加载的规则，可以实现双赢(lazy、线程安全、不必每次都加锁)也较为优美的安全构造：</p>\n<blockquote>\n<p><code>@ThreadSafe</code><br><code>public class ResourceFactory &#123;</code><br>&emsp;&emsp;<code>private static class ResourceHolder &#123;</code><br>&emsp;&emsp;&emsp;&emsp;<code>public static Resource resource = new Resource();</code><br>&emsp;&emsp;<code>&#125;</code><br>&emsp;&emsp;<code>public static Resource getResource() &#123;</code><br>&emsp;&emsp;&emsp;&emsp;<code>return ResourceHolder.resource;</code><br>&emsp;&emsp;<code>&#125;</code><br><code>&#125;</code></p>\n</blockquote>\n<h3 id=\"批判-Double-checked单例构造\"><a href=\"#批判-Double-checked单例构造\" class=\"headerlink\" title=\"(批判)Double-checked单例构造\"></a>(批判)Double-checked单例构造</h3><p>Double-checked的单例构造经常出现于各种面试题中，然而它实际上不是线程安全的，也不优美。其线程不安全的原因是，在第一次判没有使用同步，所以没有安全构造的保证，可能返回未完全构造的对象。尽管把对象的引用声明为volatile可以解决这个问题(如果对象是不可变的也不会有问题)，但这个写法远不如static-holder方式(上一节所述)简洁明了。</p>\n<h3 id=\"Java构造安全规则\"><a href=\"#Java构造安全规则\" class=\"headerlink\" title=\"Java构造安全规则\"></a>Java构造安全规则</h3><p>Java构造安全规则描述了在对象的构造过程中，什么样的属性的构造过程对其他线程是保证可见的，事实上这个规则在第三章也被提起过。这个规则和final属性息息相关。</p>\n<p>当对象被正确构造时(对象没有在构造函数中逸出)，Java构造安全规则保证，其他线程能正确看到这个对象的所有final属性构造结果，并保证能正确看到由这些final属性可达的所有对象的构造结果。</p>\n<p>这个规则的一个直观效果：不可变对象(所有属性都是final的)一定会被安全构造。</p>\n<p>啊，上面话有点抽象了，换一种说法：JVM保证了在构造函数中所有对final属性可见性(即使没有使用同步)，并且JVM保证对final属性的所有操作不会被重排到构造函数返回之后。</p>\n<p>啊，还是觉得很抽象的话，请看原文：</p>\n<blockquote>\n<p>Initialization safety guarantees that for properly constructed objects, all<br>threads will see the correct values of final fields that were set by<br>the constructor, regardless of how the object is published. Further, any<br>variables that can be reached through a final field of a properly<br>constructed object (such as the elements of a final array or the contents of<br>a HashMap refer- enced by a final field) are also guaranteed to be visible<br>to other threads.</p>\n<p>Initialization safety makes visibility guarantees only for the values that<br>are reachable through final fields as of the time the constructor finishes.<br>For values reachable through nonfinal fields, or values that may change<br>after construction, you must use synchronization to ensure visibility.</p>\n</blockquote>\n"},{"title":"Java库中的线程安全类","subtitle":"JCIP读书笔记第五章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-10-09T09:24:53.000Z","_content":"\n\n## 概览\n\n最稳定的实现线程安全类的方式，就是借助已有的线程安全类。这一章将介绍Java库中的线程安全类，包括一些线程安全容器类和同步工具类。\n\n## 同步容器\n\nJava库中的同步容器包括Vector、Hashtable以及Collections.synchronized*系列容器，这些容器都采用内置锁来执行同步操作。\n\n### 同步容器的问题\n\n**client-side锁**\n如果需要同步的组合操作(例如取得容器长度，然后删除最后一个元素)，需要使用client-side锁。事实上同步容器是支持client-side锁的，其同步使用的锁即自身对象，然而使用client-side锁往往基于对于容器实现代码的阅读。\n\n### 同步容器抛出ConcurrentModificationException\n\n当从同步容器获取迭代器之后如果同步容器被修改，迭代器的操作会抛出ConcurrentModificationException；这一特性是通过modification count计数器实现的。\n即使在单线程情况下，也可能会抛出ConcurrentModificationException。\n\n注意foreach语法也是通过迭代器实现的。\n\n### 隐蔽的迭代器使用\n\n迭代器的使用可能发生在某些被封装的方法中(例如toString)，使得调用者不易注意到ConcurrentModificationException可能被抛出。\n\n## 并发容器\n\nJava5.0之后提供了并发容器系列，所谓同步容器的改进或补充；并发容器不使用严格的互斥操作，提供了更好的性能和伸缩性。并发容器系列包括ConcurrentHashMap、 CopyOnWriteArrayList、ConcurrentLinkedQueue等。\n\n因为性能大幅提升，尽量使用并发容器而不是同步容器；同步容器唯一的优势就是互斥操作(如果需要的话)。\n\n### ConcurrentHashMap\n\nConcurrentHashMap使用了更细粒度的同步机制，允许多线程并发读取、同时读写以及一定数量的并发写入，大幅度提升了吞吐量和伸缩性。\nConcurrentHashMap和其他并发容器返回的迭代器不会抛出ConcurrentModificationException；ConcurrentHashMap的迭代器采用一种弱同步机制来同步容器元素的变化(不保证准确)。\n\n### CopyOnWriteArrayList\n\nCopyOnWriteArrayList线程安全依赖于不可变对象一定是线程安全的。人如其名，在每次发生写入时进行拷贝。\n\n### 更多的原子操作\n\n由于并发容器不能使用client-side锁，所以并发容器提供了一系列的原子操作(例如put-if-absent等)。\n\n## 阻塞队列和生产者消费者模式\n\n略\n\n## 阻塞方法和可中断方法\n\n见[中止线程](http://blog.overspark.me/2017/10/09/JCIP-chapter7-cancellation-and-shutdown/)。\n\n## 同步工具类\n\n同步工具类是基于一些状态控制线程执行流程的工具类，它们通常都持有某种状态，并基于这个状态决定允许线程执行或阻塞线程。BlockingQueue是线程安全容器的同时，也可以视为同步工具。\n\n同步工具还包括：Latch、FutureTask、Semaphore、Barrier等。\n\n\n\n","source":"_posts/JCIP-chapter5-building-blocks.md","raw":"---\ntitle: Java库中的线程安全类\nsubtitle: JCIP读书笔记第五章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-10-09 17:24:53\n---\n\n\n## 概览\n\n最稳定的实现线程安全类的方式，就是借助已有的线程安全类。这一章将介绍Java库中的线程安全类，包括一些线程安全容器类和同步工具类。\n\n## 同步容器\n\nJava库中的同步容器包括Vector、Hashtable以及Collections.synchronized*系列容器，这些容器都采用内置锁来执行同步操作。\n\n### 同步容器的问题\n\n**client-side锁**\n如果需要同步的组合操作(例如取得容器长度，然后删除最后一个元素)，需要使用client-side锁。事实上同步容器是支持client-side锁的，其同步使用的锁即自身对象，然而使用client-side锁往往基于对于容器实现代码的阅读。\n\n### 同步容器抛出ConcurrentModificationException\n\n当从同步容器获取迭代器之后如果同步容器被修改，迭代器的操作会抛出ConcurrentModificationException；这一特性是通过modification count计数器实现的。\n即使在单线程情况下，也可能会抛出ConcurrentModificationException。\n\n注意foreach语法也是通过迭代器实现的。\n\n### 隐蔽的迭代器使用\n\n迭代器的使用可能发生在某些被封装的方法中(例如toString)，使得调用者不易注意到ConcurrentModificationException可能被抛出。\n\n## 并发容器\n\nJava5.0之后提供了并发容器系列，所谓同步容器的改进或补充；并发容器不使用严格的互斥操作，提供了更好的性能和伸缩性。并发容器系列包括ConcurrentHashMap、 CopyOnWriteArrayList、ConcurrentLinkedQueue等。\n\n因为性能大幅提升，尽量使用并发容器而不是同步容器；同步容器唯一的优势就是互斥操作(如果需要的话)。\n\n### ConcurrentHashMap\n\nConcurrentHashMap使用了更细粒度的同步机制，允许多线程并发读取、同时读写以及一定数量的并发写入，大幅度提升了吞吐量和伸缩性。\nConcurrentHashMap和其他并发容器返回的迭代器不会抛出ConcurrentModificationException；ConcurrentHashMap的迭代器采用一种弱同步机制来同步容器元素的变化(不保证准确)。\n\n### CopyOnWriteArrayList\n\nCopyOnWriteArrayList线程安全依赖于不可变对象一定是线程安全的。人如其名，在每次发生写入时进行拷贝。\n\n### 更多的原子操作\n\n由于并发容器不能使用client-side锁，所以并发容器提供了一系列的原子操作(例如put-if-absent等)。\n\n## 阻塞队列和生产者消费者模式\n\n略\n\n## 阻塞方法和可中断方法\n\n见[中止线程](http://blog.overspark.me/2017/10/09/JCIP-chapter7-cancellation-and-shutdown/)。\n\n## 同步工具类\n\n同步工具类是基于一些状态控制线程执行流程的工具类，它们通常都持有某种状态，并基于这个状态决定允许线程执行或阻塞线程。BlockingQueue是线程安全容器的同时，也可以视为同步工具。\n\n同步工具还包括：Latch、FutureTask、Semaphore、Barrier等。\n\n\n\n","slug":"JCIP-chapter5-building-blocks","published":1,"updated":"2017-10-09T09:28:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4oy000i3mrf532n4omi","content":"<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p>最稳定的实现线程安全类的方式，就是借助已有的线程安全类。这一章将介绍Java库中的线程安全类，包括一些线程安全容器类和同步工具类。</p>\n<h2 id=\"同步容器\"><a href=\"#同步容器\" class=\"headerlink\" title=\"同步容器\"></a>同步容器</h2><p>Java库中的同步容器包括Vector、Hashtable以及Collections.synchronized*系列容器，这些容器都采用内置锁来执行同步操作。</p>\n<h3 id=\"同步容器的问题\"><a href=\"#同步容器的问题\" class=\"headerlink\" title=\"同步容器的问题\"></a>同步容器的问题</h3><p><strong>client-side锁</strong><br>如果需要同步的组合操作(例如取得容器长度，然后删除最后一个元素)，需要使用client-side锁。事实上同步容器是支持client-side锁的，其同步使用的锁即自身对象，然而使用client-side锁往往基于对于容器实现代码的阅读。</p>\n<h3 id=\"同步容器抛出ConcurrentModificationException\"><a href=\"#同步容器抛出ConcurrentModificationException\" class=\"headerlink\" title=\"同步容器抛出ConcurrentModificationException\"></a>同步容器抛出ConcurrentModificationException</h3><p>当从同步容器获取迭代器之后如果同步容器被修改，迭代器的操作会抛出ConcurrentModificationException；这一特性是通过modification count计数器实现的。<br>即使在单线程情况下，也可能会抛出ConcurrentModificationException。</p>\n<p>注意foreach语法也是通过迭代器实现的。</p>\n<h3 id=\"隐蔽的迭代器使用\"><a href=\"#隐蔽的迭代器使用\" class=\"headerlink\" title=\"隐蔽的迭代器使用\"></a>隐蔽的迭代器使用</h3><p>迭代器的使用可能发生在某些被封装的方法中(例如toString)，使得调用者不易注意到ConcurrentModificationException可能被抛出。</p>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><p>Java5.0之后提供了并发容器系列，所谓同步容器的改进或补充；并发容器不使用严格的互斥操作，提供了更好的性能和伸缩性。并发容器系列包括ConcurrentHashMap、 CopyOnWriteArrayList、ConcurrentLinkedQueue等。</p>\n<p>因为性能大幅提升，尽量使用并发容器而不是同步容器；同步容器唯一的优势就是互斥操作(如果需要的话)。</p>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap使用了更细粒度的同步机制，允许多线程并发读取、同时读写以及一定数量的并发写入，大幅度提升了吞吐量和伸缩性。<br>ConcurrentHashMap和其他并发容器返回的迭代器不会抛出ConcurrentModificationException；ConcurrentHashMap的迭代器采用一种弱同步机制来同步容器元素的变化(不保证准确)。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList线程安全依赖于不可变对象一定是线程安全的。人如其名，在每次发生写入时进行拷贝。</p>\n<h3 id=\"更多的原子操作\"><a href=\"#更多的原子操作\" class=\"headerlink\" title=\"更多的原子操作\"></a>更多的原子操作</h3><p>由于并发容器不能使用client-side锁，所以并发容器提供了一系列的原子操作(例如put-if-absent等)。</p>\n<h2 id=\"阻塞队列和生产者消费者模式\"><a href=\"#阻塞队列和生产者消费者模式\" class=\"headerlink\" title=\"阻塞队列和生产者消费者模式\"></a>阻塞队列和生产者消费者模式</h2><p>略</p>\n<h2 id=\"阻塞方法和可中断方法\"><a href=\"#阻塞方法和可中断方法\" class=\"headerlink\" title=\"阻塞方法和可中断方法\"></a>阻塞方法和可中断方法</h2><p>见<a href=\"http://blog.overspark.me/2017/10/09/JCIP-chapter7-cancellation-and-shutdown/\">中止线程</a>。</p>\n<h2 id=\"同步工具类\"><a href=\"#同步工具类\" class=\"headerlink\" title=\"同步工具类\"></a>同步工具类</h2><p>同步工具类是基于一些状态控制线程执行流程的工具类，它们通常都持有某种状态，并基于这个状态决定允许线程执行或阻塞线程。BlockingQueue是线程安全容器的同时，也可以视为同步工具。</p>\n<p>同步工具还包括：Latch、FutureTask、Semaphore、Barrier等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p>最稳定的实现线程安全类的方式，就是借助已有的线程安全类。这一章将介绍Java库中的线程安全类，包括一些线程安全容器类和同步工具类。</p>\n<h2 id=\"同步容器\"><a href=\"#同步容器\" class=\"headerlink\" title=\"同步容器\"></a>同步容器</h2><p>Java库中的同步容器包括Vector、Hashtable以及Collections.synchronized*系列容器，这些容器都采用内置锁来执行同步操作。</p>\n<h3 id=\"同步容器的问题\"><a href=\"#同步容器的问题\" class=\"headerlink\" title=\"同步容器的问题\"></a>同步容器的问题</h3><p><strong>client-side锁</strong><br>如果需要同步的组合操作(例如取得容器长度，然后删除最后一个元素)，需要使用client-side锁。事实上同步容器是支持client-side锁的，其同步使用的锁即自身对象，然而使用client-side锁往往基于对于容器实现代码的阅读。</p>\n<h3 id=\"同步容器抛出ConcurrentModificationException\"><a href=\"#同步容器抛出ConcurrentModificationException\" class=\"headerlink\" title=\"同步容器抛出ConcurrentModificationException\"></a>同步容器抛出ConcurrentModificationException</h3><p>当从同步容器获取迭代器之后如果同步容器被修改，迭代器的操作会抛出ConcurrentModificationException；这一特性是通过modification count计数器实现的。<br>即使在单线程情况下，也可能会抛出ConcurrentModificationException。</p>\n<p>注意foreach语法也是通过迭代器实现的。</p>\n<h3 id=\"隐蔽的迭代器使用\"><a href=\"#隐蔽的迭代器使用\" class=\"headerlink\" title=\"隐蔽的迭代器使用\"></a>隐蔽的迭代器使用</h3><p>迭代器的使用可能发生在某些被封装的方法中(例如toString)，使得调用者不易注意到ConcurrentModificationException可能被抛出。</p>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><p>Java5.0之后提供了并发容器系列，所谓同步容器的改进或补充；并发容器不使用严格的互斥操作，提供了更好的性能和伸缩性。并发容器系列包括ConcurrentHashMap、 CopyOnWriteArrayList、ConcurrentLinkedQueue等。</p>\n<p>因为性能大幅提升，尽量使用并发容器而不是同步容器；同步容器唯一的优势就是互斥操作(如果需要的话)。</p>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap使用了更细粒度的同步机制，允许多线程并发读取、同时读写以及一定数量的并发写入，大幅度提升了吞吐量和伸缩性。<br>ConcurrentHashMap和其他并发容器返回的迭代器不会抛出ConcurrentModificationException；ConcurrentHashMap的迭代器采用一种弱同步机制来同步容器元素的变化(不保证准确)。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList线程安全依赖于不可变对象一定是线程安全的。人如其名，在每次发生写入时进行拷贝。</p>\n<h3 id=\"更多的原子操作\"><a href=\"#更多的原子操作\" class=\"headerlink\" title=\"更多的原子操作\"></a>更多的原子操作</h3><p>由于并发容器不能使用client-side锁，所以并发容器提供了一系列的原子操作(例如put-if-absent等)。</p>\n<h2 id=\"阻塞队列和生产者消费者模式\"><a href=\"#阻塞队列和生产者消费者模式\" class=\"headerlink\" title=\"阻塞队列和生产者消费者模式\"></a>阻塞队列和生产者消费者模式</h2><p>略</p>\n<h2 id=\"阻塞方法和可中断方法\"><a href=\"#阻塞方法和可中断方法\" class=\"headerlink\" title=\"阻塞方法和可中断方法\"></a>阻塞方法和可中断方法</h2><p>见<a href=\"http://blog.overspark.me/2017/10/09/JCIP-chapter7-cancellation-and-shutdown/\">中止线程</a>。</p>\n<h2 id=\"同步工具类\"><a href=\"#同步工具类\" class=\"headerlink\" title=\"同步工具类\"></a>同步工具类</h2><p>同步工具类是基于一些状态控制线程执行流程的工具类，它们通常都持有某种状态，并基于这个状态决定允许线程执行或阻塞线程。BlockingQueue是线程安全容器的同时，也可以视为同步工具。</p>\n<p>同步工具还包括：Latch、FutureTask、Semaphore、Barrier等。</p>\n"},{"title":"中止线程","subtitle":"JCIP读书笔记第七章","catalog":true,"header-img":"/img/header_img/java-note-header.jpg","date":"2017-10-09T07:09:58.000Z","_content":"\n\n## 概述\n\n中止线程比启动线程要复杂，Java没有提供之间中止线程的机制(初期的中止线程方法被弃用)，而是提供了interruption机制提醒线程自己进行中止。用interruption机制来代替中止线程的原因是，如果线程被类似stop()的方法立即中止可能会打断正在进行的操作，而使变量处于非法的状态。\n\n## 任务中止\n\n中止任务的需求有很多，例如用户请求、任务时限、发生错误、服务关闭等情况。没有主动中止任务方法情况下--就像Java--可以通过设置中止标志位，并由任务代码自身定期检查中止标志来执行中止；interruption机制正是使用了类似中止标志位的协议。\n\n### 中断(Interruption)\n\nInterruption是一个线程通过Interrupted标志位通知另一个线程的一种线程间交流机制，Interruption不一定要和中止线程的语意绑定，然而在实践中Interruption通常只用于中止线程的场景；将Interruption用于中止线程以外的场景，都被证明会使程序变得脆弱且难以维护。\n\n每个线程都有一个interrupted标志位，interrupt某个线程就是将其interrupted置为true。Thread.interrupt()、Thread.isInterrupted()、Thread.interrupted()是与Interruption机制相关的三个方法。\n其中Thread.interrupted()容易使人迷惑，他会返回interrupted标志位**并将其置为false**，这也是唯一将interrupted标志位置回false的方法。\n\nJava库中对interruption的响应方式是将interrupted置回false，并抛出InterruptedException。\n\n### 中断策略\n\n通常来说，任务执行代码不应该假设其被执行的线程的中断策略，因为任务执行代码很可能在线程池的worker线程中被执行；所以在任务处理中断并中止任务后，应当保留当前线程的被中断状态(抛出InterruptedException或者保留interrupted为true)。\n\n线程的持有者应当将任务中止操作封装为类似cancel方法；与此同时非线程持有者在中止任务时应当调用封装方法，而不是直接Thread.interrupt();\n\n### 响应中断\n\n处理InterruptedException的方法有两种，将InterruptedException抛出；或者将interrupted置为true。永远不要仅仅捕获InterruptedException并什么都不做。\n线程拥有者通常是创建线程的对象，它通常还会继承Thread对象。只有线程的拥有者，才有权中止interrupted状态的传播；其他任务或者工具代码在处理中断时都应继续传播中断状态。\n\n### 使用Future提供的中止任务的功能\n\nFuture.canel(boolean)可以用于中止任务，其包含布尔型参数mayInterruptIfRunning代表cancel方法是否会中断worker线程。\n\n### 处理不可中断的阻塞\n\n有一些阻塞的操作不响应中断，需要采用其他的方法来中止这些操作：\n\n* 同步的IO操作，基于Socket的阻塞IO可以通过关闭Socket使其抛出SocketException来中止。\n* 等待获取内置锁，等待内置锁的阻塞是无解的，如果有中止的需求可以改用显式锁。\n\n\n### 重写ThreadPoolExecutor的newTaskFor方法\n\n通过重写ThreadPoolExecutor的newTaskFor方法，可以返回自定义的FutureTask类；通过重写返回的FutureTask的cancel方法，可以hook中止任务的过程(例如加入关闭IO的操作)。\n\n## 关闭服务(包含线程的服务)\n\n通常应用程序都会使用一些包含线程的服务(例如任务系统、线程池)，这些服务通常都是常驻内存的，所以在应用结束之前应当使用适当的方法来关闭这些服务，以防止线程泄漏。\n中止线程的工作应该有线程的拥有者，也就是服务本身来完成，所以类似这些服务通常应该提供shutdown方法。ExecutorService就定义了shutdown和shutdownNow两个关闭方法。\n\n### 一个Log服务\n\n本章将以一个使用单独线程的Log服务作例子，讲解关闭服务的方式。\n\n在实现关闭服务操作时，需要留意几个问题：\n\n* 是将现在正在排队的任务处理完再关闭服务(暂且称为安全关闭)，还是立即关闭服务。\n* 如何在关闭服务过程中，处理外部程序调用服务功能。\n* 在关闭服务时清理状态。\n\n在这一节，给出了一个利用请求计数实现安全关闭例子。\n\n### ExecutorService的关闭方法\n\nExecutorService的showdown方法提供了安全关闭；showdownNow方法提供了立即关闭。\n\n这一节借助ExecutorService重写了Log服务，并利用ExecutorService的shutdown方法实现了安全关闭。\n\n### Poison Pills\n\n用于生产者消费者关系中的一种关闭方式，生产者在关闭之后将poison pill加入队列，消费者在获取到poison pill之后关闭自己。\npoison pill方式只能用于生产者数量和消费者数量都确定的情况。\n\n### 使用非常驻的ExecutorService\n\n借助局部的ExecutorService，将所有任务submit之后执行shutdown和awaitTermination，可以达到等待所有任务完成之后再返回的效果。\n\n### showdownNow(立即关闭)的局限性\n\nExecutorService的showdownNow方法会返回所有未完成任务的列表(Runnable的list)，但是无法区分哪些是还未开始的任务、哪些是执行到一半中止的任务。\n\n## 处理线程的异常结束\n\n线程可能会因为抛出异常(通常是RuntimeException)而提前结束，这种异常结束不易被其他线程发现(也许仅仅在控制台输出了异常栈)，从而产生了线程泄漏。\n\n一种简单处理方式，在worker线程中捕获类似Runnable.run()方法抛出的unchecked Exception、结束线程、并通知worker线程的拥有者(通常是某种Service)线程异常结束的消息；尽管这种捕获unchecked Exception方法的安全性存在争议。\n\n### Uncaught exception handler\n\nThread提供了UncaughtExceptionHandler相关的API，可以发现从线程中抛出的未捕获的异常。\n\n最好为所有常驻线程添加UncaughtExceptionHandler。\n\n## 关闭JVM\n \nJVM有两种关闭方式：orderly或abrupt。\n当JVM中最后一个非守护线程结束、System.exit或者其他关闭JVM的方法被调用时，触发orderly关闭；当Runtime.halt被调用或者关闭JVM进程时，触发abrupt关闭。\n\n在orderly关闭过程中，JVM首先会执行所有的Shutdown hook；然后可能会执行对象的finalizer；然后关闭JVM。orderly关闭发生时，JVM不会去中断任何正在执行的线程，这些线程运行直到JVM关闭时停止。\n在abrupt关闭过程中，JVM直接停止其他什么都不做。\n\n### Shutdown hook\n\nShutdown hook时通过Runtime.addShutdownHook注册的；Shutdown hook运行在单独的线程中，所以需要是线程安全的。\n\n一种相对轻松的使用Shutdown hook方式是，整个应用仅使用一个Shutdown hook，将所有的关闭工作在这个Shutdown hook中按某种顺序执行。\n\n### 守护线程\n\nJVM中的线程可以被分为两类，普通线程和守护线程，如果不想让某些常驻线程阻止JVM关闭，可以将这些线程设为守护线程；除了主线程之外，JVM启动时创建的所有线程都是守护线程。\n\n当线程被创建时，其守护属性默认继承创建它的线程的守护属性，所以普通线程创建的线程默认是普通线程，守护线程创建的线程默认是守护线程。\n\n守护线程可能在任何时刻突然停止，如果在守护线程中执行IO操作，那么就可能没有机会清理IO。所以，**任务类服务中的work线程不适合被创建成守护线程**，守护线程适合做一些没有生命周期属性的工作。\n\n### finalizer\n\nfinalizer被JVM在单独上执行，所以需要是线程安全的；其被执行的时间、和是否会被执行都不确定。基于finalizer要求线程安全，重载finalizer的类会增加额外的同步，从而影响性能；同时finalizer很难被正确的编写；所以**尽量避免使用finalizer**\n\n一个使用finalizer的例外是，在finalizer中检查对象是否已经释放其持有的资源，否则输出错误提示。\n\n\n\n","source":"_posts/JCIP-chapter7-cancellation-and-shutdown.md","raw":"---\ntitle: 中止线程\nsubtitle: JCIP读书笔记第七章\ncatalog: true\nheader-img: /img/header_img/java-note-header.jpg\ntags:\n  - Java\ncategories:\n  - 读书笔记\ndate: 2017-10-09 15:09:58\n---\n\n\n## 概述\n\n中止线程比启动线程要复杂，Java没有提供之间中止线程的机制(初期的中止线程方法被弃用)，而是提供了interruption机制提醒线程自己进行中止。用interruption机制来代替中止线程的原因是，如果线程被类似stop()的方法立即中止可能会打断正在进行的操作，而使变量处于非法的状态。\n\n## 任务中止\n\n中止任务的需求有很多，例如用户请求、任务时限、发生错误、服务关闭等情况。没有主动中止任务方法情况下--就像Java--可以通过设置中止标志位，并由任务代码自身定期检查中止标志来执行中止；interruption机制正是使用了类似中止标志位的协议。\n\n### 中断(Interruption)\n\nInterruption是一个线程通过Interrupted标志位通知另一个线程的一种线程间交流机制，Interruption不一定要和中止线程的语意绑定，然而在实践中Interruption通常只用于中止线程的场景；将Interruption用于中止线程以外的场景，都被证明会使程序变得脆弱且难以维护。\n\n每个线程都有一个interrupted标志位，interrupt某个线程就是将其interrupted置为true。Thread.interrupt()、Thread.isInterrupted()、Thread.interrupted()是与Interruption机制相关的三个方法。\n其中Thread.interrupted()容易使人迷惑，他会返回interrupted标志位**并将其置为false**，这也是唯一将interrupted标志位置回false的方法。\n\nJava库中对interruption的响应方式是将interrupted置回false，并抛出InterruptedException。\n\n### 中断策略\n\n通常来说，任务执行代码不应该假设其被执行的线程的中断策略，因为任务执行代码很可能在线程池的worker线程中被执行；所以在任务处理中断并中止任务后，应当保留当前线程的被中断状态(抛出InterruptedException或者保留interrupted为true)。\n\n线程的持有者应当将任务中止操作封装为类似cancel方法；与此同时非线程持有者在中止任务时应当调用封装方法，而不是直接Thread.interrupt();\n\n### 响应中断\n\n处理InterruptedException的方法有两种，将InterruptedException抛出；或者将interrupted置为true。永远不要仅仅捕获InterruptedException并什么都不做。\n线程拥有者通常是创建线程的对象，它通常还会继承Thread对象。只有线程的拥有者，才有权中止interrupted状态的传播；其他任务或者工具代码在处理中断时都应继续传播中断状态。\n\n### 使用Future提供的中止任务的功能\n\nFuture.canel(boolean)可以用于中止任务，其包含布尔型参数mayInterruptIfRunning代表cancel方法是否会中断worker线程。\n\n### 处理不可中断的阻塞\n\n有一些阻塞的操作不响应中断，需要采用其他的方法来中止这些操作：\n\n* 同步的IO操作，基于Socket的阻塞IO可以通过关闭Socket使其抛出SocketException来中止。\n* 等待获取内置锁，等待内置锁的阻塞是无解的，如果有中止的需求可以改用显式锁。\n\n\n### 重写ThreadPoolExecutor的newTaskFor方法\n\n通过重写ThreadPoolExecutor的newTaskFor方法，可以返回自定义的FutureTask类；通过重写返回的FutureTask的cancel方法，可以hook中止任务的过程(例如加入关闭IO的操作)。\n\n## 关闭服务(包含线程的服务)\n\n通常应用程序都会使用一些包含线程的服务(例如任务系统、线程池)，这些服务通常都是常驻内存的，所以在应用结束之前应当使用适当的方法来关闭这些服务，以防止线程泄漏。\n中止线程的工作应该有线程的拥有者，也就是服务本身来完成，所以类似这些服务通常应该提供shutdown方法。ExecutorService就定义了shutdown和shutdownNow两个关闭方法。\n\n### 一个Log服务\n\n本章将以一个使用单独线程的Log服务作例子，讲解关闭服务的方式。\n\n在实现关闭服务操作时，需要留意几个问题：\n\n* 是将现在正在排队的任务处理完再关闭服务(暂且称为安全关闭)，还是立即关闭服务。\n* 如何在关闭服务过程中，处理外部程序调用服务功能。\n* 在关闭服务时清理状态。\n\n在这一节，给出了一个利用请求计数实现安全关闭例子。\n\n### ExecutorService的关闭方法\n\nExecutorService的showdown方法提供了安全关闭；showdownNow方法提供了立即关闭。\n\n这一节借助ExecutorService重写了Log服务，并利用ExecutorService的shutdown方法实现了安全关闭。\n\n### Poison Pills\n\n用于生产者消费者关系中的一种关闭方式，生产者在关闭之后将poison pill加入队列，消费者在获取到poison pill之后关闭自己。\npoison pill方式只能用于生产者数量和消费者数量都确定的情况。\n\n### 使用非常驻的ExecutorService\n\n借助局部的ExecutorService，将所有任务submit之后执行shutdown和awaitTermination，可以达到等待所有任务完成之后再返回的效果。\n\n### showdownNow(立即关闭)的局限性\n\nExecutorService的showdownNow方法会返回所有未完成任务的列表(Runnable的list)，但是无法区分哪些是还未开始的任务、哪些是执行到一半中止的任务。\n\n## 处理线程的异常结束\n\n线程可能会因为抛出异常(通常是RuntimeException)而提前结束，这种异常结束不易被其他线程发现(也许仅仅在控制台输出了异常栈)，从而产生了线程泄漏。\n\n一种简单处理方式，在worker线程中捕获类似Runnable.run()方法抛出的unchecked Exception、结束线程、并通知worker线程的拥有者(通常是某种Service)线程异常结束的消息；尽管这种捕获unchecked Exception方法的安全性存在争议。\n\n### Uncaught exception handler\n\nThread提供了UncaughtExceptionHandler相关的API，可以发现从线程中抛出的未捕获的异常。\n\n最好为所有常驻线程添加UncaughtExceptionHandler。\n\n## 关闭JVM\n \nJVM有两种关闭方式：orderly或abrupt。\n当JVM中最后一个非守护线程结束、System.exit或者其他关闭JVM的方法被调用时，触发orderly关闭；当Runtime.halt被调用或者关闭JVM进程时，触发abrupt关闭。\n\n在orderly关闭过程中，JVM首先会执行所有的Shutdown hook；然后可能会执行对象的finalizer；然后关闭JVM。orderly关闭发生时，JVM不会去中断任何正在执行的线程，这些线程运行直到JVM关闭时停止。\n在abrupt关闭过程中，JVM直接停止其他什么都不做。\n\n### Shutdown hook\n\nShutdown hook时通过Runtime.addShutdownHook注册的；Shutdown hook运行在单独的线程中，所以需要是线程安全的。\n\n一种相对轻松的使用Shutdown hook方式是，整个应用仅使用一个Shutdown hook，将所有的关闭工作在这个Shutdown hook中按某种顺序执行。\n\n### 守护线程\n\nJVM中的线程可以被分为两类，普通线程和守护线程，如果不想让某些常驻线程阻止JVM关闭，可以将这些线程设为守护线程；除了主线程之外，JVM启动时创建的所有线程都是守护线程。\n\n当线程被创建时，其守护属性默认继承创建它的线程的守护属性，所以普通线程创建的线程默认是普通线程，守护线程创建的线程默认是守护线程。\n\n守护线程可能在任何时刻突然停止，如果在守护线程中执行IO操作，那么就可能没有机会清理IO。所以，**任务类服务中的work线程不适合被创建成守护线程**，守护线程适合做一些没有生命周期属性的工作。\n\n### finalizer\n\nfinalizer被JVM在单独上执行，所以需要是线程安全的；其被执行的时间、和是否会被执行都不确定。基于finalizer要求线程安全，重载finalizer的类会增加额外的同步，从而影响性能；同时finalizer很难被正确的编写；所以**尽量避免使用finalizer**\n\n一个使用finalizer的例外是，在finalizer中检查对象是否已经释放其持有的资源，否则输出错误提示。\n\n\n\n","slug":"JCIP-chapter7-cancellation-and-shutdown","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4oz000j3mrf7v0i76lj","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>中止线程比启动线程要复杂，Java没有提供之间中止线程的机制(初期的中止线程方法被弃用)，而是提供了interruption机制提醒线程自己进行中止。用interruption机制来代替中止线程的原因是，如果线程被类似stop()的方法立即中止可能会打断正在进行的操作，而使变量处于非法的状态。</p>\n<h2 id=\"任务中止\"><a href=\"#任务中止\" class=\"headerlink\" title=\"任务中止\"></a>任务中止</h2><p>中止任务的需求有很多，例如用户请求、任务时限、发生错误、服务关闭等情况。没有主动中止任务方法情况下–就像Java–可以通过设置中止标志位，并由任务代码自身定期检查中止标志来执行中止；interruption机制正是使用了类似中止标志位的协议。</p>\n<h3 id=\"中断-Interruption\"><a href=\"#中断-Interruption\" class=\"headerlink\" title=\"中断(Interruption)\"></a>中断(Interruption)</h3><p>Interruption是一个线程通过Interrupted标志位通知另一个线程的一种线程间交流机制，Interruption不一定要和中止线程的语意绑定，然而在实践中Interruption通常只用于中止线程的场景；将Interruption用于中止线程以外的场景，都被证明会使程序变得脆弱且难以维护。</p>\n<p>每个线程都有一个interrupted标志位，interrupt某个线程就是将其interrupted置为true。Thread.interrupt()、Thread.isInterrupted()、Thread.interrupted()是与Interruption机制相关的三个方法。<br>其中Thread.interrupted()容易使人迷惑，他会返回interrupted标志位<strong>并将其置为false</strong>，这也是唯一将interrupted标志位置回false的方法。</p>\n<p>Java库中对interruption的响应方式是将interrupted置回false，并抛出InterruptedException。</p>\n<h3 id=\"中断策略\"><a href=\"#中断策略\" class=\"headerlink\" title=\"中断策略\"></a>中断策略</h3><p>通常来说，任务执行代码不应该假设其被执行的线程的中断策略，因为任务执行代码很可能在线程池的worker线程中被执行；所以在任务处理中断并中止任务后，应当保留当前线程的被中断状态(抛出InterruptedException或者保留interrupted为true)。</p>\n<p>线程的持有者应当将任务中止操作封装为类似cancel方法；与此同时非线程持有者在中止任务时应当调用封装方法，而不是直接Thread.interrupt();</p>\n<h3 id=\"响应中断\"><a href=\"#响应中断\" class=\"headerlink\" title=\"响应中断\"></a>响应中断</h3><p>处理InterruptedException的方法有两种，将InterruptedException抛出；或者将interrupted置为true。永远不要仅仅捕获InterruptedException并什么都不做。<br>线程拥有者通常是创建线程的对象，它通常还会继承Thread对象。只有线程的拥有者，才有权中止interrupted状态的传播；其他任务或者工具代码在处理中断时都应继续传播中断状态。</p>\n<h3 id=\"使用Future提供的中止任务的功能\"><a href=\"#使用Future提供的中止任务的功能\" class=\"headerlink\" title=\"使用Future提供的中止任务的功能\"></a>使用Future提供的中止任务的功能</h3><p>Future.canel(boolean)可以用于中止任务，其包含布尔型参数mayInterruptIfRunning代表cancel方法是否会中断worker线程。</p>\n<h3 id=\"处理不可中断的阻塞\"><a href=\"#处理不可中断的阻塞\" class=\"headerlink\" title=\"处理不可中断的阻塞\"></a>处理不可中断的阻塞</h3><p>有一些阻塞的操作不响应中断，需要采用其他的方法来中止这些操作：</p>\n<ul>\n<li>同步的IO操作，基于Socket的阻塞IO可以通过关闭Socket使其抛出SocketException来中止。</li>\n<li>等待获取内置锁，等待内置锁的阻塞是无解的，如果有中止的需求可以改用显式锁。</li>\n</ul>\n<h3 id=\"重写ThreadPoolExecutor的newTaskFor方法\"><a href=\"#重写ThreadPoolExecutor的newTaskFor方法\" class=\"headerlink\" title=\"重写ThreadPoolExecutor的newTaskFor方法\"></a>重写ThreadPoolExecutor的newTaskFor方法</h3><p>通过重写ThreadPoolExecutor的newTaskFor方法，可以返回自定义的FutureTask类；通过重写返回的FutureTask的cancel方法，可以hook中止任务的过程(例如加入关闭IO的操作)。</p>\n<h2 id=\"关闭服务-包含线程的服务\"><a href=\"#关闭服务-包含线程的服务\" class=\"headerlink\" title=\"关闭服务(包含线程的服务)\"></a>关闭服务(包含线程的服务)</h2><p>通常应用程序都会使用一些包含线程的服务(例如任务系统、线程池)，这些服务通常都是常驻内存的，所以在应用结束之前应当使用适当的方法来关闭这些服务，以防止线程泄漏。<br>中止线程的工作应该有线程的拥有者，也就是服务本身来完成，所以类似这些服务通常应该提供shutdown方法。ExecutorService就定义了shutdown和shutdownNow两个关闭方法。</p>\n<h3 id=\"一个Log服务\"><a href=\"#一个Log服务\" class=\"headerlink\" title=\"一个Log服务\"></a>一个Log服务</h3><p>本章将以一个使用单独线程的Log服务作例子，讲解关闭服务的方式。</p>\n<p>在实现关闭服务操作时，需要留意几个问题：</p>\n<ul>\n<li>是将现在正在排队的任务处理完再关闭服务(暂且称为安全关闭)，还是立即关闭服务。</li>\n<li>如何在关闭服务过程中，处理外部程序调用服务功能。</li>\n<li>在关闭服务时清理状态。</li>\n</ul>\n<p>在这一节，给出了一个利用请求计数实现安全关闭例子。</p>\n<h3 id=\"ExecutorService的关闭方法\"><a href=\"#ExecutorService的关闭方法\" class=\"headerlink\" title=\"ExecutorService的关闭方法\"></a>ExecutorService的关闭方法</h3><p>ExecutorService的showdown方法提供了安全关闭；showdownNow方法提供了立即关闭。</p>\n<p>这一节借助ExecutorService重写了Log服务，并利用ExecutorService的shutdown方法实现了安全关闭。</p>\n<h3 id=\"Poison-Pills\"><a href=\"#Poison-Pills\" class=\"headerlink\" title=\"Poison Pills\"></a>Poison Pills</h3><p>用于生产者消费者关系中的一种关闭方式，生产者在关闭之后将poison pill加入队列，消费者在获取到poison pill之后关闭自己。<br>poison pill方式只能用于生产者数量和消费者数量都确定的情况。</p>\n<h3 id=\"使用非常驻的ExecutorService\"><a href=\"#使用非常驻的ExecutorService\" class=\"headerlink\" title=\"使用非常驻的ExecutorService\"></a>使用非常驻的ExecutorService</h3><p>借助局部的ExecutorService，将所有任务submit之后执行shutdown和awaitTermination，可以达到等待所有任务完成之后再返回的效果。</p>\n<h3 id=\"showdownNow-立即关闭-的局限性\"><a href=\"#showdownNow-立即关闭-的局限性\" class=\"headerlink\" title=\"showdownNow(立即关闭)的局限性\"></a>showdownNow(立即关闭)的局限性</h3><p>ExecutorService的showdownNow方法会返回所有未完成任务的列表(Runnable的list)，但是无法区分哪些是还未开始的任务、哪些是执行到一半中止的任务。</p>\n<h2 id=\"处理线程的异常结束\"><a href=\"#处理线程的异常结束\" class=\"headerlink\" title=\"处理线程的异常结束\"></a>处理线程的异常结束</h2><p>线程可能会因为抛出异常(通常是RuntimeException)而提前结束，这种异常结束不易被其他线程发现(也许仅仅在控制台输出了异常栈)，从而产生了线程泄漏。</p>\n<p>一种简单处理方式，在worker线程中捕获类似Runnable.run()方法抛出的unchecked Exception、结束线程、并通知worker线程的拥有者(通常是某种Service)线程异常结束的消息；尽管这种捕获unchecked Exception方法的安全性存在争议。</p>\n<h3 id=\"Uncaught-exception-handler\"><a href=\"#Uncaught-exception-handler\" class=\"headerlink\" title=\"Uncaught exception handler\"></a>Uncaught exception handler</h3><p>Thread提供了UncaughtExceptionHandler相关的API，可以发现从线程中抛出的未捕获的异常。</p>\n<p>最好为所有常驻线程添加UncaughtExceptionHandler。</p>\n<h2 id=\"关闭JVM\"><a href=\"#关闭JVM\" class=\"headerlink\" title=\"关闭JVM\"></a>关闭JVM</h2><p>JVM有两种关闭方式：orderly或abrupt。<br>当JVM中最后一个非守护线程结束、System.exit或者其他关闭JVM的方法被调用时，触发orderly关闭；当Runtime.halt被调用或者关闭JVM进程时，触发abrupt关闭。</p>\n<p>在orderly关闭过程中，JVM首先会执行所有的Shutdown hook；然后可能会执行对象的finalizer；然后关闭JVM。orderly关闭发生时，JVM不会去中断任何正在执行的线程，这些线程运行直到JVM关闭时停止。<br>在abrupt关闭过程中，JVM直接停止其他什么都不做。</p>\n<h3 id=\"Shutdown-hook\"><a href=\"#Shutdown-hook\" class=\"headerlink\" title=\"Shutdown hook\"></a>Shutdown hook</h3><p>Shutdown hook时通过Runtime.addShutdownHook注册的；Shutdown hook运行在单独的线程中，所以需要是线程安全的。</p>\n<p>一种相对轻松的使用Shutdown hook方式是，整个应用仅使用一个Shutdown hook，将所有的关闭工作在这个Shutdown hook中按某种顺序执行。</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>JVM中的线程可以被分为两类，普通线程和守护线程，如果不想让某些常驻线程阻止JVM关闭，可以将这些线程设为守护线程；除了主线程之外，JVM启动时创建的所有线程都是守护线程。</p>\n<p>当线程被创建时，其守护属性默认继承创建它的线程的守护属性，所以普通线程创建的线程默认是普通线程，守护线程创建的线程默认是守护线程。</p>\n<p>守护线程可能在任何时刻突然停止，如果在守护线程中执行IO操作，那么就可能没有机会清理IO。所以，<strong>任务类服务中的work线程不适合被创建成守护线程</strong>，守护线程适合做一些没有生命周期属性的工作。</p>\n<h3 id=\"finalizer\"><a href=\"#finalizer\" class=\"headerlink\" title=\"finalizer\"></a>finalizer</h3><p>finalizer被JVM在单独上执行，所以需要是线程安全的；其被执行的时间、和是否会被执行都不确定。基于finalizer要求线程安全，重载finalizer的类会增加额外的同步，从而影响性能；同时finalizer很难被正确的编写；所以<strong>尽量避免使用finalizer</strong></p>\n<p>一个使用finalizer的例外是，在finalizer中检查对象是否已经释放其持有的资源，否则输出错误提示。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>中止线程比启动线程要复杂，Java没有提供之间中止线程的机制(初期的中止线程方法被弃用)，而是提供了interruption机制提醒线程自己进行中止。用interruption机制来代替中止线程的原因是，如果线程被类似stop()的方法立即中止可能会打断正在进行的操作，而使变量处于非法的状态。</p>\n<h2 id=\"任务中止\"><a href=\"#任务中止\" class=\"headerlink\" title=\"任务中止\"></a>任务中止</h2><p>中止任务的需求有很多，例如用户请求、任务时限、发生错误、服务关闭等情况。没有主动中止任务方法情况下–就像Java–可以通过设置中止标志位，并由任务代码自身定期检查中止标志来执行中止；interruption机制正是使用了类似中止标志位的协议。</p>\n<h3 id=\"中断-Interruption\"><a href=\"#中断-Interruption\" class=\"headerlink\" title=\"中断(Interruption)\"></a>中断(Interruption)</h3><p>Interruption是一个线程通过Interrupted标志位通知另一个线程的一种线程间交流机制，Interruption不一定要和中止线程的语意绑定，然而在实践中Interruption通常只用于中止线程的场景；将Interruption用于中止线程以外的场景，都被证明会使程序变得脆弱且难以维护。</p>\n<p>每个线程都有一个interrupted标志位，interrupt某个线程就是将其interrupted置为true。Thread.interrupt()、Thread.isInterrupted()、Thread.interrupted()是与Interruption机制相关的三个方法。<br>其中Thread.interrupted()容易使人迷惑，他会返回interrupted标志位<strong>并将其置为false</strong>，这也是唯一将interrupted标志位置回false的方法。</p>\n<p>Java库中对interruption的响应方式是将interrupted置回false，并抛出InterruptedException。</p>\n<h3 id=\"中断策略\"><a href=\"#中断策略\" class=\"headerlink\" title=\"中断策略\"></a>中断策略</h3><p>通常来说，任务执行代码不应该假设其被执行的线程的中断策略，因为任务执行代码很可能在线程池的worker线程中被执行；所以在任务处理中断并中止任务后，应当保留当前线程的被中断状态(抛出InterruptedException或者保留interrupted为true)。</p>\n<p>线程的持有者应当将任务中止操作封装为类似cancel方法；与此同时非线程持有者在中止任务时应当调用封装方法，而不是直接Thread.interrupt();</p>\n<h3 id=\"响应中断\"><a href=\"#响应中断\" class=\"headerlink\" title=\"响应中断\"></a>响应中断</h3><p>处理InterruptedException的方法有两种，将InterruptedException抛出；或者将interrupted置为true。永远不要仅仅捕获InterruptedException并什么都不做。<br>线程拥有者通常是创建线程的对象，它通常还会继承Thread对象。只有线程的拥有者，才有权中止interrupted状态的传播；其他任务或者工具代码在处理中断时都应继续传播中断状态。</p>\n<h3 id=\"使用Future提供的中止任务的功能\"><a href=\"#使用Future提供的中止任务的功能\" class=\"headerlink\" title=\"使用Future提供的中止任务的功能\"></a>使用Future提供的中止任务的功能</h3><p>Future.canel(boolean)可以用于中止任务，其包含布尔型参数mayInterruptIfRunning代表cancel方法是否会中断worker线程。</p>\n<h3 id=\"处理不可中断的阻塞\"><a href=\"#处理不可中断的阻塞\" class=\"headerlink\" title=\"处理不可中断的阻塞\"></a>处理不可中断的阻塞</h3><p>有一些阻塞的操作不响应中断，需要采用其他的方法来中止这些操作：</p>\n<ul>\n<li>同步的IO操作，基于Socket的阻塞IO可以通过关闭Socket使其抛出SocketException来中止。</li>\n<li>等待获取内置锁，等待内置锁的阻塞是无解的，如果有中止的需求可以改用显式锁。</li>\n</ul>\n<h3 id=\"重写ThreadPoolExecutor的newTaskFor方法\"><a href=\"#重写ThreadPoolExecutor的newTaskFor方法\" class=\"headerlink\" title=\"重写ThreadPoolExecutor的newTaskFor方法\"></a>重写ThreadPoolExecutor的newTaskFor方法</h3><p>通过重写ThreadPoolExecutor的newTaskFor方法，可以返回自定义的FutureTask类；通过重写返回的FutureTask的cancel方法，可以hook中止任务的过程(例如加入关闭IO的操作)。</p>\n<h2 id=\"关闭服务-包含线程的服务\"><a href=\"#关闭服务-包含线程的服务\" class=\"headerlink\" title=\"关闭服务(包含线程的服务)\"></a>关闭服务(包含线程的服务)</h2><p>通常应用程序都会使用一些包含线程的服务(例如任务系统、线程池)，这些服务通常都是常驻内存的，所以在应用结束之前应当使用适当的方法来关闭这些服务，以防止线程泄漏。<br>中止线程的工作应该有线程的拥有者，也就是服务本身来完成，所以类似这些服务通常应该提供shutdown方法。ExecutorService就定义了shutdown和shutdownNow两个关闭方法。</p>\n<h3 id=\"一个Log服务\"><a href=\"#一个Log服务\" class=\"headerlink\" title=\"一个Log服务\"></a>一个Log服务</h3><p>本章将以一个使用单独线程的Log服务作例子，讲解关闭服务的方式。</p>\n<p>在实现关闭服务操作时，需要留意几个问题：</p>\n<ul>\n<li>是将现在正在排队的任务处理完再关闭服务(暂且称为安全关闭)，还是立即关闭服务。</li>\n<li>如何在关闭服务过程中，处理外部程序调用服务功能。</li>\n<li>在关闭服务时清理状态。</li>\n</ul>\n<p>在这一节，给出了一个利用请求计数实现安全关闭例子。</p>\n<h3 id=\"ExecutorService的关闭方法\"><a href=\"#ExecutorService的关闭方法\" class=\"headerlink\" title=\"ExecutorService的关闭方法\"></a>ExecutorService的关闭方法</h3><p>ExecutorService的showdown方法提供了安全关闭；showdownNow方法提供了立即关闭。</p>\n<p>这一节借助ExecutorService重写了Log服务，并利用ExecutorService的shutdown方法实现了安全关闭。</p>\n<h3 id=\"Poison-Pills\"><a href=\"#Poison-Pills\" class=\"headerlink\" title=\"Poison Pills\"></a>Poison Pills</h3><p>用于生产者消费者关系中的一种关闭方式，生产者在关闭之后将poison pill加入队列，消费者在获取到poison pill之后关闭自己。<br>poison pill方式只能用于生产者数量和消费者数量都确定的情况。</p>\n<h3 id=\"使用非常驻的ExecutorService\"><a href=\"#使用非常驻的ExecutorService\" class=\"headerlink\" title=\"使用非常驻的ExecutorService\"></a>使用非常驻的ExecutorService</h3><p>借助局部的ExecutorService，将所有任务submit之后执行shutdown和awaitTermination，可以达到等待所有任务完成之后再返回的效果。</p>\n<h3 id=\"showdownNow-立即关闭-的局限性\"><a href=\"#showdownNow-立即关闭-的局限性\" class=\"headerlink\" title=\"showdownNow(立即关闭)的局限性\"></a>showdownNow(立即关闭)的局限性</h3><p>ExecutorService的showdownNow方法会返回所有未完成任务的列表(Runnable的list)，但是无法区分哪些是还未开始的任务、哪些是执行到一半中止的任务。</p>\n<h2 id=\"处理线程的异常结束\"><a href=\"#处理线程的异常结束\" class=\"headerlink\" title=\"处理线程的异常结束\"></a>处理线程的异常结束</h2><p>线程可能会因为抛出异常(通常是RuntimeException)而提前结束，这种异常结束不易被其他线程发现(也许仅仅在控制台输出了异常栈)，从而产生了线程泄漏。</p>\n<p>一种简单处理方式，在worker线程中捕获类似Runnable.run()方法抛出的unchecked Exception、结束线程、并通知worker线程的拥有者(通常是某种Service)线程异常结束的消息；尽管这种捕获unchecked Exception方法的安全性存在争议。</p>\n<h3 id=\"Uncaught-exception-handler\"><a href=\"#Uncaught-exception-handler\" class=\"headerlink\" title=\"Uncaught exception handler\"></a>Uncaught exception handler</h3><p>Thread提供了UncaughtExceptionHandler相关的API，可以发现从线程中抛出的未捕获的异常。</p>\n<p>最好为所有常驻线程添加UncaughtExceptionHandler。</p>\n<h2 id=\"关闭JVM\"><a href=\"#关闭JVM\" class=\"headerlink\" title=\"关闭JVM\"></a>关闭JVM</h2><p>JVM有两种关闭方式：orderly或abrupt。<br>当JVM中最后一个非守护线程结束、System.exit或者其他关闭JVM的方法被调用时，触发orderly关闭；当Runtime.halt被调用或者关闭JVM进程时，触发abrupt关闭。</p>\n<p>在orderly关闭过程中，JVM首先会执行所有的Shutdown hook；然后可能会执行对象的finalizer；然后关闭JVM。orderly关闭发生时，JVM不会去中断任何正在执行的线程，这些线程运行直到JVM关闭时停止。<br>在abrupt关闭过程中，JVM直接停止其他什么都不做。</p>\n<h3 id=\"Shutdown-hook\"><a href=\"#Shutdown-hook\" class=\"headerlink\" title=\"Shutdown hook\"></a>Shutdown hook</h3><p>Shutdown hook时通过Runtime.addShutdownHook注册的；Shutdown hook运行在单独的线程中，所以需要是线程安全的。</p>\n<p>一种相对轻松的使用Shutdown hook方式是，整个应用仅使用一个Shutdown hook，将所有的关闭工作在这个Shutdown hook中按某种顺序执行。</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>JVM中的线程可以被分为两类，普通线程和守护线程，如果不想让某些常驻线程阻止JVM关闭，可以将这些线程设为守护线程；除了主线程之外，JVM启动时创建的所有线程都是守护线程。</p>\n<p>当线程被创建时，其守护属性默认继承创建它的线程的守护属性，所以普通线程创建的线程默认是普通线程，守护线程创建的线程默认是守护线程。</p>\n<p>守护线程可能在任何时刻突然停止，如果在守护线程中执行IO操作，那么就可能没有机会清理IO。所以，<strong>任务类服务中的work线程不适合被创建成守护线程</strong>，守护线程适合做一些没有生命周期属性的工作。</p>\n<h3 id=\"finalizer\"><a href=\"#finalizer\" class=\"headerlink\" title=\"finalizer\"></a>finalizer</h3><p>finalizer被JVM在单独上执行，所以需要是线程安全的；其被执行的时间、和是否会被执行都不确定。基于finalizer要求线程安全，重载finalizer的类会增加额外的同步，从而影响性能；同时finalizer很难被正确的编写；所以<strong>尽量避免使用finalizer</strong></p>\n<p>一个使用finalizer的例外是，在finalizer中检查对象是否已经释放其持有的资源，否则输出错误提示。</p>\n"},{"title":"Android Developer Guide中的Activity","subtitle":"Android官方guide随笔 - App Components：Activity","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-08-03T07:30:44.000Z","_content":"\n\n## 展开点   \n\n* [Things That Cannot Change](https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html)。\n* AsyncQueryHandler。\n* [Multitasking the Android Way](https://android-developers.googleblog.com/2010/04/multitasking-android-way.html)。\n* Activity‘s Task in Detail。\n* allowTaskReparenting的应用场景。\n* Parcel in Detail。\n* [Document-centric model](https://plus.google.com/+DianneHackborn/posts/4QWEQgkB1v2)。\n* ActivityManager.AppTask。\n\n## Caution   \n* Activity的android:name一旦被声明之后，再后续更新中不应改变，否则一些功能例如shortcut会出错。详见[Things That Cannot Change](https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html)。\n* Activity.isFinish()可以用来判断finish()方法是否被调用过（例如在onPause、onStop这些callback里面）。\n* 如果startActivityForResult()启动的Activity异常退出，发出请求的Activity会收到RESULT_CANCELED。\n* 由Intent指定的launchMode的优先级高于（会覆盖）在manifest中声明的launchMode。\n* 7.0以上的系统中，通过Intent传递的数据过大会抛出TransactionTooLargeException异常；7.0以下仅在logcat中输出警告。这个限制的根源是，Binder transaction buffer通常有1MB左右的大小限制，每个进程有单独的Binder transaction buffer，buffer被进程内的所有binder transactions共享。\n\n\n## Introduction to Activities    \n\n这一节介绍了Activity的概念，给初学者关于Activity大致的印象。并对如何在Manifest中声明Activity进行说明，并简述了Activity的生命周期。\n\n### Activity的概念\n\nActivity是什么我们都是知道的。\n\n### 在Manifest中声明Activity\n\n通过在Manifest中声明`<activity>`标签来声明Activity。`<activity>`标签中唯一的必填属性是android:name；`<activity>`可以包含`<intent-filter>`标签；可以通过`<activity>`标签的android:permission属性来声明使用activity所需的权限。\n\n## The Activity Lifecycle\n\n管理Activity生命周期的关键，是在正确的生命周期回调中作正确的事。\n\n本节介绍了Activity生命周期的概念、各个生命周期回调、提及了Activity状态和系统杀进程间的关系、以及保存Activity状态的方法。\n\n### Activity生命周期的概念   \n\nActivity生命周期包括了Activity的状态转移和6个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop()、onDestroy()。\n\n家喻户晓的Activity状态转移图：   \n![Activity状态转移图](https://developer.android.google.cn/guide/components/images/activity_lifecycle.png) \n\n### 生命周期回调   \n\n**onCreate**\n当Activity进入*Created*状态之后，onCreate被回调。savedInstanceState会做为参数传入onCreate中，和传入onRestoreInstanceState()的savedInstanceState是同一个Bundle对象。\n在onCreate中，适宜做一些初始化工作（初始化变量、启动线程、初始化UI对象）以及调用setContentView()。\n\n**onStart**\n当Activity进入*Started*状态之后（进入可视范围），onStart被回调。\n在onStart中，适宜注册各类监听（listener和Receiver）、同步UI；重建在onStop中释放的对象。\n\n**onResume**\n当Activity进入*Resumed*状态之后，即成为当前活跃的Activity之后，onResume被回调。\n在onResume中，适宜启动动画，以及Activity进入活跃状态才开启的工作；重建在onPause中释放的对象。\n\n**onPause**\n当Activity进入*Paused*状态，即离开活跃状态，onPause被回调。\n在onPause中应该停止动画、暂停音视频播放等；同时释放在Paused状态下不需要的资源（例如sensors）以节约耗电。\n\n**onStop**\n当Activity进入*Stopped*状态，即完全不可见状态，onStop被回调。\n在onStop中应该释放所有可能造成内存泄露的资源，因为在进程被系统回收时onDestroy不保证被调用；同时在onStop中适宜进行结束前的持久化工作。 \n\n**onDestroy**\n在Activity被销毁之前回调，在这里可以释放在onStop没被释放的资源（那些不会泄露的资源）。\n\n### 进程回收与Activity状态\n\nAndroid系统的资源回收是以进程为单位，不会单独作用于Activity。但是Activity状态回影响进程回收优先级，进程回收优先级从高到低为 Destroyed > Stopped > Pauseed > Created & Started & Resumed。\n\n### 启动其他Activity\n\nonActivityResult的参数ResultCode可以使用RESULT_CANCELED、RESULT_OK以外的自定义值，自定义的ResultCode应当大于整型常量RESULT_FIRST_USER。\n\n当Activity A 启动 Activity B时，生命周期回调顺序如下：   \nActivity A的onPause() -> Activity B的onCreate()、onStart()、onResume() -> Activity A的onStop()。\n\n### 保存和恢复Activity状态\n\n系统会对Activity进行状态保存及恢复的情况有两种，因进程回收销毁Activity和因configuration变化销毁Activity。\n当Activity的状态保存被触发时，系统会用一个Bundle对象（即SaveInstanceState）来保存Activity状态，以便再次进入Activity时通过这个Bundle对象恢复Activity状态。\n依靠默认行为，Activity会保存和恢复View的状态。\n\nActivity通过onSaveInstanceState()方法保存状态，重写它时需要调用super，super方法里会进行保存View状态发生的工作。\n\nSaveInstanceState会作为参数传递给onCreate()和onRestoreInstanceState()。onRestoreInstanceState()的调用顺序在onStart()之后，重写它时需要调用super，和onSaveInstanceState()同理。\n\nonSaveInstanceState()大概是在onPause和onStop之间调用，onRestoreInstanceState()在onStart()之后被调用。\n\n## Activity State Changes\n\n本节列出了一些会造成Activity状态发生改变的情况。\n\n* Configuration change，会引发Activity的销毁和重建，为了应对Configuration change应该实现onSaveInstanceState()来保存恢复状态。\n* 7.0以上推出的multi-window模式。\n* 新的Activity或Dialog被激活。\n* 用户按下Back按键，按照默认行为会销毁当前Activity（如果没有Fragment从中作梗）。\n\n## Tasks and Back Stack\n\n本节讲解Task的概念，以及一些通过Manifest和Intent Flag变更Task和Back Stack默认行为方法。\n\n### 定义Launch Mode\n\n定义Activity的Launch Mode的方式有两种，在Manifest中或通过Intent Flag。在Intent Flag中定义的Launch Mode会覆盖Manifest中的定义。\n\nManifest中`<activity>`标签的launchMode属性可以定义著名的四种launchMode：\n\n* standard，就如同Android系统的默认行为，也是launchMode的默认值。\n* singleTop，Activity如果在当前Task的顶部，则不会新建Activity而是调用已有Activity的onNewIntent()。\n* singleTask，Activity会被创建在一个新的Task中，但如果Activity已经存在于某个Task中则不会新建Activity而是调用已有Activity的onNewIntent()。同一时间singleTask的Activity仅会有一个实例。\n* singleInstance，跟singleTask一样除了Activity会独占Task。\n\n通过Intent Flag中可以定义如下Launch Mode：   \n\n* FLAG_ACTIVITY_NEW_TASK，和singleTask一致。\n* FLAG_ACTIVITY_SINGLE_TOP，和singleTop一致。\n* FLAG_ACTIVITY_CLEAR_TOP，如果Activity存在于当前Task则不会新建，并且销毁所有在Back Stack中位于其之上的Activity，常与FLAG_ACTIVITY_NEW_TASK一起使用。如果Activity的launchMode是standard的，那么Activity会在Back Stack的原位置上销毁并重建。\n\n### affinity   \n\naffinity代表Activity倾向于存在的Task，默认情况下同一个App的所有Activity的affinity相同。\n开发者可以通过`<activity>`标签中的taskAffinity的属性来修改affinity，Activity的affinity的默认值为包名。\n\naffinity发生作用的两个场景：   \n\n* 当以 FLAG_ACTIVITY_NEW_TASK 启动Activity时，Activity会在一个“新”Task中启动。实际情况是，如果已经存在一个和Activity具有相同affinity的Task存在，那么Activity会在那个Task中启动；否则才会新建一个Task。\n* 当Activity的 allowTaskReparenting 属性被设为true时，如果Activity原本不存在于其affinity Task中，当它的affinity Task激活时，Activity会被移动到affinity Task中。\n\n### 清理Back Stack   \n\n当Task太久没被激活时，系统会清理除了Task Root以外的所有Activity（真的吗？），有一下几个标志位可以控制清理Back Stack的行为。\n\n* alwaysRetainTaskState，当Task的root Actvity包含该标志位时，默认的清理Back Stack行为不会发生。\n* clearTaskOnLaunch，和 alwaysRetainTaskState 刚好相反，当Task的root Actvity包含该标志位时，一旦用户离开这个Task，默认的清理Back Stack行为马上发生。\n* finishOnTaskLaunch，该标志作用于单个Activity，当用户离开Task之后，Task中包含该标志位的Activity会从Back Stack中移除。\n\n## Processes and Application Lifecycle\n\n本节介绍进程回收时，系统判定不同进程的优先级。\n\n进程重要程度降序如下：\n\n* 前台进程(foreground process)，包括处于Resumed(Created、Started)状态的Activity；生命周期回调正在执行的Activity、Service；onReceive()正在执行的BroadcastReceiver。\n* 可见进程(visible process)，包括处于Paused状态的Activity；由Service.startForeground()启动的Service等。\n* 服务进程(service proces)，通过startService()启动的Service。当Service运行超过30分钟之后，服务进程可能会被降级成缓存进程(cached process)。\n* 缓存进程(cached process)，包括处于Stopped状态的Activity。缓存进程由LRU列表管理，随时可能会被杀死。\n* 空进程(empty process)。\n\n## Parcelables and Bundles   \n\nParcelable对象和Bundle是设计用于在进程间传递信息的数据结构，Android的进程间通信是通过Binder transaction完成。\n\n## Recents Screen\n\nTODO。\n\n\n\n","source":"_posts/android-developers-guide-note-app-components-activity.md","raw":"---\ntitle: Android Developer Guide中的Activity\nsubtitle: Android官方guide随笔 - App Components：Activity\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-08-03 15:30:44\n---\n\n\n## 展开点   \n\n* [Things That Cannot Change](https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html)。\n* AsyncQueryHandler。\n* [Multitasking the Android Way](https://android-developers.googleblog.com/2010/04/multitasking-android-way.html)。\n* Activity‘s Task in Detail。\n* allowTaskReparenting的应用场景。\n* Parcel in Detail。\n* [Document-centric model](https://plus.google.com/+DianneHackborn/posts/4QWEQgkB1v2)。\n* ActivityManager.AppTask。\n\n## Caution   \n* Activity的android:name一旦被声明之后，再后续更新中不应改变，否则一些功能例如shortcut会出错。详见[Things That Cannot Change](https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html)。\n* Activity.isFinish()可以用来判断finish()方法是否被调用过（例如在onPause、onStop这些callback里面）。\n* 如果startActivityForResult()启动的Activity异常退出，发出请求的Activity会收到RESULT_CANCELED。\n* 由Intent指定的launchMode的优先级高于（会覆盖）在manifest中声明的launchMode。\n* 7.0以上的系统中，通过Intent传递的数据过大会抛出TransactionTooLargeException异常；7.0以下仅在logcat中输出警告。这个限制的根源是，Binder transaction buffer通常有1MB左右的大小限制，每个进程有单独的Binder transaction buffer，buffer被进程内的所有binder transactions共享。\n\n\n## Introduction to Activities    \n\n这一节介绍了Activity的概念，给初学者关于Activity大致的印象。并对如何在Manifest中声明Activity进行说明，并简述了Activity的生命周期。\n\n### Activity的概念\n\nActivity是什么我们都是知道的。\n\n### 在Manifest中声明Activity\n\n通过在Manifest中声明`<activity>`标签来声明Activity。`<activity>`标签中唯一的必填属性是android:name；`<activity>`可以包含`<intent-filter>`标签；可以通过`<activity>`标签的android:permission属性来声明使用activity所需的权限。\n\n## The Activity Lifecycle\n\n管理Activity生命周期的关键，是在正确的生命周期回调中作正确的事。\n\n本节介绍了Activity生命周期的概念、各个生命周期回调、提及了Activity状态和系统杀进程间的关系、以及保存Activity状态的方法。\n\n### Activity生命周期的概念   \n\nActivity生命周期包括了Activity的状态转移和6个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop()、onDestroy()。\n\n家喻户晓的Activity状态转移图：   \n![Activity状态转移图](https://developer.android.google.cn/guide/components/images/activity_lifecycle.png) \n\n### 生命周期回调   \n\n**onCreate**\n当Activity进入*Created*状态之后，onCreate被回调。savedInstanceState会做为参数传入onCreate中，和传入onRestoreInstanceState()的savedInstanceState是同一个Bundle对象。\n在onCreate中，适宜做一些初始化工作（初始化变量、启动线程、初始化UI对象）以及调用setContentView()。\n\n**onStart**\n当Activity进入*Started*状态之后（进入可视范围），onStart被回调。\n在onStart中，适宜注册各类监听（listener和Receiver）、同步UI；重建在onStop中释放的对象。\n\n**onResume**\n当Activity进入*Resumed*状态之后，即成为当前活跃的Activity之后，onResume被回调。\n在onResume中，适宜启动动画，以及Activity进入活跃状态才开启的工作；重建在onPause中释放的对象。\n\n**onPause**\n当Activity进入*Paused*状态，即离开活跃状态，onPause被回调。\n在onPause中应该停止动画、暂停音视频播放等；同时释放在Paused状态下不需要的资源（例如sensors）以节约耗电。\n\n**onStop**\n当Activity进入*Stopped*状态，即完全不可见状态，onStop被回调。\n在onStop中应该释放所有可能造成内存泄露的资源，因为在进程被系统回收时onDestroy不保证被调用；同时在onStop中适宜进行结束前的持久化工作。 \n\n**onDestroy**\n在Activity被销毁之前回调，在这里可以释放在onStop没被释放的资源（那些不会泄露的资源）。\n\n### 进程回收与Activity状态\n\nAndroid系统的资源回收是以进程为单位，不会单独作用于Activity。但是Activity状态回影响进程回收优先级，进程回收优先级从高到低为 Destroyed > Stopped > Pauseed > Created & Started & Resumed。\n\n### 启动其他Activity\n\nonActivityResult的参数ResultCode可以使用RESULT_CANCELED、RESULT_OK以外的自定义值，自定义的ResultCode应当大于整型常量RESULT_FIRST_USER。\n\n当Activity A 启动 Activity B时，生命周期回调顺序如下：   \nActivity A的onPause() -> Activity B的onCreate()、onStart()、onResume() -> Activity A的onStop()。\n\n### 保存和恢复Activity状态\n\n系统会对Activity进行状态保存及恢复的情况有两种，因进程回收销毁Activity和因configuration变化销毁Activity。\n当Activity的状态保存被触发时，系统会用一个Bundle对象（即SaveInstanceState）来保存Activity状态，以便再次进入Activity时通过这个Bundle对象恢复Activity状态。\n依靠默认行为，Activity会保存和恢复View的状态。\n\nActivity通过onSaveInstanceState()方法保存状态，重写它时需要调用super，super方法里会进行保存View状态发生的工作。\n\nSaveInstanceState会作为参数传递给onCreate()和onRestoreInstanceState()。onRestoreInstanceState()的调用顺序在onStart()之后，重写它时需要调用super，和onSaveInstanceState()同理。\n\nonSaveInstanceState()大概是在onPause和onStop之间调用，onRestoreInstanceState()在onStart()之后被调用。\n\n## Activity State Changes\n\n本节列出了一些会造成Activity状态发生改变的情况。\n\n* Configuration change，会引发Activity的销毁和重建，为了应对Configuration change应该实现onSaveInstanceState()来保存恢复状态。\n* 7.0以上推出的multi-window模式。\n* 新的Activity或Dialog被激活。\n* 用户按下Back按键，按照默认行为会销毁当前Activity（如果没有Fragment从中作梗）。\n\n## Tasks and Back Stack\n\n本节讲解Task的概念，以及一些通过Manifest和Intent Flag变更Task和Back Stack默认行为方法。\n\n### 定义Launch Mode\n\n定义Activity的Launch Mode的方式有两种，在Manifest中或通过Intent Flag。在Intent Flag中定义的Launch Mode会覆盖Manifest中的定义。\n\nManifest中`<activity>`标签的launchMode属性可以定义著名的四种launchMode：\n\n* standard，就如同Android系统的默认行为，也是launchMode的默认值。\n* singleTop，Activity如果在当前Task的顶部，则不会新建Activity而是调用已有Activity的onNewIntent()。\n* singleTask，Activity会被创建在一个新的Task中，但如果Activity已经存在于某个Task中则不会新建Activity而是调用已有Activity的onNewIntent()。同一时间singleTask的Activity仅会有一个实例。\n* singleInstance，跟singleTask一样除了Activity会独占Task。\n\n通过Intent Flag中可以定义如下Launch Mode：   \n\n* FLAG_ACTIVITY_NEW_TASK，和singleTask一致。\n* FLAG_ACTIVITY_SINGLE_TOP，和singleTop一致。\n* FLAG_ACTIVITY_CLEAR_TOP，如果Activity存在于当前Task则不会新建，并且销毁所有在Back Stack中位于其之上的Activity，常与FLAG_ACTIVITY_NEW_TASK一起使用。如果Activity的launchMode是standard的，那么Activity会在Back Stack的原位置上销毁并重建。\n\n### affinity   \n\naffinity代表Activity倾向于存在的Task，默认情况下同一个App的所有Activity的affinity相同。\n开发者可以通过`<activity>`标签中的taskAffinity的属性来修改affinity，Activity的affinity的默认值为包名。\n\naffinity发生作用的两个场景：   \n\n* 当以 FLAG_ACTIVITY_NEW_TASK 启动Activity时，Activity会在一个“新”Task中启动。实际情况是，如果已经存在一个和Activity具有相同affinity的Task存在，那么Activity会在那个Task中启动；否则才会新建一个Task。\n* 当Activity的 allowTaskReparenting 属性被设为true时，如果Activity原本不存在于其affinity Task中，当它的affinity Task激活时，Activity会被移动到affinity Task中。\n\n### 清理Back Stack   \n\n当Task太久没被激活时，系统会清理除了Task Root以外的所有Activity（真的吗？），有一下几个标志位可以控制清理Back Stack的行为。\n\n* alwaysRetainTaskState，当Task的root Actvity包含该标志位时，默认的清理Back Stack行为不会发生。\n* clearTaskOnLaunch，和 alwaysRetainTaskState 刚好相反，当Task的root Actvity包含该标志位时，一旦用户离开这个Task，默认的清理Back Stack行为马上发生。\n* finishOnTaskLaunch，该标志作用于单个Activity，当用户离开Task之后，Task中包含该标志位的Activity会从Back Stack中移除。\n\n## Processes and Application Lifecycle\n\n本节介绍进程回收时，系统判定不同进程的优先级。\n\n进程重要程度降序如下：\n\n* 前台进程(foreground process)，包括处于Resumed(Created、Started)状态的Activity；生命周期回调正在执行的Activity、Service；onReceive()正在执行的BroadcastReceiver。\n* 可见进程(visible process)，包括处于Paused状态的Activity；由Service.startForeground()启动的Service等。\n* 服务进程(service proces)，通过startService()启动的Service。当Service运行超过30分钟之后，服务进程可能会被降级成缓存进程(cached process)。\n* 缓存进程(cached process)，包括处于Stopped状态的Activity。缓存进程由LRU列表管理，随时可能会被杀死。\n* 空进程(empty process)。\n\n## Parcelables and Bundles   \n\nParcelable对象和Bundle是设计用于在进程间传递信息的数据结构，Android的进程间通信是通过Binder transaction完成。\n\n## Recents Screen\n\nTODO。\n\n\n\n","slug":"android-developers-guide-note-app-components-activity","published":1,"updated":"2018-03-27T04:44:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p1000k3mrfejq98498","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html\">Things That Cannot Change</a>。</li>\n<li>AsyncQueryHandler。</li>\n<li><a href=\"https://android-developers.googleblog.com/2010/04/multitasking-android-way.html\">Multitasking the Android Way</a>。</li>\n<li>Activity‘s Task in Detail。</li>\n<li>allowTaskReparenting的应用场景。</li>\n<li>Parcel in Detail。</li>\n<li><a href=\"https://plus.google.com/+DianneHackborn/posts/4QWEQgkB1v2\">Document-centric model</a>。</li>\n<li>ActivityManager.AppTask。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>Activity的android:name一旦被声明之后，再后续更新中不应改变，否则一些功能例如shortcut会出错。详见<a href=\"https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html\">Things That Cannot Change</a>。</li>\n<li>Activity.isFinish()可以用来判断finish()方法是否被调用过（例如在onPause、onStop这些callback里面）。</li>\n<li>如果startActivityForResult()启动的Activity异常退出，发出请求的Activity会收到RESULT_CANCELED。</li>\n<li>由Intent指定的launchMode的优先级高于（会覆盖）在manifest中声明的launchMode。</li>\n<li>7.0以上的系统中，通过Intent传递的数据过大会抛出TransactionTooLargeException异常；7.0以下仅在logcat中输出警告。这个限制的根源是，Binder transaction buffer通常有1MB左右的大小限制，每个进程有单独的Binder transaction buffer，buffer被进程内的所有binder transactions共享。</li>\n</ul>\n<h2 id=\"Introduction-to-Activities\"><a href=\"#Introduction-to-Activities\" class=\"headerlink\" title=\"Introduction to Activities\"></a>Introduction to Activities</h2><p>这一节介绍了Activity的概念，给初学者关于Activity大致的印象。并对如何在Manifest中声明Activity进行说明，并简述了Activity的生命周期。</p>\n<h3 id=\"Activity的概念\"><a href=\"#Activity的概念\" class=\"headerlink\" title=\"Activity的概念\"></a>Activity的概念</h3><p>Activity是什么我们都是知道的。</p>\n<h3 id=\"在Manifest中声明Activity\"><a href=\"#在Manifest中声明Activity\" class=\"headerlink\" title=\"在Manifest中声明Activity\"></a>在Manifest中声明Activity</h3><p>通过在Manifest中声明<code>&lt;activity&gt;</code>标签来声明Activity。<code>&lt;activity&gt;</code>标签中唯一的必填属性是android:name；<code>&lt;activity&gt;</code>可以包含<code>&lt;intent-filter&gt;</code>标签；可以通过<code>&lt;activity&gt;</code>标签的android:permission属性来声明使用activity所需的权限。</p>\n<h2 id=\"The-Activity-Lifecycle\"><a href=\"#The-Activity-Lifecycle\" class=\"headerlink\" title=\"The Activity Lifecycle\"></a>The Activity Lifecycle</h2><p>管理Activity生命周期的关键，是在正确的生命周期回调中作正确的事。</p>\n<p>本节介绍了Activity生命周期的概念、各个生命周期回调、提及了Activity状态和系统杀进程间的关系、以及保存Activity状态的方法。</p>\n<h3 id=\"Activity生命周期的概念\"><a href=\"#Activity生命周期的概念\" class=\"headerlink\" title=\"Activity生命周期的概念\"></a>Activity生命周期的概念</h3><p>Activity生命周期包括了Activity的状态转移和6个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop()、onDestroy()。</p>\n<p>家喻户晓的Activity状态转移图：<br><img src=\"https://developer.android.google.cn/guide/components/images/activity_lifecycle.png\" alt=\"Activity状态转移图\"> </p>\n<h3 id=\"生命周期回调\"><a href=\"#生命周期回调\" class=\"headerlink\" title=\"生命周期回调\"></a>生命周期回调</h3><p><strong>onCreate</strong><br>当Activity进入<em>Created</em>状态之后，onCreate被回调。savedInstanceState会做为参数传入onCreate中，和传入onRestoreInstanceState()的savedInstanceState是同一个Bundle对象。<br>在onCreate中，适宜做一些初始化工作（初始化变量、启动线程、初始化UI对象）以及调用setContentView()。</p>\n<p><strong>onStart</strong><br>当Activity进入<em>Started</em>状态之后（进入可视范围），onStart被回调。<br>在onStart中，适宜注册各类监听（listener和Receiver）、同步UI；重建在onStop中释放的对象。</p>\n<p><strong>onResume</strong><br>当Activity进入<em>Resumed</em>状态之后，即成为当前活跃的Activity之后，onResume被回调。<br>在onResume中，适宜启动动画，以及Activity进入活跃状态才开启的工作；重建在onPause中释放的对象。</p>\n<p><strong>onPause</strong><br>当Activity进入<em>Paused</em>状态，即离开活跃状态，onPause被回调。<br>在onPause中应该停止动画、暂停音视频播放等；同时释放在Paused状态下不需要的资源（例如sensors）以节约耗电。</p>\n<p><strong>onStop</strong><br>当Activity进入<em>Stopped</em>状态，即完全不可见状态，onStop被回调。<br>在onStop中应该释放所有可能造成内存泄露的资源，因为在进程被系统回收时onDestroy不保证被调用；同时在onStop中适宜进行结束前的持久化工作。 </p>\n<p><strong>onDestroy</strong><br>在Activity被销毁之前回调，在这里可以释放在onStop没被释放的资源（那些不会泄露的资源）。</p>\n<h3 id=\"进程回收与Activity状态\"><a href=\"#进程回收与Activity状态\" class=\"headerlink\" title=\"进程回收与Activity状态\"></a>进程回收与Activity状态</h3><p>Android系统的资源回收是以进程为单位，不会单独作用于Activity。但是Activity状态回影响进程回收优先级，进程回收优先级从高到低为 Destroyed &gt; Stopped &gt; Pauseed &gt; Created &amp; Started &amp; Resumed。</p>\n<h3 id=\"启动其他Activity\"><a href=\"#启动其他Activity\" class=\"headerlink\" title=\"启动其他Activity\"></a>启动其他Activity</h3><p>onActivityResult的参数ResultCode可以使用RESULT_CANCELED、RESULT_OK以外的自定义值，自定义的ResultCode应当大于整型常量RESULT_FIRST_USER。</p>\n<p>当Activity A 启动 Activity B时，生命周期回调顺序如下：<br>Activity A的onPause() -&gt; Activity B的onCreate()、onStart()、onResume() -&gt; Activity A的onStop()。</p>\n<h3 id=\"保存和恢复Activity状态\"><a href=\"#保存和恢复Activity状态\" class=\"headerlink\" title=\"保存和恢复Activity状态\"></a>保存和恢复Activity状态</h3><p>系统会对Activity进行状态保存及恢复的情况有两种，因进程回收销毁Activity和因configuration变化销毁Activity。<br>当Activity的状态保存被触发时，系统会用一个Bundle对象（即SaveInstanceState）来保存Activity状态，以便再次进入Activity时通过这个Bundle对象恢复Activity状态。<br>依靠默认行为，Activity会保存和恢复View的状态。</p>\n<p>Activity通过onSaveInstanceState()方法保存状态，重写它时需要调用super，super方法里会进行保存View状态发生的工作。</p>\n<p>SaveInstanceState会作为参数传递给onCreate()和onRestoreInstanceState()。onRestoreInstanceState()的调用顺序在onStart()之后，重写它时需要调用super，和onSaveInstanceState()同理。</p>\n<p>onSaveInstanceState()大概是在onPause和onStop之间调用，onRestoreInstanceState()在onStart()之后被调用。</p>\n<h2 id=\"Activity-State-Changes\"><a href=\"#Activity-State-Changes\" class=\"headerlink\" title=\"Activity State Changes\"></a>Activity State Changes</h2><p>本节列出了一些会造成Activity状态发生改变的情况。</p>\n<ul>\n<li>Configuration change，会引发Activity的销毁和重建，为了应对Configuration change应该实现onSaveInstanceState()来保存恢复状态。</li>\n<li>7.0以上推出的multi-window模式。</li>\n<li>新的Activity或Dialog被激活。</li>\n<li>用户按下Back按键，按照默认行为会销毁当前Activity（如果没有Fragment从中作梗）。</li>\n</ul>\n<h2 id=\"Tasks-and-Back-Stack\"><a href=\"#Tasks-and-Back-Stack\" class=\"headerlink\" title=\"Tasks and Back Stack\"></a>Tasks and Back Stack</h2><p>本节讲解Task的概念，以及一些通过Manifest和Intent Flag变更Task和Back Stack默认行为方法。</p>\n<h3 id=\"定义Launch-Mode\"><a href=\"#定义Launch-Mode\" class=\"headerlink\" title=\"定义Launch Mode\"></a>定义Launch Mode</h3><p>定义Activity的Launch Mode的方式有两种，在Manifest中或通过Intent Flag。在Intent Flag中定义的Launch Mode会覆盖Manifest中的定义。</p>\n<p>Manifest中<code>&lt;activity&gt;</code>标签的launchMode属性可以定义著名的四种launchMode：</p>\n<ul>\n<li>standard，就如同Android系统的默认行为，也是launchMode的默认值。</li>\n<li>singleTop，Activity如果在当前Task的顶部，则不会新建Activity而是调用已有Activity的onNewIntent()。</li>\n<li>singleTask，Activity会被创建在一个新的Task中，但如果Activity已经存在于某个Task中则不会新建Activity而是调用已有Activity的onNewIntent()。同一时间singleTask的Activity仅会有一个实例。</li>\n<li>singleInstance，跟singleTask一样除了Activity会独占Task。</li>\n</ul>\n<p>通过Intent Flag中可以定义如下Launch Mode：   </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK，和singleTask一致。</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP，和singleTop一致。</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP，如果Activity存在于当前Task则不会新建，并且销毁所有在Back Stack中位于其之上的Activity，常与FLAG_ACTIVITY_NEW_TASK一起使用。如果Activity的launchMode是standard的，那么Activity会在Back Stack的原位置上销毁并重建。</li>\n</ul>\n<h3 id=\"affinity\"><a href=\"#affinity\" class=\"headerlink\" title=\"affinity\"></a>affinity</h3><p>affinity代表Activity倾向于存在的Task，默认情况下同一个App的所有Activity的affinity相同。<br>开发者可以通过<code>&lt;activity&gt;</code>标签中的taskAffinity的属性来修改affinity，Activity的affinity的默认值为包名。</p>\n<p>affinity发生作用的两个场景：   </p>\n<ul>\n<li>当以 FLAG_ACTIVITY_NEW_TASK 启动Activity时，Activity会在一个“新”Task中启动。实际情况是，如果已经存在一个和Activity具有相同affinity的Task存在，那么Activity会在那个Task中启动；否则才会新建一个Task。</li>\n<li>当Activity的 allowTaskReparenting 属性被设为true时，如果Activity原本不存在于其affinity Task中，当它的affinity Task激活时，Activity会被移动到affinity Task中。</li>\n</ul>\n<h3 id=\"清理Back-Stack\"><a href=\"#清理Back-Stack\" class=\"headerlink\" title=\"清理Back Stack\"></a>清理Back Stack</h3><p>当Task太久没被激活时，系统会清理除了Task Root以外的所有Activity（真的吗？），有一下几个标志位可以控制清理Back Stack的行为。</p>\n<ul>\n<li>alwaysRetainTaskState，当Task的root Actvity包含该标志位时，默认的清理Back Stack行为不会发生。</li>\n<li>clearTaskOnLaunch，和 alwaysRetainTaskState 刚好相反，当Task的root Actvity包含该标志位时，一旦用户离开这个Task，默认的清理Back Stack行为马上发生。</li>\n<li>finishOnTaskLaunch，该标志作用于单个Activity，当用户离开Task之后，Task中包含该标志位的Activity会从Back Stack中移除。</li>\n</ul>\n<h2 id=\"Processes-and-Application-Lifecycle\"><a href=\"#Processes-and-Application-Lifecycle\" class=\"headerlink\" title=\"Processes and Application Lifecycle\"></a>Processes and Application Lifecycle</h2><p>本节介绍进程回收时，系统判定不同进程的优先级。</p>\n<p>进程重要程度降序如下：</p>\n<ul>\n<li>前台进程(foreground process)，包括处于Resumed(Created、Started)状态的Activity；生命周期回调正在执行的Activity、Service；onReceive()正在执行的BroadcastReceiver。</li>\n<li>可见进程(visible process)，包括处于Paused状态的Activity；由Service.startForeground()启动的Service等。</li>\n<li>服务进程(service proces)，通过startService()启动的Service。当Service运行超过30分钟之后，服务进程可能会被降级成缓存进程(cached process)。</li>\n<li>缓存进程(cached process)，包括处于Stopped状态的Activity。缓存进程由LRU列表管理，随时可能会被杀死。</li>\n<li>空进程(empty process)。</li>\n</ul>\n<h2 id=\"Parcelables-and-Bundles\"><a href=\"#Parcelables-and-Bundles\" class=\"headerlink\" title=\"Parcelables and Bundles\"></a>Parcelables and Bundles</h2><p>Parcelable对象和Bundle是设计用于在进程间传递信息的数据结构，Android的进程间通信是通过Binder transaction完成。</p>\n<h2 id=\"Recents-Screen\"><a href=\"#Recents-Screen\" class=\"headerlink\" title=\"Recents Screen\"></a>Recents Screen</h2><p>TODO。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html\">Things That Cannot Change</a>。</li>\n<li>AsyncQueryHandler。</li>\n<li><a href=\"https://android-developers.googleblog.com/2010/04/multitasking-android-way.html\">Multitasking the Android Way</a>。</li>\n<li>Activity‘s Task in Detail。</li>\n<li>allowTaskReparenting的应用场景。</li>\n<li>Parcel in Detail。</li>\n<li><a href=\"https://plus.google.com/+DianneHackborn/posts/4QWEQgkB1v2\">Document-centric model</a>。</li>\n<li>ActivityManager.AppTask。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>Activity的android:name一旦被声明之后，再后续更新中不应改变，否则一些功能例如shortcut会出错。详见<a href=\"https://android-developers.googleblog.com/2011/06/things-that-cannot-change.html\">Things That Cannot Change</a>。</li>\n<li>Activity.isFinish()可以用来判断finish()方法是否被调用过（例如在onPause、onStop这些callback里面）。</li>\n<li>如果startActivityForResult()启动的Activity异常退出，发出请求的Activity会收到RESULT_CANCELED。</li>\n<li>由Intent指定的launchMode的优先级高于（会覆盖）在manifest中声明的launchMode。</li>\n<li>7.0以上的系统中，通过Intent传递的数据过大会抛出TransactionTooLargeException异常；7.0以下仅在logcat中输出警告。这个限制的根源是，Binder transaction buffer通常有1MB左右的大小限制，每个进程有单独的Binder transaction buffer，buffer被进程内的所有binder transactions共享。</li>\n</ul>\n<h2 id=\"Introduction-to-Activities\"><a href=\"#Introduction-to-Activities\" class=\"headerlink\" title=\"Introduction to Activities\"></a>Introduction to Activities</h2><p>这一节介绍了Activity的概念，给初学者关于Activity大致的印象。并对如何在Manifest中声明Activity进行说明，并简述了Activity的生命周期。</p>\n<h3 id=\"Activity的概念\"><a href=\"#Activity的概念\" class=\"headerlink\" title=\"Activity的概念\"></a>Activity的概念</h3><p>Activity是什么我们都是知道的。</p>\n<h3 id=\"在Manifest中声明Activity\"><a href=\"#在Manifest中声明Activity\" class=\"headerlink\" title=\"在Manifest中声明Activity\"></a>在Manifest中声明Activity</h3><p>通过在Manifest中声明<code>&lt;activity&gt;</code>标签来声明Activity。<code>&lt;activity&gt;</code>标签中唯一的必填属性是android:name；<code>&lt;activity&gt;</code>可以包含<code>&lt;intent-filter&gt;</code>标签；可以通过<code>&lt;activity&gt;</code>标签的android:permission属性来声明使用activity所需的权限。</p>\n<h2 id=\"The-Activity-Lifecycle\"><a href=\"#The-Activity-Lifecycle\" class=\"headerlink\" title=\"The Activity Lifecycle\"></a>The Activity Lifecycle</h2><p>管理Activity生命周期的关键，是在正确的生命周期回调中作正确的事。</p>\n<p>本节介绍了Activity生命周期的概念、各个生命周期回调、提及了Activity状态和系统杀进程间的关系、以及保存Activity状态的方法。</p>\n<h3 id=\"Activity生命周期的概念\"><a href=\"#Activity生命周期的概念\" class=\"headerlink\" title=\"Activity生命周期的概念\"></a>Activity生命周期的概念</h3><p>Activity生命周期包括了Activity的状态转移和6个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop()、onDestroy()。</p>\n<p>家喻户晓的Activity状态转移图：<br><img src=\"https://developer.android.google.cn/guide/components/images/activity_lifecycle.png\" alt=\"Activity状态转移图\"> </p>\n<h3 id=\"生命周期回调\"><a href=\"#生命周期回调\" class=\"headerlink\" title=\"生命周期回调\"></a>生命周期回调</h3><p><strong>onCreate</strong><br>当Activity进入<em>Created</em>状态之后，onCreate被回调。savedInstanceState会做为参数传入onCreate中，和传入onRestoreInstanceState()的savedInstanceState是同一个Bundle对象。<br>在onCreate中，适宜做一些初始化工作（初始化变量、启动线程、初始化UI对象）以及调用setContentView()。</p>\n<p><strong>onStart</strong><br>当Activity进入<em>Started</em>状态之后（进入可视范围），onStart被回调。<br>在onStart中，适宜注册各类监听（listener和Receiver）、同步UI；重建在onStop中释放的对象。</p>\n<p><strong>onResume</strong><br>当Activity进入<em>Resumed</em>状态之后，即成为当前活跃的Activity之后，onResume被回调。<br>在onResume中，适宜启动动画，以及Activity进入活跃状态才开启的工作；重建在onPause中释放的对象。</p>\n<p><strong>onPause</strong><br>当Activity进入<em>Paused</em>状态，即离开活跃状态，onPause被回调。<br>在onPause中应该停止动画、暂停音视频播放等；同时释放在Paused状态下不需要的资源（例如sensors）以节约耗电。</p>\n<p><strong>onStop</strong><br>当Activity进入<em>Stopped</em>状态，即完全不可见状态，onStop被回调。<br>在onStop中应该释放所有可能造成内存泄露的资源，因为在进程被系统回收时onDestroy不保证被调用；同时在onStop中适宜进行结束前的持久化工作。 </p>\n<p><strong>onDestroy</strong><br>在Activity被销毁之前回调，在这里可以释放在onStop没被释放的资源（那些不会泄露的资源）。</p>\n<h3 id=\"进程回收与Activity状态\"><a href=\"#进程回收与Activity状态\" class=\"headerlink\" title=\"进程回收与Activity状态\"></a>进程回收与Activity状态</h3><p>Android系统的资源回收是以进程为单位，不会单独作用于Activity。但是Activity状态回影响进程回收优先级，进程回收优先级从高到低为 Destroyed &gt; Stopped &gt; Pauseed &gt; Created &amp; Started &amp; Resumed。</p>\n<h3 id=\"启动其他Activity\"><a href=\"#启动其他Activity\" class=\"headerlink\" title=\"启动其他Activity\"></a>启动其他Activity</h3><p>onActivityResult的参数ResultCode可以使用RESULT_CANCELED、RESULT_OK以外的自定义值，自定义的ResultCode应当大于整型常量RESULT_FIRST_USER。</p>\n<p>当Activity A 启动 Activity B时，生命周期回调顺序如下：<br>Activity A的onPause() -&gt; Activity B的onCreate()、onStart()、onResume() -&gt; Activity A的onStop()。</p>\n<h3 id=\"保存和恢复Activity状态\"><a href=\"#保存和恢复Activity状态\" class=\"headerlink\" title=\"保存和恢复Activity状态\"></a>保存和恢复Activity状态</h3><p>系统会对Activity进行状态保存及恢复的情况有两种，因进程回收销毁Activity和因configuration变化销毁Activity。<br>当Activity的状态保存被触发时，系统会用一个Bundle对象（即SaveInstanceState）来保存Activity状态，以便再次进入Activity时通过这个Bundle对象恢复Activity状态。<br>依靠默认行为，Activity会保存和恢复View的状态。</p>\n<p>Activity通过onSaveInstanceState()方法保存状态，重写它时需要调用super，super方法里会进行保存View状态发生的工作。</p>\n<p>SaveInstanceState会作为参数传递给onCreate()和onRestoreInstanceState()。onRestoreInstanceState()的调用顺序在onStart()之后，重写它时需要调用super，和onSaveInstanceState()同理。</p>\n<p>onSaveInstanceState()大概是在onPause和onStop之间调用，onRestoreInstanceState()在onStart()之后被调用。</p>\n<h2 id=\"Activity-State-Changes\"><a href=\"#Activity-State-Changes\" class=\"headerlink\" title=\"Activity State Changes\"></a>Activity State Changes</h2><p>本节列出了一些会造成Activity状态发生改变的情况。</p>\n<ul>\n<li>Configuration change，会引发Activity的销毁和重建，为了应对Configuration change应该实现onSaveInstanceState()来保存恢复状态。</li>\n<li>7.0以上推出的multi-window模式。</li>\n<li>新的Activity或Dialog被激活。</li>\n<li>用户按下Back按键，按照默认行为会销毁当前Activity（如果没有Fragment从中作梗）。</li>\n</ul>\n<h2 id=\"Tasks-and-Back-Stack\"><a href=\"#Tasks-and-Back-Stack\" class=\"headerlink\" title=\"Tasks and Back Stack\"></a>Tasks and Back Stack</h2><p>本节讲解Task的概念，以及一些通过Manifest和Intent Flag变更Task和Back Stack默认行为方法。</p>\n<h3 id=\"定义Launch-Mode\"><a href=\"#定义Launch-Mode\" class=\"headerlink\" title=\"定义Launch Mode\"></a>定义Launch Mode</h3><p>定义Activity的Launch Mode的方式有两种，在Manifest中或通过Intent Flag。在Intent Flag中定义的Launch Mode会覆盖Manifest中的定义。</p>\n<p>Manifest中<code>&lt;activity&gt;</code>标签的launchMode属性可以定义著名的四种launchMode：</p>\n<ul>\n<li>standard，就如同Android系统的默认行为，也是launchMode的默认值。</li>\n<li>singleTop，Activity如果在当前Task的顶部，则不会新建Activity而是调用已有Activity的onNewIntent()。</li>\n<li>singleTask，Activity会被创建在一个新的Task中，但如果Activity已经存在于某个Task中则不会新建Activity而是调用已有Activity的onNewIntent()。同一时间singleTask的Activity仅会有一个实例。</li>\n<li>singleInstance，跟singleTask一样除了Activity会独占Task。</li>\n</ul>\n<p>通过Intent Flag中可以定义如下Launch Mode：   </p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK，和singleTask一致。</li>\n<li>FLAG_ACTIVITY_SINGLE_TOP，和singleTop一致。</li>\n<li>FLAG_ACTIVITY_CLEAR_TOP，如果Activity存在于当前Task则不会新建，并且销毁所有在Back Stack中位于其之上的Activity，常与FLAG_ACTIVITY_NEW_TASK一起使用。如果Activity的launchMode是standard的，那么Activity会在Back Stack的原位置上销毁并重建。</li>\n</ul>\n<h3 id=\"affinity\"><a href=\"#affinity\" class=\"headerlink\" title=\"affinity\"></a>affinity</h3><p>affinity代表Activity倾向于存在的Task，默认情况下同一个App的所有Activity的affinity相同。<br>开发者可以通过<code>&lt;activity&gt;</code>标签中的taskAffinity的属性来修改affinity，Activity的affinity的默认值为包名。</p>\n<p>affinity发生作用的两个场景：   </p>\n<ul>\n<li>当以 FLAG_ACTIVITY_NEW_TASK 启动Activity时，Activity会在一个“新”Task中启动。实际情况是，如果已经存在一个和Activity具有相同affinity的Task存在，那么Activity会在那个Task中启动；否则才会新建一个Task。</li>\n<li>当Activity的 allowTaskReparenting 属性被设为true时，如果Activity原本不存在于其affinity Task中，当它的affinity Task激活时，Activity会被移动到affinity Task中。</li>\n</ul>\n<h3 id=\"清理Back-Stack\"><a href=\"#清理Back-Stack\" class=\"headerlink\" title=\"清理Back Stack\"></a>清理Back Stack</h3><p>当Task太久没被激活时，系统会清理除了Task Root以外的所有Activity（真的吗？），有一下几个标志位可以控制清理Back Stack的行为。</p>\n<ul>\n<li>alwaysRetainTaskState，当Task的root Actvity包含该标志位时，默认的清理Back Stack行为不会发生。</li>\n<li>clearTaskOnLaunch，和 alwaysRetainTaskState 刚好相反，当Task的root Actvity包含该标志位时，一旦用户离开这个Task，默认的清理Back Stack行为马上发生。</li>\n<li>finishOnTaskLaunch，该标志作用于单个Activity，当用户离开Task之后，Task中包含该标志位的Activity会从Back Stack中移除。</li>\n</ul>\n<h2 id=\"Processes-and-Application-Lifecycle\"><a href=\"#Processes-and-Application-Lifecycle\" class=\"headerlink\" title=\"Processes and Application Lifecycle\"></a>Processes and Application Lifecycle</h2><p>本节介绍进程回收时，系统判定不同进程的优先级。</p>\n<p>进程重要程度降序如下：</p>\n<ul>\n<li>前台进程(foreground process)，包括处于Resumed(Created、Started)状态的Activity；生命周期回调正在执行的Activity、Service；onReceive()正在执行的BroadcastReceiver。</li>\n<li>可见进程(visible process)，包括处于Paused状态的Activity；由Service.startForeground()启动的Service等。</li>\n<li>服务进程(service proces)，通过startService()启动的Service。当Service运行超过30分钟之后，服务进程可能会被降级成缓存进程(cached process)。</li>\n<li>缓存进程(cached process)，包括处于Stopped状态的Activity。缓存进程由LRU列表管理，随时可能会被杀死。</li>\n<li>空进程(empty process)。</li>\n</ul>\n<h2 id=\"Parcelables-and-Bundles\"><a href=\"#Parcelables-and-Bundles\" class=\"headerlink\" title=\"Parcelables and Bundles\"></a>Parcelables and Bundles</h2><p>Parcelable对象和Bundle是设计用于在进程间传递信息的数据结构，Android的进程间通信是通过Binder transaction完成。</p>\n<h2 id=\"Recents-Screen\"><a href=\"#Recents-Screen\" class=\"headerlink\" title=\"Recents Screen\"></a>Recents Screen</h2><p>TODO。</p>\n"},{"title":"Android Developer Guide中的ContentProvider","subtitle":"Android官方guide随笔 - App Components：ContentProvider","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-08-21T09:19:05.000Z","_content":"\n\n## 展开点   \n\n* [AbstractThreadedSyncAdapter](https://developer.android.google.cn/training/sync-adapters/index.html)。\n* search framework & Search Suggestions with ContentProvider；SearchRecentSuggestionsProvider。\n* ContentProviderOperation & ContentProvider Batch Access。\n* LevelDB。\n* [protobuf](https://github.com/google/protobuf)。\n* 使用ContentProvider分享文件。\n* ContentProvider's Temporary permission。\n* 如何限制列的访问。\n* ContentProvider执行时发生异常，跨进程抛出异常。\n\n## Caution\n\n* Android Framework提供的ContentProvider的定义(Contract)存放于android.provider包里。\n* Uri & Uri.Builder可以用来构建结构化Uri；ContentUris包括一些静态方法来处理content:类型的Uri中包含的id字段。\n* 不要在主线程上执行ContentProvider操作，这些操作时同步的。\n* 在SelectionClause中使用\"?\"通配符，可以避免SQL注入。\n* 为了在SimpleCursorAdapter中使用Cursor，Cursor中必须包含_ID列。\n* 可以使用BLOB类型字段，来实现兼容多种数据格式的表。\n* 访问ContentProvider的getType()不需要权限，即便ContentProvider的exported为false。\n\n## Content Provider Basics\n\n这一节介绍如何使用已有的ContentProvider。\n\n### 概述\n\n#### 访问ContentProvider\n\nClient Component通过ContentResolver来访问ContentProvider，ContentResolver包含了和ContentProivder一致的接口，Client Component通过ContentResolver的接口来访问ContentProivder实例的接口。\n\n#### Content URI\n\nContent URI的用于定位ContentProvider中的数据表或者数据行，其结构为`content://authority/path/id`。\nContentResolver通过authority在系统中解析Provider，ContentProvider通过path来选择将被访问的表。\n\n### “查”    \n\n“查”大致分为两步，申请权限(读权限) & 调用接口。\n\n#### 查询操作的结果 \n\nProvider的查询结果以Cursor对象的形式返回，如果没有符合条件的数据那么返回的Cursor.getCount()为0；如果在查询时发生错误，依赖Provider的实现有可能返回null或者抛出异常。\n\n可以使用工具类SimpleCursorAdapter配合ListView来展示Cursor中所包含的数据；如果要这样做Cursor中必须包含`_ID`列。\n\n### Provider的权限\n\n如果Provider不定义权限，其他的App就无法访问Provider；Provider所属的App**总是**可以自由的访问Provider。\n\n### “增”、“删”、“改”  \n\nContentResolver.insert()方法会返回刚刚插入的数据的URI。\n\n### Provider的数据类型\n\nProvider支持的基本类型包括：string、int、long、float、double和blob；其中blob为上限64KB的byte数组。通常每一列的类型会在Contract类型中注释。\n\n同时，Provider还会提供所包含URI的MIME type；可以通过ContentResolver.getType()来查询URI的MIME type。\n\n### Provider的其他访问方式\n\n这里介绍批量访问(Batch)和借助其他App访问。\n\n#### Batch操作\n\n见展开点。\n\n#### 借助其他App访问\n\n即使不申请provider的读取权限，也可以通过StartActivityForResult()访问其他App，经由返回intent中携带的Uri来访问proivder；这么做需要借助URI权限。\n\n通过Intent获取provider URI的常用协议为ACTION_PICK(android.intent.action.PICK)加上MIME type。\n\n### Contract类    \n\nContract类用于定义(向使用者说明)Provider结构，并定义一些辅助常量。\n\n### MIME Type\n\nMIME type的结构为`type/subtype`。\n对于自定义的MIME type而言，type字段永远是`vnd.android.cursor.dir`(表示一组自定义数据)或`vnd.android.cursor.item`(表示一条自定义数据)；subtype则自由定义。\n\n尽管Android系统自定义的MIME type的subtype通常很短，开发者自定义的MIME type通常基于包名 &表名unique。\n\n## Creating a Content Provider\n\n### 实现前，想清楚\n\n在实现ContentProvider之前，首先需要确定是否真的需要ContentProvider。\n\n实现ContentProvider包括以下工作：\n\n* 设计数据的存储结构，ContentProvider可以处理文件类型数据和结构化数据。\n* 继承ContentProvider并实现接口。\n* 编写contract类，定义authority，path，列名；定义Intent协议；定义权限常量，MIME type常量等。\n\n\n### 设计contract\n\nauthority需要在系统中是独一无二的，通常采用`包名.Provider名`的格式。path类似于表名，path的路径可以有多层(无需每层都有意义)。\n\nUriMatcher类可以作为识别URI的工具类。\nUriMatcher使用uri pattern stirng，其中可以包含通配符`*`和`#`，`*`代表任意长度的字符串，`#`代表任意长度的数字。\n\n### 继承&实现ContentProvider\n\n实现ContentProvider需要实现：生命周期方法(onCreate())，获取MIME type方法(getType()等)以及增删改查方法。\n\n增删改查方法有可能在任何线程上调用(八成跟Service的AIDL一样)，ContentProvider需要时线程安全的。\n返回MIME type的方法——getType()等方法——是需要认真实现的。\n\n即使在跨进程的情况下，也有方法从ContentProvider的增删改差方法中，向调用者抛出异常（方法见展开点）。\n\n不要再onCreate()方法中执行耗时操作，因为系统在创建ContentProvider的时候立即调用onCreate()过长的创建时间会拖慢返回速度，延迟耗时的初始化到第一次使用的时候。\n\n### 实现MIME type\n\nContentProvider通过`getType()`和`getStreamTypes()`返回table与文件的MIME type。\n\n#### 返回属于table的MIME type\n\n格式为`vnd.android.cursor.<item ro dir>/vnd.<package>.<typename>`。\n\n#### 返回属于文件的MIME type\n\n如果ContentProvider支持文件，就需要实现`getStreamTypes()`。\n\n### 实现Provider的权限\n\n通过权限控制其他应用对Provider的访问，那么实际存储数据的文件或Database应该是private的，否则就没有意义。\n\n在Manifest中可以分不同粒度声明Proivder的所需权限：\n\n* 整体权限，在`<provider>`标签的android:permission字段中声明Provider的整体权限。\n* 读写权限，在`<provider>`标签的android:readPermission和android:writePermission分别声明读写权限。\n* 表权限，可以通过`<provider>`的字标签` <path-permission>`为某些pattern的content uri声明读写权限。\n* Uri权限(临时权限)，通过`<provider>`标签的android:grantUriPermissions属性和子标签`<grant-uri-permission>`来开启Provider的Uri权限。\n\n### 关于`<provider>`标签的属性\n\n* android:authorities，等价于Provider在系统中的id。\n* android:name，实现Provider的class。\n* permission相关属性。\n* android:icon和android:label，也许会在Setting里显示。\n\n\n\n","source":"_posts/android-developers-guide-note-app-components-content-provider.md","raw":"---\ntitle: Android Developer Guide中的ContentProvider\nsubtitle: Android官方guide随笔 - App Components：ContentProvider\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-08-21 17:19:05\n---\n\n\n## 展开点   \n\n* [AbstractThreadedSyncAdapter](https://developer.android.google.cn/training/sync-adapters/index.html)。\n* search framework & Search Suggestions with ContentProvider；SearchRecentSuggestionsProvider。\n* ContentProviderOperation & ContentProvider Batch Access。\n* LevelDB。\n* [protobuf](https://github.com/google/protobuf)。\n* 使用ContentProvider分享文件。\n* ContentProvider's Temporary permission。\n* 如何限制列的访问。\n* ContentProvider执行时发生异常，跨进程抛出异常。\n\n## Caution\n\n* Android Framework提供的ContentProvider的定义(Contract)存放于android.provider包里。\n* Uri & Uri.Builder可以用来构建结构化Uri；ContentUris包括一些静态方法来处理content:类型的Uri中包含的id字段。\n* 不要在主线程上执行ContentProvider操作，这些操作时同步的。\n* 在SelectionClause中使用\"?\"通配符，可以避免SQL注入。\n* 为了在SimpleCursorAdapter中使用Cursor，Cursor中必须包含_ID列。\n* 可以使用BLOB类型字段，来实现兼容多种数据格式的表。\n* 访问ContentProvider的getType()不需要权限，即便ContentProvider的exported为false。\n\n## Content Provider Basics\n\n这一节介绍如何使用已有的ContentProvider。\n\n### 概述\n\n#### 访问ContentProvider\n\nClient Component通过ContentResolver来访问ContentProvider，ContentResolver包含了和ContentProivder一致的接口，Client Component通过ContentResolver的接口来访问ContentProivder实例的接口。\n\n#### Content URI\n\nContent URI的用于定位ContentProvider中的数据表或者数据行，其结构为`content://authority/path/id`。\nContentResolver通过authority在系统中解析Provider，ContentProvider通过path来选择将被访问的表。\n\n### “查”    \n\n“查”大致分为两步，申请权限(读权限) & 调用接口。\n\n#### 查询操作的结果 \n\nProvider的查询结果以Cursor对象的形式返回，如果没有符合条件的数据那么返回的Cursor.getCount()为0；如果在查询时发生错误，依赖Provider的实现有可能返回null或者抛出异常。\n\n可以使用工具类SimpleCursorAdapter配合ListView来展示Cursor中所包含的数据；如果要这样做Cursor中必须包含`_ID`列。\n\n### Provider的权限\n\n如果Provider不定义权限，其他的App就无法访问Provider；Provider所属的App**总是**可以自由的访问Provider。\n\n### “增”、“删”、“改”  \n\nContentResolver.insert()方法会返回刚刚插入的数据的URI。\n\n### Provider的数据类型\n\nProvider支持的基本类型包括：string、int、long、float、double和blob；其中blob为上限64KB的byte数组。通常每一列的类型会在Contract类型中注释。\n\n同时，Provider还会提供所包含URI的MIME type；可以通过ContentResolver.getType()来查询URI的MIME type。\n\n### Provider的其他访问方式\n\n这里介绍批量访问(Batch)和借助其他App访问。\n\n#### Batch操作\n\n见展开点。\n\n#### 借助其他App访问\n\n即使不申请provider的读取权限，也可以通过StartActivityForResult()访问其他App，经由返回intent中携带的Uri来访问proivder；这么做需要借助URI权限。\n\n通过Intent获取provider URI的常用协议为ACTION_PICK(android.intent.action.PICK)加上MIME type。\n\n### Contract类    \n\nContract类用于定义(向使用者说明)Provider结构，并定义一些辅助常量。\n\n### MIME Type\n\nMIME type的结构为`type/subtype`。\n对于自定义的MIME type而言，type字段永远是`vnd.android.cursor.dir`(表示一组自定义数据)或`vnd.android.cursor.item`(表示一条自定义数据)；subtype则自由定义。\n\n尽管Android系统自定义的MIME type的subtype通常很短，开发者自定义的MIME type通常基于包名 &表名unique。\n\n## Creating a Content Provider\n\n### 实现前，想清楚\n\n在实现ContentProvider之前，首先需要确定是否真的需要ContentProvider。\n\n实现ContentProvider包括以下工作：\n\n* 设计数据的存储结构，ContentProvider可以处理文件类型数据和结构化数据。\n* 继承ContentProvider并实现接口。\n* 编写contract类，定义authority，path，列名；定义Intent协议；定义权限常量，MIME type常量等。\n\n\n### 设计contract\n\nauthority需要在系统中是独一无二的，通常采用`包名.Provider名`的格式。path类似于表名，path的路径可以有多层(无需每层都有意义)。\n\nUriMatcher类可以作为识别URI的工具类。\nUriMatcher使用uri pattern stirng，其中可以包含通配符`*`和`#`，`*`代表任意长度的字符串，`#`代表任意长度的数字。\n\n### 继承&实现ContentProvider\n\n实现ContentProvider需要实现：生命周期方法(onCreate())，获取MIME type方法(getType()等)以及增删改查方法。\n\n增删改查方法有可能在任何线程上调用(八成跟Service的AIDL一样)，ContentProvider需要时线程安全的。\n返回MIME type的方法——getType()等方法——是需要认真实现的。\n\n即使在跨进程的情况下，也有方法从ContentProvider的增删改差方法中，向调用者抛出异常（方法见展开点）。\n\n不要再onCreate()方法中执行耗时操作，因为系统在创建ContentProvider的时候立即调用onCreate()过长的创建时间会拖慢返回速度，延迟耗时的初始化到第一次使用的时候。\n\n### 实现MIME type\n\nContentProvider通过`getType()`和`getStreamTypes()`返回table与文件的MIME type。\n\n#### 返回属于table的MIME type\n\n格式为`vnd.android.cursor.<item ro dir>/vnd.<package>.<typename>`。\n\n#### 返回属于文件的MIME type\n\n如果ContentProvider支持文件，就需要实现`getStreamTypes()`。\n\n### 实现Provider的权限\n\n通过权限控制其他应用对Provider的访问，那么实际存储数据的文件或Database应该是private的，否则就没有意义。\n\n在Manifest中可以分不同粒度声明Proivder的所需权限：\n\n* 整体权限，在`<provider>`标签的android:permission字段中声明Provider的整体权限。\n* 读写权限，在`<provider>`标签的android:readPermission和android:writePermission分别声明读写权限。\n* 表权限，可以通过`<provider>`的字标签` <path-permission>`为某些pattern的content uri声明读写权限。\n* Uri权限(临时权限)，通过`<provider>`标签的android:grantUriPermissions属性和子标签`<grant-uri-permission>`来开启Provider的Uri权限。\n\n### 关于`<provider>`标签的属性\n\n* android:authorities，等价于Provider在系统中的id。\n* android:name，实现Provider的class。\n* permission相关属性。\n* android:icon和android:label，也许会在Setting里显示。\n\n\n\n","slug":"android-developers-guide-note-app-components-content-provider","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p1000l3mrf23ad0n29","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://developer.android.google.cn/training/sync-adapters/index.html\">AbstractThreadedSyncAdapter</a>。</li>\n<li>search framework &amp; Search Suggestions with ContentProvider；SearchRecentSuggestionsProvider。</li>\n<li>ContentProviderOperation &amp; ContentProvider Batch Access。</li>\n<li>LevelDB。</li>\n<li><a href=\"https://github.com/google/protobuf\">protobuf</a>。</li>\n<li>使用ContentProvider分享文件。</li>\n<li>ContentProvider’s Temporary permission。</li>\n<li>如何限制列的访问。</li>\n<li>ContentProvider执行时发生异常，跨进程抛出异常。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>Android Framework提供的ContentProvider的定义(Contract)存放于android.provider包里。</li>\n<li>Uri &amp; Uri.Builder可以用来构建结构化Uri；ContentUris包括一些静态方法来处理content:类型的Uri中包含的id字段。</li>\n<li>不要在主线程上执行ContentProvider操作，这些操作时同步的。</li>\n<li>在SelectionClause中使用”?”通配符，可以避免SQL注入。</li>\n<li>为了在SimpleCursorAdapter中使用Cursor，Cursor中必须包含_ID列。</li>\n<li>可以使用BLOB类型字段，来实现兼容多种数据格式的表。</li>\n<li>访问ContentProvider的getType()不需要权限，即便ContentProvider的exported为false。</li>\n</ul>\n<h2 id=\"Content-Provider-Basics\"><a href=\"#Content-Provider-Basics\" class=\"headerlink\" title=\"Content Provider Basics\"></a>Content Provider Basics</h2><p>这一节介绍如何使用已有的ContentProvider。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h4 id=\"访问ContentProvider\"><a href=\"#访问ContentProvider\" class=\"headerlink\" title=\"访问ContentProvider\"></a>访问ContentProvider</h4><p>Client Component通过ContentResolver来访问ContentProvider，ContentResolver包含了和ContentProivder一致的接口，Client Component通过ContentResolver的接口来访问ContentProivder实例的接口。</p>\n<h4 id=\"Content-URI\"><a href=\"#Content-URI\" class=\"headerlink\" title=\"Content URI\"></a>Content URI</h4><p>Content URI的用于定位ContentProvider中的数据表或者数据行，其结构为<code>content://authority/path/id</code>。<br>ContentResolver通过authority在系统中解析Provider，ContentProvider通过path来选择将被访问的表。</p>\n<h3 id=\"“查”\"><a href=\"#“查”\" class=\"headerlink\" title=\"“查”\"></a>“查”</h3><p>“查”大致分为两步，申请权限(读权限) &amp; 调用接口。</p>\n<h4 id=\"查询操作的结果\"><a href=\"#查询操作的结果\" class=\"headerlink\" title=\"查询操作的结果\"></a>查询操作的结果</h4><p>Provider的查询结果以Cursor对象的形式返回，如果没有符合条件的数据那么返回的Cursor.getCount()为0；如果在查询时发生错误，依赖Provider的实现有可能返回null或者抛出异常。</p>\n<p>可以使用工具类SimpleCursorAdapter配合ListView来展示Cursor中所包含的数据；如果要这样做Cursor中必须包含<code>_ID</code>列。</p>\n<h3 id=\"Provider的权限\"><a href=\"#Provider的权限\" class=\"headerlink\" title=\"Provider的权限\"></a>Provider的权限</h3><p>如果Provider不定义权限，其他的App就无法访问Provider；Provider所属的App<strong>总是</strong>可以自由的访问Provider。</p>\n<h3 id=\"“增”、“删”、“改”\"><a href=\"#“增”、“删”、“改”\" class=\"headerlink\" title=\"“增”、“删”、“改”\"></a>“增”、“删”、“改”</h3><p>ContentResolver.insert()方法会返回刚刚插入的数据的URI。</p>\n<h3 id=\"Provider的数据类型\"><a href=\"#Provider的数据类型\" class=\"headerlink\" title=\"Provider的数据类型\"></a>Provider的数据类型</h3><p>Provider支持的基本类型包括：string、int、long、float、double和blob；其中blob为上限64KB的byte数组。通常每一列的类型会在Contract类型中注释。</p>\n<p>同时，Provider还会提供所包含URI的MIME type；可以通过ContentResolver.getType()来查询URI的MIME type。</p>\n<h3 id=\"Provider的其他访问方式\"><a href=\"#Provider的其他访问方式\" class=\"headerlink\" title=\"Provider的其他访问方式\"></a>Provider的其他访问方式</h3><p>这里介绍批量访问(Batch)和借助其他App访问。</p>\n<h4 id=\"Batch操作\"><a href=\"#Batch操作\" class=\"headerlink\" title=\"Batch操作\"></a>Batch操作</h4><p>见展开点。</p>\n<h4 id=\"借助其他App访问\"><a href=\"#借助其他App访问\" class=\"headerlink\" title=\"借助其他App访问\"></a>借助其他App访问</h4><p>即使不申请provider的读取权限，也可以通过StartActivityForResult()访问其他App，经由返回intent中携带的Uri来访问proivder；这么做需要借助URI权限。</p>\n<p>通过Intent获取provider URI的常用协议为ACTION_PICK(android.intent.action.PICK)加上MIME type。</p>\n<h3 id=\"Contract类\"><a href=\"#Contract类\" class=\"headerlink\" title=\"Contract类\"></a>Contract类</h3><p>Contract类用于定义(向使用者说明)Provider结构，并定义一些辅助常量。</p>\n<h3 id=\"MIME-Type\"><a href=\"#MIME-Type\" class=\"headerlink\" title=\"MIME Type\"></a>MIME Type</h3><p>MIME type的结构为<code>type/subtype</code>。<br>对于自定义的MIME type而言，type字段永远是<code>vnd.android.cursor.dir</code>(表示一组自定义数据)或<code>vnd.android.cursor.item</code>(表示一条自定义数据)；subtype则自由定义。</p>\n<p>尽管Android系统自定义的MIME type的subtype通常很短，开发者自定义的MIME type通常基于包名 &amp;表名unique。</p>\n<h2 id=\"Creating-a-Content-Provider\"><a href=\"#Creating-a-Content-Provider\" class=\"headerlink\" title=\"Creating a Content Provider\"></a>Creating a Content Provider</h2><h3 id=\"实现前，想清楚\"><a href=\"#实现前，想清楚\" class=\"headerlink\" title=\"实现前，想清楚\"></a>实现前，想清楚</h3><p>在实现ContentProvider之前，首先需要确定是否真的需要ContentProvider。</p>\n<p>实现ContentProvider包括以下工作：</p>\n<ul>\n<li>设计数据的存储结构，ContentProvider可以处理文件类型数据和结构化数据。</li>\n<li>继承ContentProvider并实现接口。</li>\n<li>编写contract类，定义authority，path，列名；定义Intent协议；定义权限常量，MIME type常量等。</li>\n</ul>\n<h3 id=\"设计contract\"><a href=\"#设计contract\" class=\"headerlink\" title=\"设计contract\"></a>设计contract</h3><p>authority需要在系统中是独一无二的，通常采用<code>包名.Provider名</code>的格式。path类似于表名，path的路径可以有多层(无需每层都有意义)。</p>\n<p>UriMatcher类可以作为识别URI的工具类。<br>UriMatcher使用uri pattern stirng，其中可以包含通配符<code>*</code>和<code>#</code>，<code>*</code>代表任意长度的字符串，<code>#</code>代表任意长度的数字。</p>\n<h3 id=\"继承-amp-实现ContentProvider\"><a href=\"#继承-amp-实现ContentProvider\" class=\"headerlink\" title=\"继承&amp;实现ContentProvider\"></a>继承&amp;实现ContentProvider</h3><p>实现ContentProvider需要实现：生命周期方法(onCreate())，获取MIME type方法(getType()等)以及增删改查方法。</p>\n<p>增删改查方法有可能在任何线程上调用(八成跟Service的AIDL一样)，ContentProvider需要时线程安全的。<br>返回MIME type的方法——getType()等方法——是需要认真实现的。</p>\n<p>即使在跨进程的情况下，也有方法从ContentProvider的增删改差方法中，向调用者抛出异常（方法见展开点）。</p>\n<p>不要再onCreate()方法中执行耗时操作，因为系统在创建ContentProvider的时候立即调用onCreate()过长的创建时间会拖慢返回速度，延迟耗时的初始化到第一次使用的时候。</p>\n<h3 id=\"实现MIME-type\"><a href=\"#实现MIME-type\" class=\"headerlink\" title=\"实现MIME type\"></a>实现MIME type</h3><p>ContentProvider通过<code>getType()</code>和<code>getStreamTypes()</code>返回table与文件的MIME type。</p>\n<h4 id=\"返回属于table的MIME-type\"><a href=\"#返回属于table的MIME-type\" class=\"headerlink\" title=\"返回属于table的MIME type\"></a>返回属于table的MIME type</h4><p>格式为<code>vnd.android.cursor.&lt;item ro dir&gt;/vnd.&lt;package&gt;.&lt;typename&gt;</code>。</p>\n<h4 id=\"返回属于文件的MIME-type\"><a href=\"#返回属于文件的MIME-type\" class=\"headerlink\" title=\"返回属于文件的MIME type\"></a>返回属于文件的MIME type</h4><p>如果ContentProvider支持文件，就需要实现<code>getStreamTypes()</code>。</p>\n<h3 id=\"实现Provider的权限\"><a href=\"#实现Provider的权限\" class=\"headerlink\" title=\"实现Provider的权限\"></a>实现Provider的权限</h3><p>通过权限控制其他应用对Provider的访问，那么实际存储数据的文件或Database应该是private的，否则就没有意义。</p>\n<p>在Manifest中可以分不同粒度声明Proivder的所需权限：</p>\n<ul>\n<li>整体权限，在<code>&lt;provider&gt;</code>标签的android:permission字段中声明Provider的整体权限。</li>\n<li>读写权限，在<code>&lt;provider&gt;</code>标签的android:readPermission和android:writePermission分别声明读写权限。</li>\n<li>表权限，可以通过<code>&lt;provider&gt;</code>的字标签<code>&lt;path-permission&gt;</code>为某些pattern的content uri声明读写权限。</li>\n<li>Uri权限(临时权限)，通过<code>&lt;provider&gt;</code>标签的android:grantUriPermissions属性和子标签<code>&lt;grant-uri-permission&gt;</code>来开启Provider的Uri权限。</li>\n</ul>\n<h3 id=\"关于-lt-provider-gt-标签的属性\"><a href=\"#关于-lt-provider-gt-标签的属性\" class=\"headerlink\" title=\"关于&lt;provider&gt;标签的属性\"></a>关于<code>&lt;provider&gt;</code>标签的属性</h3><ul>\n<li>android:authorities，等价于Provider在系统中的id。</li>\n<li>android:name，实现Provider的class。</li>\n<li>permission相关属性。</li>\n<li>android:icon和android:label，也许会在Setting里显示。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://developer.android.google.cn/training/sync-adapters/index.html\">AbstractThreadedSyncAdapter</a>。</li>\n<li>search framework &amp; Search Suggestions with ContentProvider；SearchRecentSuggestionsProvider。</li>\n<li>ContentProviderOperation &amp; ContentProvider Batch Access。</li>\n<li>LevelDB。</li>\n<li><a href=\"https://github.com/google/protobuf\">protobuf</a>。</li>\n<li>使用ContentProvider分享文件。</li>\n<li>ContentProvider’s Temporary permission。</li>\n<li>如何限制列的访问。</li>\n<li>ContentProvider执行时发生异常，跨进程抛出异常。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>Android Framework提供的ContentProvider的定义(Contract)存放于android.provider包里。</li>\n<li>Uri &amp; Uri.Builder可以用来构建结构化Uri；ContentUris包括一些静态方法来处理content:类型的Uri中包含的id字段。</li>\n<li>不要在主线程上执行ContentProvider操作，这些操作时同步的。</li>\n<li>在SelectionClause中使用”?”通配符，可以避免SQL注入。</li>\n<li>为了在SimpleCursorAdapter中使用Cursor，Cursor中必须包含_ID列。</li>\n<li>可以使用BLOB类型字段，来实现兼容多种数据格式的表。</li>\n<li>访问ContentProvider的getType()不需要权限，即便ContentProvider的exported为false。</li>\n</ul>\n<h2 id=\"Content-Provider-Basics\"><a href=\"#Content-Provider-Basics\" class=\"headerlink\" title=\"Content Provider Basics\"></a>Content Provider Basics</h2><p>这一节介绍如何使用已有的ContentProvider。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h4 id=\"访问ContentProvider\"><a href=\"#访问ContentProvider\" class=\"headerlink\" title=\"访问ContentProvider\"></a>访问ContentProvider</h4><p>Client Component通过ContentResolver来访问ContentProvider，ContentResolver包含了和ContentProivder一致的接口，Client Component通过ContentResolver的接口来访问ContentProivder实例的接口。</p>\n<h4 id=\"Content-URI\"><a href=\"#Content-URI\" class=\"headerlink\" title=\"Content URI\"></a>Content URI</h4><p>Content URI的用于定位ContentProvider中的数据表或者数据行，其结构为<code>content://authority/path/id</code>。<br>ContentResolver通过authority在系统中解析Provider，ContentProvider通过path来选择将被访问的表。</p>\n<h3 id=\"“查”\"><a href=\"#“查”\" class=\"headerlink\" title=\"“查”\"></a>“查”</h3><p>“查”大致分为两步，申请权限(读权限) &amp; 调用接口。</p>\n<h4 id=\"查询操作的结果\"><a href=\"#查询操作的结果\" class=\"headerlink\" title=\"查询操作的结果\"></a>查询操作的结果</h4><p>Provider的查询结果以Cursor对象的形式返回，如果没有符合条件的数据那么返回的Cursor.getCount()为0；如果在查询时发生错误，依赖Provider的实现有可能返回null或者抛出异常。</p>\n<p>可以使用工具类SimpleCursorAdapter配合ListView来展示Cursor中所包含的数据；如果要这样做Cursor中必须包含<code>_ID</code>列。</p>\n<h3 id=\"Provider的权限\"><a href=\"#Provider的权限\" class=\"headerlink\" title=\"Provider的权限\"></a>Provider的权限</h3><p>如果Provider不定义权限，其他的App就无法访问Provider；Provider所属的App<strong>总是</strong>可以自由的访问Provider。</p>\n<h3 id=\"“增”、“删”、“改”\"><a href=\"#“增”、“删”、“改”\" class=\"headerlink\" title=\"“增”、“删”、“改”\"></a>“增”、“删”、“改”</h3><p>ContentResolver.insert()方法会返回刚刚插入的数据的URI。</p>\n<h3 id=\"Provider的数据类型\"><a href=\"#Provider的数据类型\" class=\"headerlink\" title=\"Provider的数据类型\"></a>Provider的数据类型</h3><p>Provider支持的基本类型包括：string、int、long、float、double和blob；其中blob为上限64KB的byte数组。通常每一列的类型会在Contract类型中注释。</p>\n<p>同时，Provider还会提供所包含URI的MIME type；可以通过ContentResolver.getType()来查询URI的MIME type。</p>\n<h3 id=\"Provider的其他访问方式\"><a href=\"#Provider的其他访问方式\" class=\"headerlink\" title=\"Provider的其他访问方式\"></a>Provider的其他访问方式</h3><p>这里介绍批量访问(Batch)和借助其他App访问。</p>\n<h4 id=\"Batch操作\"><a href=\"#Batch操作\" class=\"headerlink\" title=\"Batch操作\"></a>Batch操作</h4><p>见展开点。</p>\n<h4 id=\"借助其他App访问\"><a href=\"#借助其他App访问\" class=\"headerlink\" title=\"借助其他App访问\"></a>借助其他App访问</h4><p>即使不申请provider的读取权限，也可以通过StartActivityForResult()访问其他App，经由返回intent中携带的Uri来访问proivder；这么做需要借助URI权限。</p>\n<p>通过Intent获取provider URI的常用协议为ACTION_PICK(android.intent.action.PICK)加上MIME type。</p>\n<h3 id=\"Contract类\"><a href=\"#Contract类\" class=\"headerlink\" title=\"Contract类\"></a>Contract类</h3><p>Contract类用于定义(向使用者说明)Provider结构，并定义一些辅助常量。</p>\n<h3 id=\"MIME-Type\"><a href=\"#MIME-Type\" class=\"headerlink\" title=\"MIME Type\"></a>MIME Type</h3><p>MIME type的结构为<code>type/subtype</code>。<br>对于自定义的MIME type而言，type字段永远是<code>vnd.android.cursor.dir</code>(表示一组自定义数据)或<code>vnd.android.cursor.item</code>(表示一条自定义数据)；subtype则自由定义。</p>\n<p>尽管Android系统自定义的MIME type的subtype通常很短，开发者自定义的MIME type通常基于包名 &amp;表名unique。</p>\n<h2 id=\"Creating-a-Content-Provider\"><a href=\"#Creating-a-Content-Provider\" class=\"headerlink\" title=\"Creating a Content Provider\"></a>Creating a Content Provider</h2><h3 id=\"实现前，想清楚\"><a href=\"#实现前，想清楚\" class=\"headerlink\" title=\"实现前，想清楚\"></a>实现前，想清楚</h3><p>在实现ContentProvider之前，首先需要确定是否真的需要ContentProvider。</p>\n<p>实现ContentProvider包括以下工作：</p>\n<ul>\n<li>设计数据的存储结构，ContentProvider可以处理文件类型数据和结构化数据。</li>\n<li>继承ContentProvider并实现接口。</li>\n<li>编写contract类，定义authority，path，列名；定义Intent协议；定义权限常量，MIME type常量等。</li>\n</ul>\n<h3 id=\"设计contract\"><a href=\"#设计contract\" class=\"headerlink\" title=\"设计contract\"></a>设计contract</h3><p>authority需要在系统中是独一无二的，通常采用<code>包名.Provider名</code>的格式。path类似于表名，path的路径可以有多层(无需每层都有意义)。</p>\n<p>UriMatcher类可以作为识别URI的工具类。<br>UriMatcher使用uri pattern stirng，其中可以包含通配符<code>*</code>和<code>#</code>，<code>*</code>代表任意长度的字符串，<code>#</code>代表任意长度的数字。</p>\n<h3 id=\"继承-amp-实现ContentProvider\"><a href=\"#继承-amp-实现ContentProvider\" class=\"headerlink\" title=\"继承&amp;实现ContentProvider\"></a>继承&amp;实现ContentProvider</h3><p>实现ContentProvider需要实现：生命周期方法(onCreate())，获取MIME type方法(getType()等)以及增删改查方法。</p>\n<p>增删改查方法有可能在任何线程上调用(八成跟Service的AIDL一样)，ContentProvider需要时线程安全的。<br>返回MIME type的方法——getType()等方法——是需要认真实现的。</p>\n<p>即使在跨进程的情况下，也有方法从ContentProvider的增删改差方法中，向调用者抛出异常（方法见展开点）。</p>\n<p>不要再onCreate()方法中执行耗时操作，因为系统在创建ContentProvider的时候立即调用onCreate()过长的创建时间会拖慢返回速度，延迟耗时的初始化到第一次使用的时候。</p>\n<h3 id=\"实现MIME-type\"><a href=\"#实现MIME-type\" class=\"headerlink\" title=\"实现MIME type\"></a>实现MIME type</h3><p>ContentProvider通过<code>getType()</code>和<code>getStreamTypes()</code>返回table与文件的MIME type。</p>\n<h4 id=\"返回属于table的MIME-type\"><a href=\"#返回属于table的MIME-type\" class=\"headerlink\" title=\"返回属于table的MIME type\"></a>返回属于table的MIME type</h4><p>格式为<code>vnd.android.cursor.&lt;item ro dir&gt;/vnd.&lt;package&gt;.&lt;typename&gt;</code>。</p>\n<h4 id=\"返回属于文件的MIME-type\"><a href=\"#返回属于文件的MIME-type\" class=\"headerlink\" title=\"返回属于文件的MIME type\"></a>返回属于文件的MIME type</h4><p>如果ContentProvider支持文件，就需要实现<code>getStreamTypes()</code>。</p>\n<h3 id=\"实现Provider的权限\"><a href=\"#实现Provider的权限\" class=\"headerlink\" title=\"实现Provider的权限\"></a>实现Provider的权限</h3><p>通过权限控制其他应用对Provider的访问，那么实际存储数据的文件或Database应该是private的，否则就没有意义。</p>\n<p>在Manifest中可以分不同粒度声明Proivder的所需权限：</p>\n<ul>\n<li>整体权限，在<code>&lt;provider&gt;</code>标签的android:permission字段中声明Provider的整体权限。</li>\n<li>读写权限，在<code>&lt;provider&gt;</code>标签的android:readPermission和android:writePermission分别声明读写权限。</li>\n<li>表权限，可以通过<code>&lt;provider&gt;</code>的字标签<code>&lt;path-permission&gt;</code>为某些pattern的content uri声明读写权限。</li>\n<li>Uri权限(临时权限)，通过<code>&lt;provider&gt;</code>标签的android:grantUriPermissions属性和子标签<code>&lt;grant-uri-permission&gt;</code>来开启Provider的Uri权限。</li>\n</ul>\n<h3 id=\"关于-lt-provider-gt-标签的属性\"><a href=\"#关于-lt-provider-gt-标签的属性\" class=\"headerlink\" title=\"关于&lt;provider&gt;标签的属性\"></a>关于<code>&lt;provider&gt;</code>标签的属性</h3><ul>\n<li>android:authorities，等价于Provider在系统中的id。</li>\n<li>android:name，实现Provider的class。</li>\n<li>permission相关属性。</li>\n<li>android:icon和android:label，也许会在Setting里显示。</li>\n</ul>\n"},{"title":"Android Developer Guide中的Fragment和Loader","subtitle":"Android官方guide随笔 - App Components：Fragment & Loader","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-08-04T07:19:51.000Z","_content":"\n\n## 展开点   \n\n* DialogFragment vs Dialog。\n* FragmentManager in Detail。\n* multiple fragments to the same container。 \n* Fragment and Menus。\n* Fragment lifecycle in Detail。\n\n## Caution   \n\n* 经过commit()方法提交Fragment更改应该发生在Activity进行SaveInstanceState之前，如果在SaveInstanceState之后这么做会抛出异常；如果一定要在SaveInstanceState之后提交Fragment更改，使用commitAllowingStateLoss()。\n* 如果要Fragment能够收到onCreateOptionsMenu()回调，需要在Activity处于Created状态时调用setHasOptionsMenu()。\n\n## Fragments\n\n### 创建Fragment   \n\n创建包含UI的Fragment有两种途径：\n\n* 在layout文件中声明`<fragment>`标签，如同使用View一样；系统会用onCreateView()返回的View替换`<fragment>`标签。\n* 使用FragmentTransaction.add(int, Fragment)方法提交fragment。\n\n创建不包含UI的Fragment，需要使用FragmentTransaction.add(Fragment, String)方法，String参数代表了Fragment的Tag。因为不包含UI的Fragment不存在于View结构中，通过Activity查找它的唯一方法是findFragmentByTag()。\n\n每个Fragment必须有一个唯一标识，系统寻找这个标识有三种方式：  \n\n* android:id属性。\n* android:tag属性。\n* 如果前两条都不存在，系统会使用fragment的parent viewgroup的id。\n\n### Fragment和Activity的交流\n\n* Fragment中可以通过getActivity()或得所属的Activity。\n* Fragment定义Listner类的Interface来给Activity回调。\n* Fragment可以参与Options Menu和Context Menu。\n\n### Fragment的生命周期\n\n![Fragment生命周期图](https://developer.android.google.cn/images/activity_fragment_lifecycle.png)\n\n与Activity相同，系统会Fragment的onSaveInstanceState()方法，savedInstanceState会在 onCreate()、onCreateView()、onActivityCreated()方法中被传入。\n\n## Loader\n\n### 为什么要使用Loader\n\n* Loader运行在单独线程中（车有轮子...）。\n* Loader简化了Worker线程和主线程之间的交流（AsyncTask也行）。\n* Loader当Activity发生configuration changes时，加载结果会得以保存（都MVP了，不过在轻量级实现时有一定意义）。\n* Loader会在数据源变化时产生响应，例如ContentProvider（有一定意义，跟LiveData有何不同）。\n*\n\n### 使用Loader\n\nLoader相关的API主要包含在LoaderManager，LoaderManager.LoaderCallbacks和Loader三个class & interface中。\n\n* LoaderManager，每个Activity & Fragment绑定唯一一个LoaderManager，可以通过getLoaderManager()获取。\n* LoaderManager.LoaderCallbacks，绑定Loader回调接口，返回Loader的加载状态和加载结果。\n* Loader，开发者自己实现Loader或者使用系统提供的工具Loader，实现具体的加载过程。\n\n\n\n\n","source":"_posts/android-developers-guide-note-app-components-fragment.md","raw":"---\ntitle: Android Developer Guide中的Fragment和Loader\nsubtitle: Android官方guide随笔 - App Components：Fragment & Loader\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-08-04 15:19:51\n---\n\n\n## 展开点   \n\n* DialogFragment vs Dialog。\n* FragmentManager in Detail。\n* multiple fragments to the same container。 \n* Fragment and Menus。\n* Fragment lifecycle in Detail。\n\n## Caution   \n\n* 经过commit()方法提交Fragment更改应该发生在Activity进行SaveInstanceState之前，如果在SaveInstanceState之后这么做会抛出异常；如果一定要在SaveInstanceState之后提交Fragment更改，使用commitAllowingStateLoss()。\n* 如果要Fragment能够收到onCreateOptionsMenu()回调，需要在Activity处于Created状态时调用setHasOptionsMenu()。\n\n## Fragments\n\n### 创建Fragment   \n\n创建包含UI的Fragment有两种途径：\n\n* 在layout文件中声明`<fragment>`标签，如同使用View一样；系统会用onCreateView()返回的View替换`<fragment>`标签。\n* 使用FragmentTransaction.add(int, Fragment)方法提交fragment。\n\n创建不包含UI的Fragment，需要使用FragmentTransaction.add(Fragment, String)方法，String参数代表了Fragment的Tag。因为不包含UI的Fragment不存在于View结构中，通过Activity查找它的唯一方法是findFragmentByTag()。\n\n每个Fragment必须有一个唯一标识，系统寻找这个标识有三种方式：  \n\n* android:id属性。\n* android:tag属性。\n* 如果前两条都不存在，系统会使用fragment的parent viewgroup的id。\n\n### Fragment和Activity的交流\n\n* Fragment中可以通过getActivity()或得所属的Activity。\n* Fragment定义Listner类的Interface来给Activity回调。\n* Fragment可以参与Options Menu和Context Menu。\n\n### Fragment的生命周期\n\n![Fragment生命周期图](https://developer.android.google.cn/images/activity_fragment_lifecycle.png)\n\n与Activity相同，系统会Fragment的onSaveInstanceState()方法，savedInstanceState会在 onCreate()、onCreateView()、onActivityCreated()方法中被传入。\n\n## Loader\n\n### 为什么要使用Loader\n\n* Loader运行在单独线程中（车有轮子...）。\n* Loader简化了Worker线程和主线程之间的交流（AsyncTask也行）。\n* Loader当Activity发生configuration changes时，加载结果会得以保存（都MVP了，不过在轻量级实现时有一定意义）。\n* Loader会在数据源变化时产生响应，例如ContentProvider（有一定意义，跟LiveData有何不同）。\n*\n\n### 使用Loader\n\nLoader相关的API主要包含在LoaderManager，LoaderManager.LoaderCallbacks和Loader三个class & interface中。\n\n* LoaderManager，每个Activity & Fragment绑定唯一一个LoaderManager，可以通过getLoaderManager()获取。\n* LoaderManager.LoaderCallbacks，绑定Loader回调接口，返回Loader的加载状态和加载结果。\n* Loader，开发者自己实现Loader或者使用系统提供的工具Loader，实现具体的加载过程。\n\n\n\n\n","slug":"android-developers-guide-note-app-components-fragment","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p1000m3mrf1pyw15pi","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>DialogFragment vs Dialog。</li>\n<li>FragmentManager in Detail。</li>\n<li>multiple fragments to the same container。 </li>\n<li>Fragment and Menus。</li>\n<li>Fragment lifecycle in Detail。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>经过commit()方法提交Fragment更改应该发生在Activity进行SaveInstanceState之前，如果在SaveInstanceState之后这么做会抛出异常；如果一定要在SaveInstanceState之后提交Fragment更改，使用commitAllowingStateLoss()。</li>\n<li>如果要Fragment能够收到onCreateOptionsMenu()回调，需要在Activity处于Created状态时调用setHasOptionsMenu()。</li>\n</ul>\n<h2 id=\"Fragments\"><a href=\"#Fragments\" class=\"headerlink\" title=\"Fragments\"></a>Fragments</h2><h3 id=\"创建Fragment\"><a href=\"#创建Fragment\" class=\"headerlink\" title=\"创建Fragment\"></a>创建Fragment</h3><p>创建包含UI的Fragment有两种途径：</p>\n<ul>\n<li>在layout文件中声明<code>&lt;fragment&gt;</code>标签，如同使用View一样；系统会用onCreateView()返回的View替换<code>&lt;fragment&gt;</code>标签。</li>\n<li>使用FragmentTransaction.add(int, Fragment)方法提交fragment。</li>\n</ul>\n<p>创建不包含UI的Fragment，需要使用FragmentTransaction.add(Fragment, String)方法，String参数代表了Fragment的Tag。因为不包含UI的Fragment不存在于View结构中，通过Activity查找它的唯一方法是findFragmentByTag()。</p>\n<p>每个Fragment必须有一个唯一标识，系统寻找这个标识有三种方式：  </p>\n<ul>\n<li>android:id属性。</li>\n<li>android:tag属性。</li>\n<li>如果前两条都不存在，系统会使用fragment的parent viewgroup的id。</li>\n</ul>\n<h3 id=\"Fragment和Activity的交流\"><a href=\"#Fragment和Activity的交流\" class=\"headerlink\" title=\"Fragment和Activity的交流\"></a>Fragment和Activity的交流</h3><ul>\n<li>Fragment中可以通过getActivity()或得所属的Activity。</li>\n<li>Fragment定义Listner类的Interface来给Activity回调。</li>\n<li>Fragment可以参与Options Menu和Context Menu。</li>\n</ul>\n<h3 id=\"Fragment的生命周期\"><a href=\"#Fragment的生命周期\" class=\"headerlink\" title=\"Fragment的生命周期\"></a>Fragment的生命周期</h3><p><img src=\"https://developer.android.google.cn/images/activity_fragment_lifecycle.png\" alt=\"Fragment生命周期图\"></p>\n<p>与Activity相同，系统会Fragment的onSaveInstanceState()方法，savedInstanceState会在 onCreate()、onCreateView()、onActivityCreated()方法中被传入。</p>\n<h2 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h2><h3 id=\"为什么要使用Loader\"><a href=\"#为什么要使用Loader\" class=\"headerlink\" title=\"为什么要使用Loader\"></a>为什么要使用Loader</h3><ul>\n<li>Loader运行在单独线程中（车有轮子…）。</li>\n<li>Loader简化了Worker线程和主线程之间的交流（AsyncTask也行）。</li>\n<li>Loader当Activity发生configuration changes时，加载结果会得以保存（都MVP了，不过在轻量级实现时有一定意义）。</li>\n<li>Loader会在数据源变化时产生响应，例如ContentProvider（有一定意义，跟LiveData有何不同）。<br>*</li>\n</ul>\n<h3 id=\"使用Loader\"><a href=\"#使用Loader\" class=\"headerlink\" title=\"使用Loader\"></a>使用Loader</h3><p>Loader相关的API主要包含在LoaderManager，LoaderManager.LoaderCallbacks和Loader三个class &amp; interface中。</p>\n<ul>\n<li>LoaderManager，每个Activity &amp; Fragment绑定唯一一个LoaderManager，可以通过getLoaderManager()获取。</li>\n<li>LoaderManager.LoaderCallbacks，绑定Loader回调接口，返回Loader的加载状态和加载结果。</li>\n<li>Loader，开发者自己实现Loader或者使用系统提供的工具Loader，实现具体的加载过程。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>DialogFragment vs Dialog。</li>\n<li>FragmentManager in Detail。</li>\n<li>multiple fragments to the same container。 </li>\n<li>Fragment and Menus。</li>\n<li>Fragment lifecycle in Detail。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>经过commit()方法提交Fragment更改应该发生在Activity进行SaveInstanceState之前，如果在SaveInstanceState之后这么做会抛出异常；如果一定要在SaveInstanceState之后提交Fragment更改，使用commitAllowingStateLoss()。</li>\n<li>如果要Fragment能够收到onCreateOptionsMenu()回调，需要在Activity处于Created状态时调用setHasOptionsMenu()。</li>\n</ul>\n<h2 id=\"Fragments\"><a href=\"#Fragments\" class=\"headerlink\" title=\"Fragments\"></a>Fragments</h2><h3 id=\"创建Fragment\"><a href=\"#创建Fragment\" class=\"headerlink\" title=\"创建Fragment\"></a>创建Fragment</h3><p>创建包含UI的Fragment有两种途径：</p>\n<ul>\n<li>在layout文件中声明<code>&lt;fragment&gt;</code>标签，如同使用View一样；系统会用onCreateView()返回的View替换<code>&lt;fragment&gt;</code>标签。</li>\n<li>使用FragmentTransaction.add(int, Fragment)方法提交fragment。</li>\n</ul>\n<p>创建不包含UI的Fragment，需要使用FragmentTransaction.add(Fragment, String)方法，String参数代表了Fragment的Tag。因为不包含UI的Fragment不存在于View结构中，通过Activity查找它的唯一方法是findFragmentByTag()。</p>\n<p>每个Fragment必须有一个唯一标识，系统寻找这个标识有三种方式：  </p>\n<ul>\n<li>android:id属性。</li>\n<li>android:tag属性。</li>\n<li>如果前两条都不存在，系统会使用fragment的parent viewgroup的id。</li>\n</ul>\n<h3 id=\"Fragment和Activity的交流\"><a href=\"#Fragment和Activity的交流\" class=\"headerlink\" title=\"Fragment和Activity的交流\"></a>Fragment和Activity的交流</h3><ul>\n<li>Fragment中可以通过getActivity()或得所属的Activity。</li>\n<li>Fragment定义Listner类的Interface来给Activity回调。</li>\n<li>Fragment可以参与Options Menu和Context Menu。</li>\n</ul>\n<h3 id=\"Fragment的生命周期\"><a href=\"#Fragment的生命周期\" class=\"headerlink\" title=\"Fragment的生命周期\"></a>Fragment的生命周期</h3><p><img src=\"https://developer.android.google.cn/images/activity_fragment_lifecycle.png\" alt=\"Fragment生命周期图\"></p>\n<p>与Activity相同，系统会Fragment的onSaveInstanceState()方法，savedInstanceState会在 onCreate()、onCreateView()、onActivityCreated()方法中被传入。</p>\n<h2 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h2><h3 id=\"为什么要使用Loader\"><a href=\"#为什么要使用Loader\" class=\"headerlink\" title=\"为什么要使用Loader\"></a>为什么要使用Loader</h3><ul>\n<li>Loader运行在单独线程中（车有轮子…）。</li>\n<li>Loader简化了Worker线程和主线程之间的交流（AsyncTask也行）。</li>\n<li>Loader当Activity发生configuration changes时，加载结果会得以保存（都MVP了，不过在轻量级实现时有一定意义）。</li>\n<li>Loader会在数据源变化时产生响应，例如ContentProvider（有一定意义，跟LiveData有何不同）。<br>*</li>\n</ul>\n<h3 id=\"使用Loader\"><a href=\"#使用Loader\" class=\"headerlink\" title=\"使用Loader\"></a>使用Loader</h3><p>Loader相关的API主要包含在LoaderManager，LoaderManager.LoaderCallbacks和Loader三个class &amp; interface中。</p>\n<ul>\n<li>LoaderManager，每个Activity &amp; Fragment绑定唯一一个LoaderManager，可以通过getLoaderManager()获取。</li>\n<li>LoaderManager.LoaderCallbacks，绑定Loader回调接口，返回Loader的加载状态和加载结果。</li>\n<li>Loader，开发者自己实现Loader或者使用系统提供的工具Loader，实现具体的加载过程。</li>\n</ul>\n"},{"title":"Android Developer Guide中的Intent","subtitle":"Android官方guide随笔 - App Components：Intent","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-07-26T10:13:13.000Z","_content":"\n## 展开点  \n* MIME Type & URI结构。\n* Intent Flags。\n* CATEGORY_DEFAULT的意义。 \n* 如何根据content provider类型URI推断Intent Data的MIME Type，对Intent Resolve有什么影响。\n*  ClipData的用处。\n* DocumentsProvider。\n\n## Caution   \n* 不要为Service添加Intent filter，不要使用implicit intent启动Service。在5.0以上，使用implicit intent调用bindService()，系统会抛出异常。\n* Intent的静态常量中定义了一些通用的action、category和extra key字符串；Settings的静态常量定义了一些打开Settings App界面的action。\n* Intent的setData方法和setType方法会相互将对方置空（setData会置空mType，setType会置空mData，优秀的设计...）；同时set需要调用setDataAndType。\n* 在使用implicit intent时使用Intent.resolveActivity()检查有没有App响应这个Intent；如果没有Activity适合Intent的话，startActivity()会抛异常。\n* （对于Activity而言）为了能收到implicit intent，在intent-filter中必须声明CATEGORY_DEFAULT，因为startActivity()和startActivityForResult()会默认添加CATEGORY_DEFAULT。\n\n\n## Intents and Intent Filters   \n\nIntent用于Component之间的交流、传递信息，依赖Intent的Component包括Activity、Servcie和Recevier（不包括Provider）。\n\n### Intent的分类 \n\nIntent分为Explicit intents和Implicit intents两类，其区别就是Intent中是否包含ComponentName。\n\n### Intent组成    \n\nIntent中包含的主要成分如下：\n\n* Component name，区分Explicit intents和Implicit intents成分。Intent中的Component name属性是一个ComponentName对象。\n* Action，表明Intent作希望执行的操作。Android系统有很多预定义的Action，同时Action通常也决定了Intent的结构(data、extra等)。\n* Data，由URI和MIME type组成，做为Action的补充，代表Action的目标数据&数据类型。如果URI是content: URI，MIME type往往可以由URI推断出。\n* Category，表明希望哪些类型的Component响应Intent。\n* Extras，extras是一个Bundle对象，传递额外数据。\n* Flags，一些标志位用于告知Android系统如何使用这个Intent。\n\nComponent name、Action、Data和Category这四种成分会影响Intent Resolve。 \n\n借助Intent.createChooer()方法，可以在发送implicit intent时强制显示chooer dialog（尽管用户之前在chooer dialog选择了默认处理intent的App）。\n\n### 接收implicit intent   \n\n组件通过在manifest文件中定义`<intent-filter>`来接收implicit intent，组件可以定义多个`<intent-filter>`。\n\nexplicit intent将无视`<intent-filter>`以及由`<intent-filter>`定义的intent resolve规则。\n\n`<intent-filter>`由三类标签组成：`<action>`、`<data>`、`<category>`。每类标签可以有一个或多个（或没有）。\n当你定义多个`<action>`、`<data>`或`<category>`时，你所维护Component需要能够处理由这些标签任意组合而成的Intent；如果你只想处理特定组合，定义多个`<intent-filter>`。\n\n在manifest中Component的android:exported属性可以控制该Component是否能被其他App调用。当android:exported为false时，Component仅能被相同UID的App调用。没有Intent-filter的Activity的android:exported属性默认值是false。\n\n### 使用PendingIntent   \n\n>The primary purpose of a PendingIntent is to grant permission to a foreign \n>application to use the contained Intent as if it were executed from your \n>app's own process.\n\n### Intent resovle规则   \n\nIntent若要通过Intent filter的检验，则需要通过Action检验、Data检验、Category检验三部分。\n\n* Action检验。\n    - 当Intent包含某个Intent filter中声明的action时可通过Action检验。\n    - 如果Intent filter没有声明action，任何Intent都无法通过Action检验。\n    - 如果Intent中不包含action，那么只要Intent filter声明了任意action，就可通过Acton检验。\n* Category检验。\n    - 当Intent中定义的所有category都在Intent filter中被声明，可通过Category检验。\n* Data检验。Data检验包括URI检验和MIME type检验；URI检验仅检验Intent filter中定义的部分。\n    - 如果Intent不包含URI和MIME type，仅在Intent filter没声明data条件时通过。\n    - 如果Intent仅包含URI，仅在URI和Intent filter匹配，且Intent filter没声明type条件时通过。\n    - 如果Intent仅包含MIME type，仅在type和Intent filter匹配，且Intent filter没声明URI条件时通过。\n    - 如果Intent包含URI和MIME type，在URI和type均匹配时通过；或者在type匹配，Intent的URI为content:、file:类型，且Intent filter没有定义URI条件时通过。\n\n\n## Common Intents   \n\n介绍一些Android系统预先定义的Action，以及相应的Intent结构和经由onActivityResult返回Intent的结构。\n\n### 通过adb命令测试Intent   \nadb shell am start -a `<ACTION>` -t `<MIME_TYPE>` -d `<DATA>` -e `<EXTRA_NAME>` `<EXTRA_VALUE>` -n `<ACTIVITY>`。\n\n","source":"_posts/android-developers-guide-note-app-components-intents.md","raw":"---\ntitle: Android Developer Guide中的Intent\nsubtitle: Android官方guide随笔 - App Components：Intent\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-07-26 18:13:13\n---\n\n## 展开点  \n* MIME Type & URI结构。\n* Intent Flags。\n* CATEGORY_DEFAULT的意义。 \n* 如何根据content provider类型URI推断Intent Data的MIME Type，对Intent Resolve有什么影响。\n*  ClipData的用处。\n* DocumentsProvider。\n\n## Caution   \n* 不要为Service添加Intent filter，不要使用implicit intent启动Service。在5.0以上，使用implicit intent调用bindService()，系统会抛出异常。\n* Intent的静态常量中定义了一些通用的action、category和extra key字符串；Settings的静态常量定义了一些打开Settings App界面的action。\n* Intent的setData方法和setType方法会相互将对方置空（setData会置空mType，setType会置空mData，优秀的设计...）；同时set需要调用setDataAndType。\n* 在使用implicit intent时使用Intent.resolveActivity()检查有没有App响应这个Intent；如果没有Activity适合Intent的话，startActivity()会抛异常。\n* （对于Activity而言）为了能收到implicit intent，在intent-filter中必须声明CATEGORY_DEFAULT，因为startActivity()和startActivityForResult()会默认添加CATEGORY_DEFAULT。\n\n\n## Intents and Intent Filters   \n\nIntent用于Component之间的交流、传递信息，依赖Intent的Component包括Activity、Servcie和Recevier（不包括Provider）。\n\n### Intent的分类 \n\nIntent分为Explicit intents和Implicit intents两类，其区别就是Intent中是否包含ComponentName。\n\n### Intent组成    \n\nIntent中包含的主要成分如下：\n\n* Component name，区分Explicit intents和Implicit intents成分。Intent中的Component name属性是一个ComponentName对象。\n* Action，表明Intent作希望执行的操作。Android系统有很多预定义的Action，同时Action通常也决定了Intent的结构(data、extra等)。\n* Data，由URI和MIME type组成，做为Action的补充，代表Action的目标数据&数据类型。如果URI是content: URI，MIME type往往可以由URI推断出。\n* Category，表明希望哪些类型的Component响应Intent。\n* Extras，extras是一个Bundle对象，传递额外数据。\n* Flags，一些标志位用于告知Android系统如何使用这个Intent。\n\nComponent name、Action、Data和Category这四种成分会影响Intent Resolve。 \n\n借助Intent.createChooer()方法，可以在发送implicit intent时强制显示chooer dialog（尽管用户之前在chooer dialog选择了默认处理intent的App）。\n\n### 接收implicit intent   \n\n组件通过在manifest文件中定义`<intent-filter>`来接收implicit intent，组件可以定义多个`<intent-filter>`。\n\nexplicit intent将无视`<intent-filter>`以及由`<intent-filter>`定义的intent resolve规则。\n\n`<intent-filter>`由三类标签组成：`<action>`、`<data>`、`<category>`。每类标签可以有一个或多个（或没有）。\n当你定义多个`<action>`、`<data>`或`<category>`时，你所维护Component需要能够处理由这些标签任意组合而成的Intent；如果你只想处理特定组合，定义多个`<intent-filter>`。\n\n在manifest中Component的android:exported属性可以控制该Component是否能被其他App调用。当android:exported为false时，Component仅能被相同UID的App调用。没有Intent-filter的Activity的android:exported属性默认值是false。\n\n### 使用PendingIntent   \n\n>The primary purpose of a PendingIntent is to grant permission to a foreign \n>application to use the contained Intent as if it were executed from your \n>app's own process.\n\n### Intent resovle规则   \n\nIntent若要通过Intent filter的检验，则需要通过Action检验、Data检验、Category检验三部分。\n\n* Action检验。\n    - 当Intent包含某个Intent filter中声明的action时可通过Action检验。\n    - 如果Intent filter没有声明action，任何Intent都无法通过Action检验。\n    - 如果Intent中不包含action，那么只要Intent filter声明了任意action，就可通过Acton检验。\n* Category检验。\n    - 当Intent中定义的所有category都在Intent filter中被声明，可通过Category检验。\n* Data检验。Data检验包括URI检验和MIME type检验；URI检验仅检验Intent filter中定义的部分。\n    - 如果Intent不包含URI和MIME type，仅在Intent filter没声明data条件时通过。\n    - 如果Intent仅包含URI，仅在URI和Intent filter匹配，且Intent filter没声明type条件时通过。\n    - 如果Intent仅包含MIME type，仅在type和Intent filter匹配，且Intent filter没声明URI条件时通过。\n    - 如果Intent包含URI和MIME type，在URI和type均匹配时通过；或者在type匹配，Intent的URI为content:、file:类型，且Intent filter没有定义URI条件时通过。\n\n\n## Common Intents   \n\n介绍一些Android系统预先定义的Action，以及相应的Intent结构和经由onActivityResult返回Intent的结构。\n\n### 通过adb命令测试Intent   \nadb shell am start -a `<ACTION>` -t `<MIME_TYPE>` -d `<DATA>` -e `<EXTRA_NAME>` `<EXTRA_VALUE>` -n `<ACTIVITY>`。\n\n","slug":"android-developers-guide-note-app-components-intents","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p2000n3mrf8xey78hp","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>MIME Type &amp; URI结构。</li>\n<li>Intent Flags。</li>\n<li>CATEGORY_DEFAULT的意义。 </li>\n<li>如何根据content provider类型URI推断Intent Data的MIME Type，对Intent Resolve有什么影响。</li>\n<li>ClipData的用处。</li>\n<li>DocumentsProvider。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>不要为Service添加Intent filter，不要使用implicit intent启动Service。在5.0以上，使用implicit intent调用bindService()，系统会抛出异常。</li>\n<li>Intent的静态常量中定义了一些通用的action、category和extra key字符串；Settings的静态常量定义了一些打开Settings App界面的action。</li>\n<li>Intent的setData方法和setType方法会相互将对方置空（setData会置空mType，setType会置空mData，优秀的设计…）；同时set需要调用setDataAndType。</li>\n<li>在使用implicit intent时使用Intent.resolveActivity()检查有没有App响应这个Intent；如果没有Activity适合Intent的话，startActivity()会抛异常。</li>\n<li>（对于Activity而言）为了能收到implicit intent，在intent-filter中必须声明CATEGORY_DEFAULT，因为startActivity()和startActivityForResult()会默认添加CATEGORY_DEFAULT。</li>\n</ul>\n<h2 id=\"Intents-and-Intent-Filters\"><a href=\"#Intents-and-Intent-Filters\" class=\"headerlink\" title=\"Intents and Intent Filters\"></a>Intents and Intent Filters</h2><p>Intent用于Component之间的交流、传递信息，依赖Intent的Component包括Activity、Servcie和Recevier（不包括Provider）。</p>\n<h3 id=\"Intent的分类\"><a href=\"#Intent的分类\" class=\"headerlink\" title=\"Intent的分类\"></a>Intent的分类</h3><p>Intent分为Explicit intents和Implicit intents两类，其区别就是Intent中是否包含ComponentName。</p>\n<h3 id=\"Intent组成\"><a href=\"#Intent组成\" class=\"headerlink\" title=\"Intent组成\"></a>Intent组成</h3><p>Intent中包含的主要成分如下：</p>\n<ul>\n<li>Component name，区分Explicit intents和Implicit intents成分。Intent中的Component name属性是一个ComponentName对象。</li>\n<li>Action，表明Intent作希望执行的操作。Android系统有很多预定义的Action，同时Action通常也决定了Intent的结构(data、extra等)。</li>\n<li>Data，由URI和MIME type组成，做为Action的补充，代表Action的目标数据&amp;数据类型。如果URI是content: URI，MIME type往往可以由URI推断出。</li>\n<li>Category，表明希望哪些类型的Component响应Intent。</li>\n<li>Extras，extras是一个Bundle对象，传递额外数据。</li>\n<li>Flags，一些标志位用于告知Android系统如何使用这个Intent。</li>\n</ul>\n<p>Component name、Action、Data和Category这四种成分会影响Intent Resolve。 </p>\n<p>借助Intent.createChooer()方法，可以在发送implicit intent时强制显示chooer dialog（尽管用户之前在chooer dialog选择了默认处理intent的App）。</p>\n<h3 id=\"接收implicit-intent\"><a href=\"#接收implicit-intent\" class=\"headerlink\" title=\"接收implicit intent\"></a>接收implicit intent</h3><p>组件通过在manifest文件中定义<code>&lt;intent-filter&gt;</code>来接收implicit intent，组件可以定义多个<code>&lt;intent-filter&gt;</code>。</p>\n<p>explicit intent将无视<code>&lt;intent-filter&gt;</code>以及由<code>&lt;intent-filter&gt;</code>定义的intent resolve规则。</p>\n<p><code>&lt;intent-filter&gt;</code>由三类标签组成：<code>&lt;action&gt;</code>、<code>&lt;data&gt;</code>、<code>&lt;category&gt;</code>。每类标签可以有一个或多个（或没有）。<br>当你定义多个<code>&lt;action&gt;</code>、<code>&lt;data&gt;</code>或<code>&lt;category&gt;</code>时，你所维护Component需要能够处理由这些标签任意组合而成的Intent；如果你只想处理特定组合，定义多个<code>&lt;intent-filter&gt;</code>。</p>\n<p>在manifest中Component的android:exported属性可以控制该Component是否能被其他App调用。当android:exported为false时，Component仅能被相同UID的App调用。没有Intent-filter的Activity的android:exported属性默认值是false。</p>\n<h3 id=\"使用PendingIntent\"><a href=\"#使用PendingIntent\" class=\"headerlink\" title=\"使用PendingIntent\"></a>使用PendingIntent</h3><blockquote>\n<p>The primary purpose of a PendingIntent is to grant permission to a foreign<br>application to use the contained Intent as if it were executed from your<br>app’s own process.</p>\n</blockquote>\n<h3 id=\"Intent-resovle规则\"><a href=\"#Intent-resovle规则\" class=\"headerlink\" title=\"Intent resovle规则\"></a>Intent resovle规则</h3><p>Intent若要通过Intent filter的检验，则需要通过Action检验、Data检验、Category检验三部分。</p>\n<ul>\n<li>Action检验。<ul>\n<li>当Intent包含某个Intent filter中声明的action时可通过Action检验。</li>\n<li>如果Intent filter没有声明action，任何Intent都无法通过Action检验。</li>\n<li>如果Intent中不包含action，那么只要Intent filter声明了任意action，就可通过Acton检验。</li>\n</ul>\n</li>\n<li>Category检验。<ul>\n<li>当Intent中定义的所有category都在Intent filter中被声明，可通过Category检验。</li>\n</ul>\n</li>\n<li>Data检验。Data检验包括URI检验和MIME type检验；URI检验仅检验Intent filter中定义的部分。<ul>\n<li>如果Intent不包含URI和MIME type，仅在Intent filter没声明data条件时通过。</li>\n<li>如果Intent仅包含URI，仅在URI和Intent filter匹配，且Intent filter没声明type条件时通过。</li>\n<li>如果Intent仅包含MIME type，仅在type和Intent filter匹配，且Intent filter没声明URI条件时通过。</li>\n<li>如果Intent包含URI和MIME type，在URI和type均匹配时通过；或者在type匹配，Intent的URI为content:、file:类型，且Intent filter没有定义URI条件时通过。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Common-Intents\"><a href=\"#Common-Intents\" class=\"headerlink\" title=\"Common Intents\"></a>Common Intents</h2><p>介绍一些Android系统预先定义的Action，以及相应的Intent结构和经由onActivityResult返回Intent的结构。</p>\n<h3 id=\"通过adb命令测试Intent\"><a href=\"#通过adb命令测试Intent\" class=\"headerlink\" title=\"通过adb命令测试Intent\"></a>通过adb命令测试Intent</h3><p>adb shell am start -a <code>&lt;ACTION&gt;</code> -t <code>&lt;MIME_TYPE&gt;</code> -d <code>&lt;DATA&gt;</code> -e <code>&lt;EXTRA_NAME&gt;</code> <code>&lt;EXTRA_VALUE&gt;</code> -n <code>&lt;ACTIVITY&gt;</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>MIME Type &amp; URI结构。</li>\n<li>Intent Flags。</li>\n<li>CATEGORY_DEFAULT的意义。 </li>\n<li>如何根据content provider类型URI推断Intent Data的MIME Type，对Intent Resolve有什么影响。</li>\n<li>ClipData的用处。</li>\n<li>DocumentsProvider。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>不要为Service添加Intent filter，不要使用implicit intent启动Service。在5.0以上，使用implicit intent调用bindService()，系统会抛出异常。</li>\n<li>Intent的静态常量中定义了一些通用的action、category和extra key字符串；Settings的静态常量定义了一些打开Settings App界面的action。</li>\n<li>Intent的setData方法和setType方法会相互将对方置空（setData会置空mType，setType会置空mData，优秀的设计…）；同时set需要调用setDataAndType。</li>\n<li>在使用implicit intent时使用Intent.resolveActivity()检查有没有App响应这个Intent；如果没有Activity适合Intent的话，startActivity()会抛异常。</li>\n<li>（对于Activity而言）为了能收到implicit intent，在intent-filter中必须声明CATEGORY_DEFAULT，因为startActivity()和startActivityForResult()会默认添加CATEGORY_DEFAULT。</li>\n</ul>\n<h2 id=\"Intents-and-Intent-Filters\"><a href=\"#Intents-and-Intent-Filters\" class=\"headerlink\" title=\"Intents and Intent Filters\"></a>Intents and Intent Filters</h2><p>Intent用于Component之间的交流、传递信息，依赖Intent的Component包括Activity、Servcie和Recevier（不包括Provider）。</p>\n<h3 id=\"Intent的分类\"><a href=\"#Intent的分类\" class=\"headerlink\" title=\"Intent的分类\"></a>Intent的分类</h3><p>Intent分为Explicit intents和Implicit intents两类，其区别就是Intent中是否包含ComponentName。</p>\n<h3 id=\"Intent组成\"><a href=\"#Intent组成\" class=\"headerlink\" title=\"Intent组成\"></a>Intent组成</h3><p>Intent中包含的主要成分如下：</p>\n<ul>\n<li>Component name，区分Explicit intents和Implicit intents成分。Intent中的Component name属性是一个ComponentName对象。</li>\n<li>Action，表明Intent作希望执行的操作。Android系统有很多预定义的Action，同时Action通常也决定了Intent的结构(data、extra等)。</li>\n<li>Data，由URI和MIME type组成，做为Action的补充，代表Action的目标数据&amp;数据类型。如果URI是content: URI，MIME type往往可以由URI推断出。</li>\n<li>Category，表明希望哪些类型的Component响应Intent。</li>\n<li>Extras，extras是一个Bundle对象，传递额外数据。</li>\n<li>Flags，一些标志位用于告知Android系统如何使用这个Intent。</li>\n</ul>\n<p>Component name、Action、Data和Category这四种成分会影响Intent Resolve。 </p>\n<p>借助Intent.createChooer()方法，可以在发送implicit intent时强制显示chooer dialog（尽管用户之前在chooer dialog选择了默认处理intent的App）。</p>\n<h3 id=\"接收implicit-intent\"><a href=\"#接收implicit-intent\" class=\"headerlink\" title=\"接收implicit intent\"></a>接收implicit intent</h3><p>组件通过在manifest文件中定义<code>&lt;intent-filter&gt;</code>来接收implicit intent，组件可以定义多个<code>&lt;intent-filter&gt;</code>。</p>\n<p>explicit intent将无视<code>&lt;intent-filter&gt;</code>以及由<code>&lt;intent-filter&gt;</code>定义的intent resolve规则。</p>\n<p><code>&lt;intent-filter&gt;</code>由三类标签组成：<code>&lt;action&gt;</code>、<code>&lt;data&gt;</code>、<code>&lt;category&gt;</code>。每类标签可以有一个或多个（或没有）。<br>当你定义多个<code>&lt;action&gt;</code>、<code>&lt;data&gt;</code>或<code>&lt;category&gt;</code>时，你所维护Component需要能够处理由这些标签任意组合而成的Intent；如果你只想处理特定组合，定义多个<code>&lt;intent-filter&gt;</code>。</p>\n<p>在manifest中Component的android:exported属性可以控制该Component是否能被其他App调用。当android:exported为false时，Component仅能被相同UID的App调用。没有Intent-filter的Activity的android:exported属性默认值是false。</p>\n<h3 id=\"使用PendingIntent\"><a href=\"#使用PendingIntent\" class=\"headerlink\" title=\"使用PendingIntent\"></a>使用PendingIntent</h3><blockquote>\n<p>The primary purpose of a PendingIntent is to grant permission to a foreign<br>application to use the contained Intent as if it were executed from your<br>app’s own process.</p>\n</blockquote>\n<h3 id=\"Intent-resovle规则\"><a href=\"#Intent-resovle规则\" class=\"headerlink\" title=\"Intent resovle规则\"></a>Intent resovle规则</h3><p>Intent若要通过Intent filter的检验，则需要通过Action检验、Data检验、Category检验三部分。</p>\n<ul>\n<li>Action检验。<ul>\n<li>当Intent包含某个Intent filter中声明的action时可通过Action检验。</li>\n<li>如果Intent filter没有声明action，任何Intent都无法通过Action检验。</li>\n<li>如果Intent中不包含action，那么只要Intent filter声明了任意action，就可通过Acton检验。</li>\n</ul>\n</li>\n<li>Category检验。<ul>\n<li>当Intent中定义的所有category都在Intent filter中被声明，可通过Category检验。</li>\n</ul>\n</li>\n<li>Data检验。Data检验包括URI检验和MIME type检验；URI检验仅检验Intent filter中定义的部分。<ul>\n<li>如果Intent不包含URI和MIME type，仅在Intent filter没声明data条件时通过。</li>\n<li>如果Intent仅包含URI，仅在URI和Intent filter匹配，且Intent filter没声明type条件时通过。</li>\n<li>如果Intent仅包含MIME type，仅在type和Intent filter匹配，且Intent filter没声明URI条件时通过。</li>\n<li>如果Intent包含URI和MIME type，在URI和type均匹配时通过；或者在type匹配，Intent的URI为content:、file:类型，且Intent filter没有定义URI条件时通过。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Common-Intents\"><a href=\"#Common-Intents\" class=\"headerlink\" title=\"Common Intents\"></a>Common Intents</h2><p>介绍一些Android系统预先定义的Action，以及相应的Intent结构和经由onActivityResult返回Intent的结构。</p>\n<h3 id=\"通过adb命令测试Intent\"><a href=\"#通过adb命令测试Intent\" class=\"headerlink\" title=\"通过adb命令测试Intent\"></a>通过adb命令测试Intent</h3><p>adb shell am start -a <code>&lt;ACTION&gt;</code> -t <code>&lt;MIME_TYPE&gt;</code> -d <code>&lt;DATA&gt;</code> -e <code>&lt;EXTRA_NAME&gt;</code> <code>&lt;EXTRA_VALUE&gt;</code> -n <code>&lt;ACTIVITY&gt;</code>。</p>\n"},{"title":"Android Developer Guide中的其他话题","subtitle":"Android官方guide随笔 - App Components：Others","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-08-21T09:19:18.000Z","_content":"\n\n## 展开点\n\n* [Background Optimizations](https://www.youtube.com/watch?v=vBjTXKpaFj8&feature=youtu.be)。\n*  foreground broadcast and receiver；FLAG_RECEIVER_FOREGROUND。\n*  custom permission的定义App和使用App的安装顺序；如果在permission还没定义时使用会发生什么。\n*  explicit intent with receiver。\n*  local broadcast and receiver。\n*  [Intelligent Job-Scheduling](https://developer.android.google.cn/topic/performance/scheduling.html)。\n*  Resize App Widget。\n*  ViewStub。\n*  AppWidgetManager in Detail。\n*  orderedBroadcast。 \n*  [Launcher](https://android.googlesource.com/platform/packages/apps/Launcher3/)。\n\n## Cautions\n\n* 所有的系统Broadcast记录在Android SDK的BROADCAST_ACTIONS.TXT文件中。\n* 通过context注册的receivers的作用时间和context的生命周期一样长，例如Activity和Application。\n\n## Broadcasts\n\n### 系统广播   \n\nAndroid 7.0之后系统不再发ACTION_NEW_PICTURE和ACTION_NEW_VIDEO广播；CONNECTIVITY_ACTION只能用动态注册的receiver接受。\n\n### 接收广播\n\nApp通过manifest的`<receiver>`标签生命receiver，package manager会在app安装的时候注册receiver，receiver仅在onReceive执行时处于active状态。\n\n通过Context.registerReceiver方法动态注册receiver；也可以通过LocalBroadcastManager.registerReceiver动态注册local receiver。\nlocal broadcast执行效率更高，无需跨越app的时候使用local broadcast。\n\n#### goAsync()\n\n调用goAsync()可以使receiver在onReceive返回之后仍处于active状态，处于active状态不会超过receiver的10秒限制，可以通过goAsync()返回的PendingResult对象的PendingResult.finish()方法终结receiver的active状态(在后台线程里)。\n\n### 发送广播\n\n使用sendBroadcast(Intent)或者LocalBroadcastManager.sendBroadcast。\nAndroid 4.0之后，通过Intent.setPackage()限制哪些应用可以收到这次广播。\n\n### 最佳实践\n\n* 无需跨app时使用local broadcast，执行效率更高。\n* 如果可以动态注册receiver就不要静态注册，以免拖慢系统。\n* 确保广播的action是unique的。\n* 不要在onReceiver里直接启动线程，除非使用goAsync()或者Service。\n* 不要通过receiver启动activity。\n\n## App Widget\n\nApp Widget就是可以被嵌入其他应用中的一块View。\n\n### 基础\n\n构建App Widget需要以下工作：\n\n* AppWidgetProviderInfo，xml形式的metadata文件，用于配置AppWidget的属性。\n* AppWidgetProvider的实现类。\n* layout文件。\n* AppWidget的configuration Activity，是AppWidet的可选组成部分。\n\n### 在Manifest中  \n\n* `<receiver>`标签：AppWidgetProvider继承自receiver，在manifest文件中通过`<receiver>`标签来声明AppWidgetProvider。\n* `<intent-filter>`标签：`<intent-filter>`必须包含声明ACTION_APPWIDGET_UPDATE的`<action>`标签。\n* `<meta-data>`标签：用于声明AppWidgetProviderInfo，androidLname值为android.appwidget.provider，android:resource为metadata的xml文件的位置。\n\n### MetaData\n\nAppWidgetProviderInfo包含了AppWidget的配置信息，通过res/xml下包含单独` <appwidget-provider>`标签的xml文件定义。\n\n`<appwidget-provider>`的属性：\n\n* minWidth & minHeight，描述widget占据的默认空间，系统会将其值近似到整cell。\n* minResizeWidth & minResizeHeight，配合Android 3.1的缩放widget功能，描述widget的最小尺寸。\n* updatePeriodMillis，调用AppWidgetProvider.update()的时间间隔，“0”代表从不。\n* initialLayout，layout文件。\n* configure，configuration Activity。\n* previewImage，预览图。\n* resizeMode，缩放方式例如\"vertical\"、\"horizental\"、\"none\"。\n* widgetCategory，widget的显示位置例如\"home_screen\"或\"keyguard\"；在5.0后不支持锁屏widget。\n\nWidget的update事件会将睡眠的设备唤醒，从而增加电量消耗。如果不需要再睡眠期间update widget可以使用AlarmMananger来代替（AlarmMananger不会唤醒设备）。\n\n### Widget布局文件   \n\n#### 设置margin \n\nwidget需要和其他widget & app icon有一些margin，不然很丑。\n在Android 4.0之后会自动给widget加入margin，所以targetSdkVersion=14。\n如果需要兼容旧系统，可以在layout中设置padding，padding值在大于等于14时为0即可。\n\n### 实现AppWidgetProvider类\n\n需要实现的回调接口：\n\n* onUpdate()，如果没有定义configuration activity，在第一次创建Widget的时候也会回调，所以需要负责setup工作。\n* onAppWidgetOptionsChanged()，在widget实例第一次被放置或者widget被缩放时调用。\n* onDeleted()，任意widget实例被删除时调用。\n* onEnabled & onDisabled，第一个widget实例被创建时 & 最后一个widget实例被删除时调用。\n\nAppWidgetProvider仅仅是个工具类，开发者也可以直接继承receiver来辅助widget。\n\n### Configuration Activity\n\nConfiguration Activity会在Widget创建的时候被Widget host调用；Configuration Activity在manifest中必须包含action=ACTION_APPWIDGET_CONFIGURE的intent-filter。\nConfiguration Activity需要返回result；result和启动的Intent都需要包含\nEXTRA_APPWIDGET_ID，代表widget id。\n\ntip：在启动时就setResult中加入RESULT_CANCELED和EXTRA_APPWIDGET_ID，以防activity通过其他逻辑分支退出。\n\n### 预览图 \n\nAndroid模拟器包含应用\"Widget Preview\"，方便制作widget预览图。\n\n### AppWidget显示列表\n\n//TODO:加入展开列表\n\n## App Widget Host\n\n//TODO:加入展开列表\n\n## Processes and Threads\n\n默认情况下，同一个App的Component都是运行在同一个进程的主线程上。\n\n通过Component标签的android:process属性可以使得同一个App的Component运行在不同进程中，或者使不同App的Component运行在同一进程中。\n借助`<application>`的android:process属性设置App的默认进程名。\n\n","source":"_posts/android-developers-guide-note-app-components-others.md","raw":"---\ntitle: Android Developer Guide中的其他话题\nsubtitle: Android官方guide随笔 - App Components：Others\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-08-21 17:19:18\n---\n\n\n## 展开点\n\n* [Background Optimizations](https://www.youtube.com/watch?v=vBjTXKpaFj8&feature=youtu.be)。\n*  foreground broadcast and receiver；FLAG_RECEIVER_FOREGROUND。\n*  custom permission的定义App和使用App的安装顺序；如果在permission还没定义时使用会发生什么。\n*  explicit intent with receiver。\n*  local broadcast and receiver。\n*  [Intelligent Job-Scheduling](https://developer.android.google.cn/topic/performance/scheduling.html)。\n*  Resize App Widget。\n*  ViewStub。\n*  AppWidgetManager in Detail。\n*  orderedBroadcast。 \n*  [Launcher](https://android.googlesource.com/platform/packages/apps/Launcher3/)。\n\n## Cautions\n\n* 所有的系统Broadcast记录在Android SDK的BROADCAST_ACTIONS.TXT文件中。\n* 通过context注册的receivers的作用时间和context的生命周期一样长，例如Activity和Application。\n\n## Broadcasts\n\n### 系统广播   \n\nAndroid 7.0之后系统不再发ACTION_NEW_PICTURE和ACTION_NEW_VIDEO广播；CONNECTIVITY_ACTION只能用动态注册的receiver接受。\n\n### 接收广播\n\nApp通过manifest的`<receiver>`标签生命receiver，package manager会在app安装的时候注册receiver，receiver仅在onReceive执行时处于active状态。\n\n通过Context.registerReceiver方法动态注册receiver；也可以通过LocalBroadcastManager.registerReceiver动态注册local receiver。\nlocal broadcast执行效率更高，无需跨越app的时候使用local broadcast。\n\n#### goAsync()\n\n调用goAsync()可以使receiver在onReceive返回之后仍处于active状态，处于active状态不会超过receiver的10秒限制，可以通过goAsync()返回的PendingResult对象的PendingResult.finish()方法终结receiver的active状态(在后台线程里)。\n\n### 发送广播\n\n使用sendBroadcast(Intent)或者LocalBroadcastManager.sendBroadcast。\nAndroid 4.0之后，通过Intent.setPackage()限制哪些应用可以收到这次广播。\n\n### 最佳实践\n\n* 无需跨app时使用local broadcast，执行效率更高。\n* 如果可以动态注册receiver就不要静态注册，以免拖慢系统。\n* 确保广播的action是unique的。\n* 不要在onReceiver里直接启动线程，除非使用goAsync()或者Service。\n* 不要通过receiver启动activity。\n\n## App Widget\n\nApp Widget就是可以被嵌入其他应用中的一块View。\n\n### 基础\n\n构建App Widget需要以下工作：\n\n* AppWidgetProviderInfo，xml形式的metadata文件，用于配置AppWidget的属性。\n* AppWidgetProvider的实现类。\n* layout文件。\n* AppWidget的configuration Activity，是AppWidet的可选组成部分。\n\n### 在Manifest中  \n\n* `<receiver>`标签：AppWidgetProvider继承自receiver，在manifest文件中通过`<receiver>`标签来声明AppWidgetProvider。\n* `<intent-filter>`标签：`<intent-filter>`必须包含声明ACTION_APPWIDGET_UPDATE的`<action>`标签。\n* `<meta-data>`标签：用于声明AppWidgetProviderInfo，androidLname值为android.appwidget.provider，android:resource为metadata的xml文件的位置。\n\n### MetaData\n\nAppWidgetProviderInfo包含了AppWidget的配置信息，通过res/xml下包含单独` <appwidget-provider>`标签的xml文件定义。\n\n`<appwidget-provider>`的属性：\n\n* minWidth & minHeight，描述widget占据的默认空间，系统会将其值近似到整cell。\n* minResizeWidth & minResizeHeight，配合Android 3.1的缩放widget功能，描述widget的最小尺寸。\n* updatePeriodMillis，调用AppWidgetProvider.update()的时间间隔，“0”代表从不。\n* initialLayout，layout文件。\n* configure，configuration Activity。\n* previewImage，预览图。\n* resizeMode，缩放方式例如\"vertical\"、\"horizental\"、\"none\"。\n* widgetCategory，widget的显示位置例如\"home_screen\"或\"keyguard\"；在5.0后不支持锁屏widget。\n\nWidget的update事件会将睡眠的设备唤醒，从而增加电量消耗。如果不需要再睡眠期间update widget可以使用AlarmMananger来代替（AlarmMananger不会唤醒设备）。\n\n### Widget布局文件   \n\n#### 设置margin \n\nwidget需要和其他widget & app icon有一些margin，不然很丑。\n在Android 4.0之后会自动给widget加入margin，所以targetSdkVersion=14。\n如果需要兼容旧系统，可以在layout中设置padding，padding值在大于等于14时为0即可。\n\n### 实现AppWidgetProvider类\n\n需要实现的回调接口：\n\n* onUpdate()，如果没有定义configuration activity，在第一次创建Widget的时候也会回调，所以需要负责setup工作。\n* onAppWidgetOptionsChanged()，在widget实例第一次被放置或者widget被缩放时调用。\n* onDeleted()，任意widget实例被删除时调用。\n* onEnabled & onDisabled，第一个widget实例被创建时 & 最后一个widget实例被删除时调用。\n\nAppWidgetProvider仅仅是个工具类，开发者也可以直接继承receiver来辅助widget。\n\n### Configuration Activity\n\nConfiguration Activity会在Widget创建的时候被Widget host调用；Configuration Activity在manifest中必须包含action=ACTION_APPWIDGET_CONFIGURE的intent-filter。\nConfiguration Activity需要返回result；result和启动的Intent都需要包含\nEXTRA_APPWIDGET_ID，代表widget id。\n\ntip：在启动时就setResult中加入RESULT_CANCELED和EXTRA_APPWIDGET_ID，以防activity通过其他逻辑分支退出。\n\n### 预览图 \n\nAndroid模拟器包含应用\"Widget Preview\"，方便制作widget预览图。\n\n### AppWidget显示列表\n\n//TODO:加入展开列表\n\n## App Widget Host\n\n//TODO:加入展开列表\n\n## Processes and Threads\n\n默认情况下，同一个App的Component都是运行在同一个进程的主线程上。\n\n通过Component标签的android:process属性可以使得同一个App的Component运行在不同进程中，或者使不同App的Component运行在同一进程中。\n借助`<application>`的android:process属性设置App的默认进程名。\n\n","slug":"android-developers-guide-note-app-components-others","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p2000o3mrf8g7q1aqn","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=vBjTXKpaFj8&amp;feature=youtu.be\">Background Optimizations</a>。</li>\n<li>foreground broadcast and receiver；FLAG_RECEIVER_FOREGROUND。</li>\n<li>custom permission的定义App和使用App的安装顺序；如果在permission还没定义时使用会发生什么。</li>\n<li>explicit intent with receiver。</li>\n<li>local broadcast and receiver。</li>\n<li><a href=\"https://developer.android.google.cn/topic/performance/scheduling.html\">Intelligent Job-Scheduling</a>。</li>\n<li>Resize App Widget。</li>\n<li>ViewStub。</li>\n<li>AppWidgetManager in Detail。</li>\n<li>orderedBroadcast。 </li>\n<li><a href=\"https://android.googlesource.com/platform/packages/apps/Launcher3/\">Launcher</a>。</li>\n</ul>\n<h2 id=\"Cautions\"><a href=\"#Cautions\" class=\"headerlink\" title=\"Cautions\"></a>Cautions</h2><ul>\n<li>所有的系统Broadcast记录在Android SDK的BROADCAST_ACTIONS.TXT文件中。</li>\n<li>通过context注册的receivers的作用时间和context的生命周期一样长，例如Activity和Application。</li>\n</ul>\n<h2 id=\"Broadcasts\"><a href=\"#Broadcasts\" class=\"headerlink\" title=\"Broadcasts\"></a>Broadcasts</h2><h3 id=\"系统广播\"><a href=\"#系统广播\" class=\"headerlink\" title=\"系统广播\"></a>系统广播</h3><p>Android 7.0之后系统不再发ACTION_NEW_PICTURE和ACTION_NEW_VIDEO广播；CONNECTIVITY_ACTION只能用动态注册的receiver接受。</p>\n<h3 id=\"接收广播\"><a href=\"#接收广播\" class=\"headerlink\" title=\"接收广播\"></a>接收广播</h3><p>App通过manifest的<code>&lt;receiver&gt;</code>标签生命receiver，package manager会在app安装的时候注册receiver，receiver仅在onReceive执行时处于active状态。</p>\n<p>通过Context.registerReceiver方法动态注册receiver；也可以通过LocalBroadcastManager.registerReceiver动态注册local receiver。<br>local broadcast执行效率更高，无需跨越app的时候使用local broadcast。</p>\n<h4 id=\"goAsync\"><a href=\"#goAsync\" class=\"headerlink\" title=\"goAsync()\"></a>goAsync()</h4><p>调用goAsync()可以使receiver在onReceive返回之后仍处于active状态，处于active状态不会超过receiver的10秒限制，可以通过goAsync()返回的PendingResult对象的PendingResult.finish()方法终结receiver的active状态(在后台线程里)。</p>\n<h3 id=\"发送广播\"><a href=\"#发送广播\" class=\"headerlink\" title=\"发送广播\"></a>发送广播</h3><p>使用sendBroadcast(Intent)或者LocalBroadcastManager.sendBroadcast。<br>Android 4.0之后，通过Intent.setPackage()限制哪些应用可以收到这次广播。</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ul>\n<li>无需跨app时使用local broadcast，执行效率更高。</li>\n<li>如果可以动态注册receiver就不要静态注册，以免拖慢系统。</li>\n<li>确保广播的action是unique的。</li>\n<li>不要在onReceiver里直接启动线程，除非使用goAsync()或者Service。</li>\n<li>不要通过receiver启动activity。</li>\n</ul>\n<h2 id=\"App-Widget\"><a href=\"#App-Widget\" class=\"headerlink\" title=\"App Widget\"></a>App Widget</h2><p>App Widget就是可以被嵌入其他应用中的一块View。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>构建App Widget需要以下工作：</p>\n<ul>\n<li>AppWidgetProviderInfo，xml形式的metadata文件，用于配置AppWidget的属性。</li>\n<li>AppWidgetProvider的实现类。</li>\n<li>layout文件。</li>\n<li>AppWidget的configuration Activity，是AppWidet的可选组成部分。</li>\n</ul>\n<h3 id=\"在Manifest中\"><a href=\"#在Manifest中\" class=\"headerlink\" title=\"在Manifest中\"></a>在Manifest中</h3><ul>\n<li><code>&lt;receiver&gt;</code>标签：AppWidgetProvider继承自receiver，在manifest文件中通过<code>&lt;receiver&gt;</code>标签来声明AppWidgetProvider。</li>\n<li><code>&lt;intent-filter&gt;</code>标签：<code>&lt;intent-filter&gt;</code>必须包含声明ACTION_APPWIDGET_UPDATE的<code>&lt;action&gt;</code>标签。</li>\n<li><code>&lt;meta-data&gt;</code>标签：用于声明AppWidgetProviderInfo，androidLname值为android.appwidget.provider，android:resource为metadata的xml文件的位置。</li>\n</ul>\n<h3 id=\"MetaData\"><a href=\"#MetaData\" class=\"headerlink\" title=\"MetaData\"></a>MetaData</h3><p>AppWidgetProviderInfo包含了AppWidget的配置信息，通过res/xml下包含单独<code>&lt;appwidget-provider&gt;</code>标签的xml文件定义。</p>\n<p><code>&lt;appwidget-provider&gt;</code>的属性：</p>\n<ul>\n<li>minWidth &amp; minHeight，描述widget占据的默认空间，系统会将其值近似到整cell。</li>\n<li>minResizeWidth &amp; minResizeHeight，配合Android 3.1的缩放widget功能，描述widget的最小尺寸。</li>\n<li>updatePeriodMillis，调用AppWidgetProvider.update()的时间间隔，“0”代表从不。</li>\n<li>initialLayout，layout文件。</li>\n<li>configure，configuration Activity。</li>\n<li>previewImage，预览图。</li>\n<li>resizeMode，缩放方式例如”vertical”、”horizental”、”none”。</li>\n<li>widgetCategory，widget的显示位置例如”home_screen”或”keyguard”；在5.0后不支持锁屏widget。</li>\n</ul>\n<p>Widget的update事件会将睡眠的设备唤醒，从而增加电量消耗。如果不需要再睡眠期间update widget可以使用AlarmMananger来代替（AlarmMananger不会唤醒设备）。</p>\n<h3 id=\"Widget布局文件\"><a href=\"#Widget布局文件\" class=\"headerlink\" title=\"Widget布局文件\"></a>Widget布局文件</h3><h4 id=\"设置margin\"><a href=\"#设置margin\" class=\"headerlink\" title=\"设置margin\"></a>设置margin</h4><p>widget需要和其他widget &amp; app icon有一些margin，不然很丑。<br>在Android 4.0之后会自动给widget加入margin，所以targetSdkVersion=14。<br>如果需要兼容旧系统，可以在layout中设置padding，padding值在大于等于14时为0即可。</p>\n<h3 id=\"实现AppWidgetProvider类\"><a href=\"#实现AppWidgetProvider类\" class=\"headerlink\" title=\"实现AppWidgetProvider类\"></a>实现AppWidgetProvider类</h3><p>需要实现的回调接口：</p>\n<ul>\n<li>onUpdate()，如果没有定义configuration activity，在第一次创建Widget的时候也会回调，所以需要负责setup工作。</li>\n<li>onAppWidgetOptionsChanged()，在widget实例第一次被放置或者widget被缩放时调用。</li>\n<li>onDeleted()，任意widget实例被删除时调用。</li>\n<li>onEnabled &amp; onDisabled，第一个widget实例被创建时 &amp; 最后一个widget实例被删除时调用。</li>\n</ul>\n<p>AppWidgetProvider仅仅是个工具类，开发者也可以直接继承receiver来辅助widget。</p>\n<h3 id=\"Configuration-Activity\"><a href=\"#Configuration-Activity\" class=\"headerlink\" title=\"Configuration Activity\"></a>Configuration Activity</h3><p>Configuration Activity会在Widget创建的时候被Widget host调用；Configuration Activity在manifest中必须包含action=ACTION_APPWIDGET_CONFIGURE的intent-filter。<br>Configuration Activity需要返回result；result和启动的Intent都需要包含<br>EXTRA_APPWIDGET_ID，代表widget id。</p>\n<p>tip：在启动时就setResult中加入RESULT_CANCELED和EXTRA_APPWIDGET_ID，以防activity通过其他逻辑分支退出。</p>\n<h3 id=\"预览图\"><a href=\"#预览图\" class=\"headerlink\" title=\"预览图\"></a>预览图</h3><p>Android模拟器包含应用”Widget Preview”，方便制作widget预览图。</p>\n<h3 id=\"AppWidget显示列表\"><a href=\"#AppWidget显示列表\" class=\"headerlink\" title=\"AppWidget显示列表\"></a>AppWidget显示列表</h3><p>//TODO:加入展开列表</p>\n<h2 id=\"App-Widget-Host\"><a href=\"#App-Widget-Host\" class=\"headerlink\" title=\"App Widget Host\"></a>App Widget Host</h2><p>//TODO:加入展开列表</p>\n<h2 id=\"Processes-and-Threads\"><a href=\"#Processes-and-Threads\" class=\"headerlink\" title=\"Processes and Threads\"></a>Processes and Threads</h2><p>默认情况下，同一个App的Component都是运行在同一个进程的主线程上。</p>\n<p>通过Component标签的android:process属性可以使得同一个App的Component运行在不同进程中，或者使不同App的Component运行在同一进程中。<br>借助<code>&lt;application&gt;</code>的android:process属性设置App的默认进程名。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=vBjTXKpaFj8&amp;feature=youtu.be\">Background Optimizations</a>。</li>\n<li>foreground broadcast and receiver；FLAG_RECEIVER_FOREGROUND。</li>\n<li>custom permission的定义App和使用App的安装顺序；如果在permission还没定义时使用会发生什么。</li>\n<li>explicit intent with receiver。</li>\n<li>local broadcast and receiver。</li>\n<li><a href=\"https://developer.android.google.cn/topic/performance/scheduling.html\">Intelligent Job-Scheduling</a>。</li>\n<li>Resize App Widget。</li>\n<li>ViewStub。</li>\n<li>AppWidgetManager in Detail。</li>\n<li>orderedBroadcast。 </li>\n<li><a href=\"https://android.googlesource.com/platform/packages/apps/Launcher3/\">Launcher</a>。</li>\n</ul>\n<h2 id=\"Cautions\"><a href=\"#Cautions\" class=\"headerlink\" title=\"Cautions\"></a>Cautions</h2><ul>\n<li>所有的系统Broadcast记录在Android SDK的BROADCAST_ACTIONS.TXT文件中。</li>\n<li>通过context注册的receivers的作用时间和context的生命周期一样长，例如Activity和Application。</li>\n</ul>\n<h2 id=\"Broadcasts\"><a href=\"#Broadcasts\" class=\"headerlink\" title=\"Broadcasts\"></a>Broadcasts</h2><h3 id=\"系统广播\"><a href=\"#系统广播\" class=\"headerlink\" title=\"系统广播\"></a>系统广播</h3><p>Android 7.0之后系统不再发ACTION_NEW_PICTURE和ACTION_NEW_VIDEO广播；CONNECTIVITY_ACTION只能用动态注册的receiver接受。</p>\n<h3 id=\"接收广播\"><a href=\"#接收广播\" class=\"headerlink\" title=\"接收广播\"></a>接收广播</h3><p>App通过manifest的<code>&lt;receiver&gt;</code>标签生命receiver，package manager会在app安装的时候注册receiver，receiver仅在onReceive执行时处于active状态。</p>\n<p>通过Context.registerReceiver方法动态注册receiver；也可以通过LocalBroadcastManager.registerReceiver动态注册local receiver。<br>local broadcast执行效率更高，无需跨越app的时候使用local broadcast。</p>\n<h4 id=\"goAsync\"><a href=\"#goAsync\" class=\"headerlink\" title=\"goAsync()\"></a>goAsync()</h4><p>调用goAsync()可以使receiver在onReceive返回之后仍处于active状态，处于active状态不会超过receiver的10秒限制，可以通过goAsync()返回的PendingResult对象的PendingResult.finish()方法终结receiver的active状态(在后台线程里)。</p>\n<h3 id=\"发送广播\"><a href=\"#发送广播\" class=\"headerlink\" title=\"发送广播\"></a>发送广播</h3><p>使用sendBroadcast(Intent)或者LocalBroadcastManager.sendBroadcast。<br>Android 4.0之后，通过Intent.setPackage()限制哪些应用可以收到这次广播。</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ul>\n<li>无需跨app时使用local broadcast，执行效率更高。</li>\n<li>如果可以动态注册receiver就不要静态注册，以免拖慢系统。</li>\n<li>确保广播的action是unique的。</li>\n<li>不要在onReceiver里直接启动线程，除非使用goAsync()或者Service。</li>\n<li>不要通过receiver启动activity。</li>\n</ul>\n<h2 id=\"App-Widget\"><a href=\"#App-Widget\" class=\"headerlink\" title=\"App Widget\"></a>App Widget</h2><p>App Widget就是可以被嵌入其他应用中的一块View。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>构建App Widget需要以下工作：</p>\n<ul>\n<li>AppWidgetProviderInfo，xml形式的metadata文件，用于配置AppWidget的属性。</li>\n<li>AppWidgetProvider的实现类。</li>\n<li>layout文件。</li>\n<li>AppWidget的configuration Activity，是AppWidet的可选组成部分。</li>\n</ul>\n<h3 id=\"在Manifest中\"><a href=\"#在Manifest中\" class=\"headerlink\" title=\"在Manifest中\"></a>在Manifest中</h3><ul>\n<li><code>&lt;receiver&gt;</code>标签：AppWidgetProvider继承自receiver，在manifest文件中通过<code>&lt;receiver&gt;</code>标签来声明AppWidgetProvider。</li>\n<li><code>&lt;intent-filter&gt;</code>标签：<code>&lt;intent-filter&gt;</code>必须包含声明ACTION_APPWIDGET_UPDATE的<code>&lt;action&gt;</code>标签。</li>\n<li><code>&lt;meta-data&gt;</code>标签：用于声明AppWidgetProviderInfo，androidLname值为android.appwidget.provider，android:resource为metadata的xml文件的位置。</li>\n</ul>\n<h3 id=\"MetaData\"><a href=\"#MetaData\" class=\"headerlink\" title=\"MetaData\"></a>MetaData</h3><p>AppWidgetProviderInfo包含了AppWidget的配置信息，通过res/xml下包含单独<code>&lt;appwidget-provider&gt;</code>标签的xml文件定义。</p>\n<p><code>&lt;appwidget-provider&gt;</code>的属性：</p>\n<ul>\n<li>minWidth &amp; minHeight，描述widget占据的默认空间，系统会将其值近似到整cell。</li>\n<li>minResizeWidth &amp; minResizeHeight，配合Android 3.1的缩放widget功能，描述widget的最小尺寸。</li>\n<li>updatePeriodMillis，调用AppWidgetProvider.update()的时间间隔，“0”代表从不。</li>\n<li>initialLayout，layout文件。</li>\n<li>configure，configuration Activity。</li>\n<li>previewImage，预览图。</li>\n<li>resizeMode，缩放方式例如”vertical”、”horizental”、”none”。</li>\n<li>widgetCategory，widget的显示位置例如”home_screen”或”keyguard”；在5.0后不支持锁屏widget。</li>\n</ul>\n<p>Widget的update事件会将睡眠的设备唤醒，从而增加电量消耗。如果不需要再睡眠期间update widget可以使用AlarmMananger来代替（AlarmMananger不会唤醒设备）。</p>\n<h3 id=\"Widget布局文件\"><a href=\"#Widget布局文件\" class=\"headerlink\" title=\"Widget布局文件\"></a>Widget布局文件</h3><h4 id=\"设置margin\"><a href=\"#设置margin\" class=\"headerlink\" title=\"设置margin\"></a>设置margin</h4><p>widget需要和其他widget &amp; app icon有一些margin，不然很丑。<br>在Android 4.0之后会自动给widget加入margin，所以targetSdkVersion=14。<br>如果需要兼容旧系统，可以在layout中设置padding，padding值在大于等于14时为0即可。</p>\n<h3 id=\"实现AppWidgetProvider类\"><a href=\"#实现AppWidgetProvider类\" class=\"headerlink\" title=\"实现AppWidgetProvider类\"></a>实现AppWidgetProvider类</h3><p>需要实现的回调接口：</p>\n<ul>\n<li>onUpdate()，如果没有定义configuration activity，在第一次创建Widget的时候也会回调，所以需要负责setup工作。</li>\n<li>onAppWidgetOptionsChanged()，在widget实例第一次被放置或者widget被缩放时调用。</li>\n<li>onDeleted()，任意widget实例被删除时调用。</li>\n<li>onEnabled &amp; onDisabled，第一个widget实例被创建时 &amp; 最后一个widget实例被删除时调用。</li>\n</ul>\n<p>AppWidgetProvider仅仅是个工具类，开发者也可以直接继承receiver来辅助widget。</p>\n<h3 id=\"Configuration-Activity\"><a href=\"#Configuration-Activity\" class=\"headerlink\" title=\"Configuration Activity\"></a>Configuration Activity</h3><p>Configuration Activity会在Widget创建的时候被Widget host调用；Configuration Activity在manifest中必须包含action=ACTION_APPWIDGET_CONFIGURE的intent-filter。<br>Configuration Activity需要返回result；result和启动的Intent都需要包含<br>EXTRA_APPWIDGET_ID，代表widget id。</p>\n<p>tip：在启动时就setResult中加入RESULT_CANCELED和EXTRA_APPWIDGET_ID，以防activity通过其他逻辑分支退出。</p>\n<h3 id=\"预览图\"><a href=\"#预览图\" class=\"headerlink\" title=\"预览图\"></a>预览图</h3><p>Android模拟器包含应用”Widget Preview”，方便制作widget预览图。</p>\n<h3 id=\"AppWidget显示列表\"><a href=\"#AppWidget显示列表\" class=\"headerlink\" title=\"AppWidget显示列表\"></a>AppWidget显示列表</h3><p>//TODO:加入展开列表</p>\n<h2 id=\"App-Widget-Host\"><a href=\"#App-Widget-Host\" class=\"headerlink\" title=\"App Widget Host\"></a>App Widget Host</h2><p>//TODO:加入展开列表</p>\n<h2 id=\"Processes-and-Threads\"><a href=\"#Processes-and-Threads\" class=\"headerlink\" title=\"Processes and Threads\"></a>Processes and Threads</h2><p>默认情况下，同一个App的Component都是运行在同一个进程的主线程上。</p>\n<p>通过Component标签的android:process属性可以使得同一个App的Component运行在不同进程中，或者使不同App的Component运行在同一进程中。<br>借助<code>&lt;application&gt;</code>的android:process属性设置App的默认进程名。</p>\n"},{"title":"Android Developer Guide中的Service","subtitle":"Android官方guide随笔 - App Components：Service","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-08-04T07:23:41.000Z","_content":"\n## 展开点\n\n* 在进程回收之后，系统什么情况下会重启Service。\n* onRebind()的应用场景。\n* 客户端服务端AIDL冲突的情况。\n* Binder in Detail。\n* 对象经过IPC方法传递后，是否还是同一个对象。\n\n\n## Caution\n\n* 如果不想Service被其他App使用，应该在Manifast里面将android:exported属性声明为false。\n* 用户可以主动终止正在运行的Service，为了避免用户误杀，最好在`<service>`标签的android:description属性中描述Service的用途。\n* onUnbind()回调是在**所有**Client都调用UnbindService()之后调用。\n* 为了简单性尽量使用Messenger而不是AIDL，尽管Messenger是基于AIDL的。\n* AIDL应当向后兼容（兼容旧版本）。\n* 应当把AIDL的方法参数的in & out属性控制在最小权限，因为序列化的代价很大。\n* 当IPC的客户端和服务端AIDL文件存在冲突时，IPC方法会抛出SecurityException异常。\n* \"四大组件\"中，receiver不能bind Serivce；其他三位都可以，包括provider。\n* 即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。\n\n## Services\n\n根据启动方式，或者说执行方式的不同，Service可以被分为Scheduled、Started、Bound三类：\n\n* Scheduled，通过JobScheduler启动的Serivce类型是Scheduled。JobScheduler从Android 5.0（21）开始被引入。\n* Started，被startService()调用过的Service类型是Started；如果不主动结束(使用stopSelf()或者stopService())，Started的Service不会停止运行从而被正常销毁（除了进程回收）。\n* Bound，被 bindService()调用过的Serivce类型是Bound；Bound Service用于IPC，当所有Client Component从Serivce Unbind之后Service停止运行从而被销毁。\n\nService可以即处于Started状态又处于Bound状态。\n\n### 基础    \n\n#### 重要回调\n\nService类几个重要的需要override的回调方法分别是onStartCommand()、onBind()、onCreate()、onDestroy()。\nonCreate()和onDestroy()方法分别在Service创建&销毁时被调用，适用于setup和cleanup之类的工作。\nonBind()在Service中是abstract的方法所以必须被继承，但如果不想支持bind就使onBind()返回null。\n\nonStartCommand()会返回一个整数，代表Servcie应对进程回收的方式，返回值的值域有：\n\n* START_NOT_STICKY，进程回收后除非有未处理的Intent(pending intent)，否则不再重启Servcie。\n* START_STICKY，进程回收后重启Service，但重启时不会将最后一次的Intent作为参数传给onStartCommand()而是对Intent参数传null，如果有pending intent则传pending intent。\n* START_REDELIVER_INTENT，进程回收后重启Service，并将最后一次的Intent作为参数传给onStartCommand()，如果有pending intent在这之后会一次传递pending intent。\n\n#### 在manifest中声明   \n\n在`<application>`标签下通过`<service>`标签声明Serivce，`<service>`标签中唯一必填的属性就是android:name来指明Service的class。\n通过设置android:exported属性可以将Service声明为私有的，android:exported为false的Service仅能被UID相同的App访问；和Activity相同，android:exported的默认值在无intent-filter时为false，反之为true。\n\n### 创建Started类型的Service   \n\n使用Started类型的Service时通常有两个继承选择，继承Service或者继承IntentService。\n\n#### 继承IntentService   \n\nIntentService是系统提供的便利工具类，使用单独的线程响应startService()，使用者为一必要做的就是实现onHandleIntent()；如果要override其他方法，需要调用super。\n\nIntentService做了以下的工作：\n\n* 自动管理线程，使用一个单独的线程对每个传入onStartCommand()的Intent调用 onHandleIntent()。\n* 自动管理声明周期，在所有onHandleIntent()执行结束后，调用stopSelf()。\n* 提供了默认的onBind()方法返回null。\n* 提供了默认onStartCommand()方法。\n\n#### 继承Service\n\n很多时候继承Service就像实现一个自己的IntentService一样，所以如果能用IntentService那么就不要自己实现它。\n\n#### Start Service\n\nIntent & startService()。\n\n#### Stop Service\n\n有一个带整形参数的关闭Service的方法Service.stopSelf(int)，这个参数和onStartCommand()传入的startId一致；当调用带参数stopSelf时，仅当使用最新的startId时Service才会被关闭。\n\n### Foreground Service\n\n通过`startForeground(int NOTIFICATION_ID, Notification notification)`方法使Service运行在前台；注意NOTIFICATION_ID不能为0。\n\n### Service的生命周期\n\n![service生命周期图](https://developer.android.google.cn/images/service_lifecycle.png)\n\n当Service同时被Started和Bound时，只有两类个类型的生命周期都结束时，Service才会被销毁；即stopSelf()被调用**且**所有Client Component都unbind。\n\n## Bound Service   \n\nBound Service最经典的应用场景是IPC，但可以使同进程内的Client-Server式访问更加规范。\n\n### 基础   \n\nService为了支持bind，需要在onBind()方法中返回一个非空的IBinder对象；需要bindService的Component需要实现ServiceConnection来监听Bind状态的变化。\n\nAndroid系统会缓存Service第一次返回的IBinder对象，在其他Component再去BindService时，系统直接返回缓存的IBinder并不再调用onBind。\n\n### 提供IBinder   \n\n可以选用以下几种方式提供IBinder：\n\n* 继承Binder(注意不是实现IBinder)，适用于没有跨进程需求的情况，通过返回的IBinder在同一进程内直接进行函数调用。\n* 使用Messenger，Service端Messenger使用一个Hanlder做初始化，通过Messenger.getBinder()方法返回IBinder对象，Client端发送的消息会被返回给Hanlder；Messenger将所有消息由单线程返回；Messenger也是基于AIDL的。\n* 使用AIDL。\n\n#### 继承Binder\n\n同进程，有如一般的callback一样，如你所想。\n\n#### 使用Messenger   \n\n如果需要Service给bind Component返回数据，在bind Component发送的Message对象的replyTo字段中，添加一个Service to Client的Messenger，以实现双向通信。\n\n### 发起Bind请求   \n\n即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。\n\n如果Bind Component销毁时仍与Service保持Bound状态，系统会自动unbind，但不要依赖这个行为unbind。\n\n### 注意事项   \n\n* 对象的引用计数是跨进程的（啊，目前这句话没发提供指导意义）。\n\n## AIDL(Android Interface Definition Language)\n\nAIDL用于在IPC过程中，定义Client和Service端交互的接口。\n\nAIDL接口对于Client而言是同步的函数调用，对于Service而言函数调用实际发生的线程分情况而不同：\n\n* 当Client和Service处于同一个进程的时候，AIDL接口的执行和调用处于同一个线程，即调用AIDL接口的线程；没有IPC，情况和直接的function call一样。\n* 当IPC发生时，AIDL接口的运行被分发到由系统维持的线程池中，系统为每个进程维护一个这样的IPC线程池。\n\n如果AIDL接口用oneway修饰，IPC情况下接口调用会立刻返回，接口执行随后发生在Binder线程池中；同进程情况下，这个接口调用依然是同步的。\n\nAIDL接口运行过程中的抛出的异常**不会**返回给调用者。\n\n### 使用AIDL\n\nClient和Serivce两个Application中必须存放.aidl文件。Android SDK会为每个.aidl文件生成IBinder接口。\n\n使用AIDL的步骤包括：编写.aidl文件、实现aidl接口(Stub)、返回AIDL接口给Client(Stub`s implementation)。\n\n#### 编写.aidl文件\n\n每个.aidl文件职能保护一个aidl接口。\n\nAIDL支持以下数据类型：\n\n* 基础类型。\n* String & CharSequence。\n* List & Map，经过IPC之后List的实现均为ArrayList，Map的实现均为HashMap。\n* 由AIDL生成的接口 & 由AIDL声明的Parcelable。\n\n即使在同一个包中，在.aidl文件中引用其他类型也需要显示import。\n\n注意，在接口参数列表中的非基础类型，需要标注传递方向(in & out)；.aidl文件中的注释会存在于生成的.java文件中。\n\n#### 实现AIDL接口    \n\n由.aidl文件生成的.java文件中，会存在名称为Stub并继承自Binder的抽象子类；通过继承Stub类来实现AIDL接口。\n\n#### 返回AIDL接口\n\n将Stub类的实现作为IBinder从onBind()中返回；Client通过YourServiceInterface.Stub.asInterface(IBinder)获得AIDL接口进行调用。\n\n### 通过AIDL接口传递复杂类型\n\n通过返回的复杂类型必须实现Parcelable接口才能跨越进程；同时还需要在.aidl文件中将类型声明为Parcelable。\n\n### 调用IPC接口\n\n在调用IPC接口的时候，需要捕获DeadObjectException(RemoteException)，在绑定断开时抛出；和捕获SecurityException，当Client和Service的AIDL文件有冲突时抛出。\n\n\n\n\n\n\n","source":"_posts/android-developers-guide-note-app-components-service.md","raw":"---\ntitle: Android Developer Guide中的Service\nsubtitle: Android官方guide随笔 - App Components：Service\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-08-04 15:23:41\n---\n\n## 展开点\n\n* 在进程回收之后，系统什么情况下会重启Service。\n* onRebind()的应用场景。\n* 客户端服务端AIDL冲突的情况。\n* Binder in Detail。\n* 对象经过IPC方法传递后，是否还是同一个对象。\n\n\n## Caution\n\n* 如果不想Service被其他App使用，应该在Manifast里面将android:exported属性声明为false。\n* 用户可以主动终止正在运行的Service，为了避免用户误杀，最好在`<service>`标签的android:description属性中描述Service的用途。\n* onUnbind()回调是在**所有**Client都调用UnbindService()之后调用。\n* 为了简单性尽量使用Messenger而不是AIDL，尽管Messenger是基于AIDL的。\n* AIDL应当向后兼容（兼容旧版本）。\n* 应当把AIDL的方法参数的in & out属性控制在最小权限，因为序列化的代价很大。\n* 当IPC的客户端和服务端AIDL文件存在冲突时，IPC方法会抛出SecurityException异常。\n* \"四大组件\"中，receiver不能bind Serivce；其他三位都可以，包括provider。\n* 即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。\n\n## Services\n\n根据启动方式，或者说执行方式的不同，Service可以被分为Scheduled、Started、Bound三类：\n\n* Scheduled，通过JobScheduler启动的Serivce类型是Scheduled。JobScheduler从Android 5.0（21）开始被引入。\n* Started，被startService()调用过的Service类型是Started；如果不主动结束(使用stopSelf()或者stopService())，Started的Service不会停止运行从而被正常销毁（除了进程回收）。\n* Bound，被 bindService()调用过的Serivce类型是Bound；Bound Service用于IPC，当所有Client Component从Serivce Unbind之后Service停止运行从而被销毁。\n\nService可以即处于Started状态又处于Bound状态。\n\n### 基础    \n\n#### 重要回调\n\nService类几个重要的需要override的回调方法分别是onStartCommand()、onBind()、onCreate()、onDestroy()。\nonCreate()和onDestroy()方法分别在Service创建&销毁时被调用，适用于setup和cleanup之类的工作。\nonBind()在Service中是abstract的方法所以必须被继承，但如果不想支持bind就使onBind()返回null。\n\nonStartCommand()会返回一个整数，代表Servcie应对进程回收的方式，返回值的值域有：\n\n* START_NOT_STICKY，进程回收后除非有未处理的Intent(pending intent)，否则不再重启Servcie。\n* START_STICKY，进程回收后重启Service，但重启时不会将最后一次的Intent作为参数传给onStartCommand()而是对Intent参数传null，如果有pending intent则传pending intent。\n* START_REDELIVER_INTENT，进程回收后重启Service，并将最后一次的Intent作为参数传给onStartCommand()，如果有pending intent在这之后会一次传递pending intent。\n\n#### 在manifest中声明   \n\n在`<application>`标签下通过`<service>`标签声明Serivce，`<service>`标签中唯一必填的属性就是android:name来指明Service的class。\n通过设置android:exported属性可以将Service声明为私有的，android:exported为false的Service仅能被UID相同的App访问；和Activity相同，android:exported的默认值在无intent-filter时为false，反之为true。\n\n### 创建Started类型的Service   \n\n使用Started类型的Service时通常有两个继承选择，继承Service或者继承IntentService。\n\n#### 继承IntentService   \n\nIntentService是系统提供的便利工具类，使用单独的线程响应startService()，使用者为一必要做的就是实现onHandleIntent()；如果要override其他方法，需要调用super。\n\nIntentService做了以下的工作：\n\n* 自动管理线程，使用一个单独的线程对每个传入onStartCommand()的Intent调用 onHandleIntent()。\n* 自动管理声明周期，在所有onHandleIntent()执行结束后，调用stopSelf()。\n* 提供了默认的onBind()方法返回null。\n* 提供了默认onStartCommand()方法。\n\n#### 继承Service\n\n很多时候继承Service就像实现一个自己的IntentService一样，所以如果能用IntentService那么就不要自己实现它。\n\n#### Start Service\n\nIntent & startService()。\n\n#### Stop Service\n\n有一个带整形参数的关闭Service的方法Service.stopSelf(int)，这个参数和onStartCommand()传入的startId一致；当调用带参数stopSelf时，仅当使用最新的startId时Service才会被关闭。\n\n### Foreground Service\n\n通过`startForeground(int NOTIFICATION_ID, Notification notification)`方法使Service运行在前台；注意NOTIFICATION_ID不能为0。\n\n### Service的生命周期\n\n![service生命周期图](https://developer.android.google.cn/images/service_lifecycle.png)\n\n当Service同时被Started和Bound时，只有两类个类型的生命周期都结束时，Service才会被销毁；即stopSelf()被调用**且**所有Client Component都unbind。\n\n## Bound Service   \n\nBound Service最经典的应用场景是IPC，但可以使同进程内的Client-Server式访问更加规范。\n\n### 基础   \n\nService为了支持bind，需要在onBind()方法中返回一个非空的IBinder对象；需要bindService的Component需要实现ServiceConnection来监听Bind状态的变化。\n\nAndroid系统会缓存Service第一次返回的IBinder对象，在其他Component再去BindService时，系统直接返回缓存的IBinder并不再调用onBind。\n\n### 提供IBinder   \n\n可以选用以下几种方式提供IBinder：\n\n* 继承Binder(注意不是实现IBinder)，适用于没有跨进程需求的情况，通过返回的IBinder在同一进程内直接进行函数调用。\n* 使用Messenger，Service端Messenger使用一个Hanlder做初始化，通过Messenger.getBinder()方法返回IBinder对象，Client端发送的消息会被返回给Hanlder；Messenger将所有消息由单线程返回；Messenger也是基于AIDL的。\n* 使用AIDL。\n\n#### 继承Binder\n\n同进程，有如一般的callback一样，如你所想。\n\n#### 使用Messenger   \n\n如果需要Service给bind Component返回数据，在bind Component发送的Message对象的replyTo字段中，添加一个Service to Client的Messenger，以实现双向通信。\n\n### 发起Bind请求   \n\n即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。\n\n如果Bind Component销毁时仍与Service保持Bound状态，系统会自动unbind，但不要依赖这个行为unbind。\n\n### 注意事项   \n\n* 对象的引用计数是跨进程的（啊，目前这句话没发提供指导意义）。\n\n## AIDL(Android Interface Definition Language)\n\nAIDL用于在IPC过程中，定义Client和Service端交互的接口。\n\nAIDL接口对于Client而言是同步的函数调用，对于Service而言函数调用实际发生的线程分情况而不同：\n\n* 当Client和Service处于同一个进程的时候，AIDL接口的执行和调用处于同一个线程，即调用AIDL接口的线程；没有IPC，情况和直接的function call一样。\n* 当IPC发生时，AIDL接口的运行被分发到由系统维持的线程池中，系统为每个进程维护一个这样的IPC线程池。\n\n如果AIDL接口用oneway修饰，IPC情况下接口调用会立刻返回，接口执行随后发生在Binder线程池中；同进程情况下，这个接口调用依然是同步的。\n\nAIDL接口运行过程中的抛出的异常**不会**返回给调用者。\n\n### 使用AIDL\n\nClient和Serivce两个Application中必须存放.aidl文件。Android SDK会为每个.aidl文件生成IBinder接口。\n\n使用AIDL的步骤包括：编写.aidl文件、实现aidl接口(Stub)、返回AIDL接口给Client(Stub`s implementation)。\n\n#### 编写.aidl文件\n\n每个.aidl文件职能保护一个aidl接口。\n\nAIDL支持以下数据类型：\n\n* 基础类型。\n* String & CharSequence。\n* List & Map，经过IPC之后List的实现均为ArrayList，Map的实现均为HashMap。\n* 由AIDL生成的接口 & 由AIDL声明的Parcelable。\n\n即使在同一个包中，在.aidl文件中引用其他类型也需要显示import。\n\n注意，在接口参数列表中的非基础类型，需要标注传递方向(in & out)；.aidl文件中的注释会存在于生成的.java文件中。\n\n#### 实现AIDL接口    \n\n由.aidl文件生成的.java文件中，会存在名称为Stub并继承自Binder的抽象子类；通过继承Stub类来实现AIDL接口。\n\n#### 返回AIDL接口\n\n将Stub类的实现作为IBinder从onBind()中返回；Client通过YourServiceInterface.Stub.asInterface(IBinder)获得AIDL接口进行调用。\n\n### 通过AIDL接口传递复杂类型\n\n通过返回的复杂类型必须实现Parcelable接口才能跨越进程；同时还需要在.aidl文件中将类型声明为Parcelable。\n\n### 调用IPC接口\n\n在调用IPC接口的时候，需要捕获DeadObjectException(RemoteException)，在绑定断开时抛出；和捕获SecurityException，当Client和Service的AIDL文件有冲突时抛出。\n\n\n\n\n\n\n","slug":"android-developers-guide-note-app-components-service","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p3000p3mrfht575ztj","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>在进程回收之后，系统什么情况下会重启Service。</li>\n<li>onRebind()的应用场景。</li>\n<li>客户端服务端AIDL冲突的情况。</li>\n<li>Binder in Detail。</li>\n<li>对象经过IPC方法传递后，是否还是同一个对象。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>如果不想Service被其他App使用，应该在Manifast里面将android:exported属性声明为false。</li>\n<li>用户可以主动终止正在运行的Service，为了避免用户误杀，最好在<code>&lt;service&gt;</code>标签的android:description属性中描述Service的用途。</li>\n<li>onUnbind()回调是在<strong>所有</strong>Client都调用UnbindService()之后调用。</li>\n<li>为了简单性尽量使用Messenger而不是AIDL，尽管Messenger是基于AIDL的。</li>\n<li>AIDL应当向后兼容（兼容旧版本）。</li>\n<li>应当把AIDL的方法参数的in &amp; out属性控制在最小权限，因为序列化的代价很大。</li>\n<li>当IPC的客户端和服务端AIDL文件存在冲突时，IPC方法会抛出SecurityException异常。</li>\n<li>“四大组件”中，receiver不能bind Serivce；其他三位都可以，包括provider。</li>\n<li>即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。</li>\n</ul>\n<h2 id=\"Services\"><a href=\"#Services\" class=\"headerlink\" title=\"Services\"></a>Services</h2><p>根据启动方式，或者说执行方式的不同，Service可以被分为Scheduled、Started、Bound三类：</p>\n<ul>\n<li>Scheduled，通过JobScheduler启动的Serivce类型是Scheduled。JobScheduler从Android 5.0（21）开始被引入。</li>\n<li>Started，被startService()调用过的Service类型是Started；如果不主动结束(使用stopSelf()或者stopService())，Started的Service不会停止运行从而被正常销毁（除了进程回收）。</li>\n<li>Bound，被 bindService()调用过的Serivce类型是Bound；Bound Service用于IPC，当所有Client Component从Serivce Unbind之后Service停止运行从而被销毁。</li>\n</ul>\n<p>Service可以即处于Started状态又处于Bound状态。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><h4 id=\"重要回调\"><a href=\"#重要回调\" class=\"headerlink\" title=\"重要回调\"></a>重要回调</h4><p>Service类几个重要的需要override的回调方法分别是onStartCommand()、onBind()、onCreate()、onDestroy()。<br>onCreate()和onDestroy()方法分别在Service创建&amp;销毁时被调用，适用于setup和cleanup之类的工作。<br>onBind()在Service中是abstract的方法所以必须被继承，但如果不想支持bind就使onBind()返回null。</p>\n<p>onStartCommand()会返回一个整数，代表Servcie应对进程回收的方式，返回值的值域有：</p>\n<ul>\n<li>START_NOT_STICKY，进程回收后除非有未处理的Intent(pending intent)，否则不再重启Servcie。</li>\n<li>START_STICKY，进程回收后重启Service，但重启时不会将最后一次的Intent作为参数传给onStartCommand()而是对Intent参数传null，如果有pending intent则传pending intent。</li>\n<li>START_REDELIVER_INTENT，进程回收后重启Service，并将最后一次的Intent作为参数传给onStartCommand()，如果有pending intent在这之后会一次传递pending intent。</li>\n</ul>\n<h4 id=\"在manifest中声明\"><a href=\"#在manifest中声明\" class=\"headerlink\" title=\"在manifest中声明\"></a>在manifest中声明</h4><p>在<code>&lt;application&gt;</code>标签下通过<code>&lt;service&gt;</code>标签声明Serivce，<code>&lt;service&gt;</code>标签中唯一必填的属性就是android:name来指明Service的class。<br>通过设置android:exported属性可以将Service声明为私有的，android:exported为false的Service仅能被UID相同的App访问；和Activity相同，android:exported的默认值在无intent-filter时为false，反之为true。</p>\n<h3 id=\"创建Started类型的Service\"><a href=\"#创建Started类型的Service\" class=\"headerlink\" title=\"创建Started类型的Service\"></a>创建Started类型的Service</h3><p>使用Started类型的Service时通常有两个继承选择，继承Service或者继承IntentService。</p>\n<h4 id=\"继承IntentService\"><a href=\"#继承IntentService\" class=\"headerlink\" title=\"继承IntentService\"></a>继承IntentService</h4><p>IntentService是系统提供的便利工具类，使用单独的线程响应startService()，使用者为一必要做的就是实现onHandleIntent()；如果要override其他方法，需要调用super。</p>\n<p>IntentService做了以下的工作：</p>\n<ul>\n<li>自动管理线程，使用一个单独的线程对每个传入onStartCommand()的Intent调用 onHandleIntent()。</li>\n<li>自动管理声明周期，在所有onHandleIntent()执行结束后，调用stopSelf()。</li>\n<li>提供了默认的onBind()方法返回null。</li>\n<li>提供了默认onStartCommand()方法。</li>\n</ul>\n<h4 id=\"继承Service\"><a href=\"#继承Service\" class=\"headerlink\" title=\"继承Service\"></a>继承Service</h4><p>很多时候继承Service就像实现一个自己的IntentService一样，所以如果能用IntentService那么就不要自己实现它。</p>\n<h4 id=\"Start-Service\"><a href=\"#Start-Service\" class=\"headerlink\" title=\"Start Service\"></a>Start Service</h4><p>Intent &amp; startService()。</p>\n<h4 id=\"Stop-Service\"><a href=\"#Stop-Service\" class=\"headerlink\" title=\"Stop Service\"></a>Stop Service</h4><p>有一个带整形参数的关闭Service的方法Service.stopSelf(int)，这个参数和onStartCommand()传入的startId一致；当调用带参数stopSelf时，仅当使用最新的startId时Service才会被关闭。</p>\n<h3 id=\"Foreground-Service\"><a href=\"#Foreground-Service\" class=\"headerlink\" title=\"Foreground Service\"></a>Foreground Service</h3><p>通过<code>startForeground(int NOTIFICATION_ID, Notification notification)</code>方法使Service运行在前台；注意NOTIFICATION_ID不能为0。</p>\n<h3 id=\"Service的生命周期\"><a href=\"#Service的生命周期\" class=\"headerlink\" title=\"Service的生命周期\"></a>Service的生命周期</h3><p><img src=\"https://developer.android.google.cn/images/service_lifecycle.png\" alt=\"service生命周期图\"></p>\n<p>当Service同时被Started和Bound时，只有两类个类型的生命周期都结束时，Service才会被销毁；即stopSelf()被调用<strong>且</strong>所有Client Component都unbind。</p>\n<h2 id=\"Bound-Service\"><a href=\"#Bound-Service\" class=\"headerlink\" title=\"Bound Service\"></a>Bound Service</h2><p>Bound Service最经典的应用场景是IPC，但可以使同进程内的Client-Server式访问更加规范。</p>\n<h3 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>Service为了支持bind，需要在onBind()方法中返回一个非空的IBinder对象；需要bindService的Component需要实现ServiceConnection来监听Bind状态的变化。</p>\n<p>Android系统会缓存Service第一次返回的IBinder对象，在其他Component再去BindService时，系统直接返回缓存的IBinder并不再调用onBind。</p>\n<h3 id=\"提供IBinder\"><a href=\"#提供IBinder\" class=\"headerlink\" title=\"提供IBinder\"></a>提供IBinder</h3><p>可以选用以下几种方式提供IBinder：</p>\n<ul>\n<li>继承Binder(注意不是实现IBinder)，适用于没有跨进程需求的情况，通过返回的IBinder在同一进程内直接进行函数调用。</li>\n<li>使用Messenger，Service端Messenger使用一个Hanlder做初始化，通过Messenger.getBinder()方法返回IBinder对象，Client端发送的消息会被返回给Hanlder；Messenger将所有消息由单线程返回；Messenger也是基于AIDL的。</li>\n<li>使用AIDL。</li>\n</ul>\n<h4 id=\"继承Binder\"><a href=\"#继承Binder\" class=\"headerlink\" title=\"继承Binder\"></a>继承Binder</h4><p>同进程，有如一般的callback一样，如你所想。</p>\n<h4 id=\"使用Messenger\"><a href=\"#使用Messenger\" class=\"headerlink\" title=\"使用Messenger\"></a>使用Messenger</h4><p>如果需要Service给bind Component返回数据，在bind Component发送的Message对象的replyTo字段中，添加一个Service to Client的Messenger，以实现双向通信。</p>\n<h3 id=\"发起Bind请求\"><a href=\"#发起Bind请求\" class=\"headerlink\" title=\"发起Bind请求\"></a>发起Bind请求</h3><p>即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。</p>\n<p>如果Bind Component销毁时仍与Service保持Bound状态，系统会自动unbind，但不要依赖这个行为unbind。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>对象的引用计数是跨进程的（啊，目前这句话没发提供指导意义）。</li>\n</ul>\n<h2 id=\"AIDL-Android-Interface-Definition-Language\"><a href=\"#AIDL-Android-Interface-Definition-Language\" class=\"headerlink\" title=\"AIDL(Android Interface Definition Language)\"></a>AIDL(Android Interface Definition Language)</h2><p>AIDL用于在IPC过程中，定义Client和Service端交互的接口。</p>\n<p>AIDL接口对于Client而言是同步的函数调用，对于Service而言函数调用实际发生的线程分情况而不同：</p>\n<ul>\n<li>当Client和Service处于同一个进程的时候，AIDL接口的执行和调用处于同一个线程，即调用AIDL接口的线程；没有IPC，情况和直接的function call一样。</li>\n<li>当IPC发生时，AIDL接口的运行被分发到由系统维持的线程池中，系统为每个进程维护一个这样的IPC线程池。</li>\n</ul>\n<p>如果AIDL接口用oneway修饰，IPC情况下接口调用会立刻返回，接口执行随后发生在Binder线程池中；同进程情况下，这个接口调用依然是同步的。</p>\n<p>AIDL接口运行过程中的抛出的异常<strong>不会</strong>返回给调用者。</p>\n<h3 id=\"使用AIDL\"><a href=\"#使用AIDL\" class=\"headerlink\" title=\"使用AIDL\"></a>使用AIDL</h3><p>Client和Serivce两个Application中必须存放.aidl文件。Android SDK会为每个.aidl文件生成IBinder接口。</p>\n<p>使用AIDL的步骤包括：编写.aidl文件、实现aidl接口(Stub)、返回AIDL接口给Client(Stub`s implementation)。</p>\n<h4 id=\"编写-aidl文件\"><a href=\"#编写-aidl文件\" class=\"headerlink\" title=\"编写.aidl文件\"></a>编写.aidl文件</h4><p>每个.aidl文件职能保护一个aidl接口。</p>\n<p>AIDL支持以下数据类型：</p>\n<ul>\n<li>基础类型。</li>\n<li>String &amp; CharSequence。</li>\n<li>List &amp; Map，经过IPC之后List的实现均为ArrayList，Map的实现均为HashMap。</li>\n<li>由AIDL生成的接口 &amp; 由AIDL声明的Parcelable。</li>\n</ul>\n<p>即使在同一个包中，在.aidl文件中引用其他类型也需要显示import。</p>\n<p>注意，在接口参数列表中的非基础类型，需要标注传递方向(in &amp; out)；.aidl文件中的注释会存在于生成的.java文件中。</p>\n<h4 id=\"实现AIDL接口\"><a href=\"#实现AIDL接口\" class=\"headerlink\" title=\"实现AIDL接口\"></a>实现AIDL接口</h4><p>由.aidl文件生成的.java文件中，会存在名称为Stub并继承自Binder的抽象子类；通过继承Stub类来实现AIDL接口。</p>\n<h4 id=\"返回AIDL接口\"><a href=\"#返回AIDL接口\" class=\"headerlink\" title=\"返回AIDL接口\"></a>返回AIDL接口</h4><p>将Stub类的实现作为IBinder从onBind()中返回；Client通过YourServiceInterface.Stub.asInterface(IBinder)获得AIDL接口进行调用。</p>\n<h3 id=\"通过AIDL接口传递复杂类型\"><a href=\"#通过AIDL接口传递复杂类型\" class=\"headerlink\" title=\"通过AIDL接口传递复杂类型\"></a>通过AIDL接口传递复杂类型</h3><p>通过返回的复杂类型必须实现Parcelable接口才能跨越进程；同时还需要在.aidl文件中将类型声明为Parcelable。</p>\n<h3 id=\"调用IPC接口\"><a href=\"#调用IPC接口\" class=\"headerlink\" title=\"调用IPC接口\"></a>调用IPC接口</h3><p>在调用IPC接口的时候，需要捕获DeadObjectException(RemoteException)，在绑定断开时抛出；和捕获SecurityException，当Client和Service的AIDL文件有冲突时抛出。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>在进程回收之后，系统什么情况下会重启Service。</li>\n<li>onRebind()的应用场景。</li>\n<li>客户端服务端AIDL冲突的情况。</li>\n<li>Binder in Detail。</li>\n<li>对象经过IPC方法传递后，是否还是同一个对象。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>如果不想Service被其他App使用，应该在Manifast里面将android:exported属性声明为false。</li>\n<li>用户可以主动终止正在运行的Service，为了避免用户误杀，最好在<code>&lt;service&gt;</code>标签的android:description属性中描述Service的用途。</li>\n<li>onUnbind()回调是在<strong>所有</strong>Client都调用UnbindService()之后调用。</li>\n<li>为了简单性尽量使用Messenger而不是AIDL，尽管Messenger是基于AIDL的。</li>\n<li>AIDL应当向后兼容（兼容旧版本）。</li>\n<li>应当把AIDL的方法参数的in &amp; out属性控制在最小权限，因为序列化的代价很大。</li>\n<li>当IPC的客户端和服务端AIDL文件存在冲突时，IPC方法会抛出SecurityException异常。</li>\n<li>“四大组件”中，receiver不能bind Serivce；其他三位都可以，包括provider。</li>\n<li>即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。</li>\n</ul>\n<h2 id=\"Services\"><a href=\"#Services\" class=\"headerlink\" title=\"Services\"></a>Services</h2><p>根据启动方式，或者说执行方式的不同，Service可以被分为Scheduled、Started、Bound三类：</p>\n<ul>\n<li>Scheduled，通过JobScheduler启动的Serivce类型是Scheduled。JobScheduler从Android 5.0（21）开始被引入。</li>\n<li>Started，被startService()调用过的Service类型是Started；如果不主动结束(使用stopSelf()或者stopService())，Started的Service不会停止运行从而被正常销毁（除了进程回收）。</li>\n<li>Bound，被 bindService()调用过的Serivce类型是Bound；Bound Service用于IPC，当所有Client Component从Serivce Unbind之后Service停止运行从而被销毁。</li>\n</ul>\n<p>Service可以即处于Started状态又处于Bound状态。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><h4 id=\"重要回调\"><a href=\"#重要回调\" class=\"headerlink\" title=\"重要回调\"></a>重要回调</h4><p>Service类几个重要的需要override的回调方法分别是onStartCommand()、onBind()、onCreate()、onDestroy()。<br>onCreate()和onDestroy()方法分别在Service创建&amp;销毁时被调用，适用于setup和cleanup之类的工作。<br>onBind()在Service中是abstract的方法所以必须被继承，但如果不想支持bind就使onBind()返回null。</p>\n<p>onStartCommand()会返回一个整数，代表Servcie应对进程回收的方式，返回值的值域有：</p>\n<ul>\n<li>START_NOT_STICKY，进程回收后除非有未处理的Intent(pending intent)，否则不再重启Servcie。</li>\n<li>START_STICKY，进程回收后重启Service，但重启时不会将最后一次的Intent作为参数传给onStartCommand()而是对Intent参数传null，如果有pending intent则传pending intent。</li>\n<li>START_REDELIVER_INTENT，进程回收后重启Service，并将最后一次的Intent作为参数传给onStartCommand()，如果有pending intent在这之后会一次传递pending intent。</li>\n</ul>\n<h4 id=\"在manifest中声明\"><a href=\"#在manifest中声明\" class=\"headerlink\" title=\"在manifest中声明\"></a>在manifest中声明</h4><p>在<code>&lt;application&gt;</code>标签下通过<code>&lt;service&gt;</code>标签声明Serivce，<code>&lt;service&gt;</code>标签中唯一必填的属性就是android:name来指明Service的class。<br>通过设置android:exported属性可以将Service声明为私有的，android:exported为false的Service仅能被UID相同的App访问；和Activity相同，android:exported的默认值在无intent-filter时为false，反之为true。</p>\n<h3 id=\"创建Started类型的Service\"><a href=\"#创建Started类型的Service\" class=\"headerlink\" title=\"创建Started类型的Service\"></a>创建Started类型的Service</h3><p>使用Started类型的Service时通常有两个继承选择，继承Service或者继承IntentService。</p>\n<h4 id=\"继承IntentService\"><a href=\"#继承IntentService\" class=\"headerlink\" title=\"继承IntentService\"></a>继承IntentService</h4><p>IntentService是系统提供的便利工具类，使用单独的线程响应startService()，使用者为一必要做的就是实现onHandleIntent()；如果要override其他方法，需要调用super。</p>\n<p>IntentService做了以下的工作：</p>\n<ul>\n<li>自动管理线程，使用一个单独的线程对每个传入onStartCommand()的Intent调用 onHandleIntent()。</li>\n<li>自动管理声明周期，在所有onHandleIntent()执行结束后，调用stopSelf()。</li>\n<li>提供了默认的onBind()方法返回null。</li>\n<li>提供了默认onStartCommand()方法。</li>\n</ul>\n<h4 id=\"继承Service\"><a href=\"#继承Service\" class=\"headerlink\" title=\"继承Service\"></a>继承Service</h4><p>很多时候继承Service就像实现一个自己的IntentService一样，所以如果能用IntentService那么就不要自己实现它。</p>\n<h4 id=\"Start-Service\"><a href=\"#Start-Service\" class=\"headerlink\" title=\"Start Service\"></a>Start Service</h4><p>Intent &amp; startService()。</p>\n<h4 id=\"Stop-Service\"><a href=\"#Stop-Service\" class=\"headerlink\" title=\"Stop Service\"></a>Stop Service</h4><p>有一个带整形参数的关闭Service的方法Service.stopSelf(int)，这个参数和onStartCommand()传入的startId一致；当调用带参数stopSelf时，仅当使用最新的startId时Service才会被关闭。</p>\n<h3 id=\"Foreground-Service\"><a href=\"#Foreground-Service\" class=\"headerlink\" title=\"Foreground Service\"></a>Foreground Service</h3><p>通过<code>startForeground(int NOTIFICATION_ID, Notification notification)</code>方法使Service运行在前台；注意NOTIFICATION_ID不能为0。</p>\n<h3 id=\"Service的生命周期\"><a href=\"#Service的生命周期\" class=\"headerlink\" title=\"Service的生命周期\"></a>Service的生命周期</h3><p><img src=\"https://developer.android.google.cn/images/service_lifecycle.png\" alt=\"service生命周期图\"></p>\n<p>当Service同时被Started和Bound时，只有两类个类型的生命周期都结束时，Service才会被销毁；即stopSelf()被调用<strong>且</strong>所有Client Component都unbind。</p>\n<h2 id=\"Bound-Service\"><a href=\"#Bound-Service\" class=\"headerlink\" title=\"Bound Service\"></a>Bound Service</h2><p>Bound Service最经典的应用场景是IPC，但可以使同进程内的Client-Server式访问更加规范。</p>\n<h3 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>Service为了支持bind，需要在onBind()方法中返回一个非空的IBinder对象；需要bindService的Component需要实现ServiceConnection来监听Bind状态的变化。</p>\n<p>Android系统会缓存Service第一次返回的IBinder对象，在其他Component再去BindService时，系统直接返回缓存的IBinder并不再调用onBind。</p>\n<h3 id=\"提供IBinder\"><a href=\"#提供IBinder\" class=\"headerlink\" title=\"提供IBinder\"></a>提供IBinder</h3><p>可以选用以下几种方式提供IBinder：</p>\n<ul>\n<li>继承Binder(注意不是实现IBinder)，适用于没有跨进程需求的情况，通过返回的IBinder在同一进程内直接进行函数调用。</li>\n<li>使用Messenger，Service端Messenger使用一个Hanlder做初始化，通过Messenger.getBinder()方法返回IBinder对象，Client端发送的消息会被返回给Hanlder；Messenger将所有消息由单线程返回；Messenger也是基于AIDL的。</li>\n<li>使用AIDL。</li>\n</ul>\n<h4 id=\"继承Binder\"><a href=\"#继承Binder\" class=\"headerlink\" title=\"继承Binder\"></a>继承Binder</h4><p>同进程，有如一般的callback一样，如你所想。</p>\n<h4 id=\"使用Messenger\"><a href=\"#使用Messenger\" class=\"headerlink\" title=\"使用Messenger\"></a>使用Messenger</h4><p>如果需要Service给bind Component返回数据，在bind Component发送的Message对象的replyTo字段中，添加一个Service to Client的Messenger，以实现双向通信。</p>\n<h3 id=\"发起Bind请求\"><a href=\"#发起Bind请求\" class=\"headerlink\" title=\"发起Bind请求\"></a>发起Bind请求</h3><p>即便bindService()方法返回false，也需要主动调用unbindService()，否则Service不会停止运行。</p>\n<p>如果Bind Component销毁时仍与Service保持Bound状态，系统会自动unbind，但不要依赖这个行为unbind。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>对象的引用计数是跨进程的（啊，目前这句话没发提供指导意义）。</li>\n</ul>\n<h2 id=\"AIDL-Android-Interface-Definition-Language\"><a href=\"#AIDL-Android-Interface-Definition-Language\" class=\"headerlink\" title=\"AIDL(Android Interface Definition Language)\"></a>AIDL(Android Interface Definition Language)</h2><p>AIDL用于在IPC过程中，定义Client和Service端交互的接口。</p>\n<p>AIDL接口对于Client而言是同步的函数调用，对于Service而言函数调用实际发生的线程分情况而不同：</p>\n<ul>\n<li>当Client和Service处于同一个进程的时候，AIDL接口的执行和调用处于同一个线程，即调用AIDL接口的线程；没有IPC，情况和直接的function call一样。</li>\n<li>当IPC发生时，AIDL接口的运行被分发到由系统维持的线程池中，系统为每个进程维护一个这样的IPC线程池。</li>\n</ul>\n<p>如果AIDL接口用oneway修饰，IPC情况下接口调用会立刻返回，接口执行随后发生在Binder线程池中；同进程情况下，这个接口调用依然是同步的。</p>\n<p>AIDL接口运行过程中的抛出的异常<strong>不会</strong>返回给调用者。</p>\n<h3 id=\"使用AIDL\"><a href=\"#使用AIDL\" class=\"headerlink\" title=\"使用AIDL\"></a>使用AIDL</h3><p>Client和Serivce两个Application中必须存放.aidl文件。Android SDK会为每个.aidl文件生成IBinder接口。</p>\n<p>使用AIDL的步骤包括：编写.aidl文件、实现aidl接口(Stub)、返回AIDL接口给Client(Stub`s implementation)。</p>\n<h4 id=\"编写-aidl文件\"><a href=\"#编写-aidl文件\" class=\"headerlink\" title=\"编写.aidl文件\"></a>编写.aidl文件</h4><p>每个.aidl文件职能保护一个aidl接口。</p>\n<p>AIDL支持以下数据类型：</p>\n<ul>\n<li>基础类型。</li>\n<li>String &amp; CharSequence。</li>\n<li>List &amp; Map，经过IPC之后List的实现均为ArrayList，Map的实现均为HashMap。</li>\n<li>由AIDL生成的接口 &amp; 由AIDL声明的Parcelable。</li>\n</ul>\n<p>即使在同一个包中，在.aidl文件中引用其他类型也需要显示import。</p>\n<p>注意，在接口参数列表中的非基础类型，需要标注传递方向(in &amp; out)；.aidl文件中的注释会存在于生成的.java文件中。</p>\n<h4 id=\"实现AIDL接口\"><a href=\"#实现AIDL接口\" class=\"headerlink\" title=\"实现AIDL接口\"></a>实现AIDL接口</h4><p>由.aidl文件生成的.java文件中，会存在名称为Stub并继承自Binder的抽象子类；通过继承Stub类来实现AIDL接口。</p>\n<h4 id=\"返回AIDL接口\"><a href=\"#返回AIDL接口\" class=\"headerlink\" title=\"返回AIDL接口\"></a>返回AIDL接口</h4><p>将Stub类的实现作为IBinder从onBind()中返回；Client通过YourServiceInterface.Stub.asInterface(IBinder)获得AIDL接口进行调用。</p>\n<h3 id=\"通过AIDL接口传递复杂类型\"><a href=\"#通过AIDL接口传递复杂类型\" class=\"headerlink\" title=\"通过AIDL接口传递复杂类型\"></a>通过AIDL接口传递复杂类型</h3><p>通过返回的复杂类型必须实现Parcelable接口才能跨越进程；同时还需要在.aidl文件中将类型声明为Parcelable。</p>\n<h3 id=\"调用IPC接口\"><a href=\"#调用IPC接口\" class=\"headerlink\" title=\"调用IPC接口\"></a>调用IPC接口</h3><p>在调用IPC接口的时候，需要捕获DeadObjectException(RemoteException)，在绑定断开时抛出；和捕获SecurityException，当Client和Service的AIDL文件有冲突时抛出。</p>\n"},{"title":"Android Developer Guide中的Resource","subtitle":"Android官方guide随笔 - Resource","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-09-04T08:27:21.000Z","_content":"\n\n## 展开点 \n* [New Tools For Managing Screen Sizes](https://android-developers.googleblog.com/2011/07/new-tools-for-managing-screen-sizes.html)。\n* [Holo Everywhere](https://android-developers.googleblog.com/2012/01/holo-everywhere.html)。\n* [New Mode for Apps on Large Screens](https://android-developers.googleblog.com/2011/07/new-mode-for-apps-on-large-screens.html)。  \n* Fragment.setRetainInstance()的原理。\n* [Localization Checklist](https://developer.android.google.cn/guide/topics/resources/localization.html#strategies)。\n* [App Translation Service](https://support.google.com/l10n/answer/6359997)。\n* ICU4J。\n* 在xml中`@`引用和`?`引用。\n* library工程的R类是否与app的R类进行合并；在xml中资源的包名，例如@android:;library工程是否有单独的包名。\n\n## Caution   \n\n* 直接把resource文件放置在res/目录下，会导致编译错误。\n* configuration后缀有固定的顺序，其次序不能随意安排。\n* aapt负责生成R类。\n* 在api13之后，orientation变化同时也会引发可用宽高变化；所以要自行处理orientation变化需要声明`android:configChanges=\"orientation|screenSize\"`。\n\n## Resources Overview\n\n所有的资源文件存放在`res/`目录下，并通过类型和configuration后缀安置在不同的子目录中。Android将资源和代码分离，除了保持整洁的结构之外，还便于随着configuration的变化在运行来变更所使用的资源。\n\n## Providing Resources\n\n### 资源类型和组织方式\n\n每一个资源文件(或资源item)都应该被放置在`res/`目录下的某个子目录里(对于item则是存在某个子目录的某个文件里)。不考虑config后缀，`res/`下的子目录是按照资源类型区分命名的。\n\n#### 子目录一览\n\nResource子目录类型表:\n\n|子目录名 | 用途            | \n|:--------|:----------------| \n|`animator/` | 属性动画的xml文件。 |\n|`anim/` | view动画的xml文件。 |\n|`color/` | color state list的xml文件。 |\n|`drawable/` | 包含bitmap文件(.png、.g.png、.jgp、.gif等)；包含用xml描述的drawable文件(stat list、shape、帧动画等)。 |\n|`mipmap/` | 应用图标。 |\n|`layout/` | 布局xml。 |\n|`menu/` | menu xml。 |\n|`raw/` | 不会被解释为任何类型的资源，单纯视为文件 |\n|`values/` | 存放包含各种value的xml文件。 |\n|`xml/` | xml格式的配置文件，这些文件通常用于某些Android自带的framework中，如widget framework。 |\n|`font/` | 包含字体文件(.ttf、.otf、.ttc)；包含xml描述的字体。|\n\n#### `values/`\n\n这些子目录中`values/`目录比较特殊，也容易让初学者困惑。在其他目录中，单个文件就代表单个资源；在`values/`目录中，单个xml文件往往包含了一组资源，在xml中的单个特定标签代表单个资源。\n事实上`values/`下的xml文件是可以随意命名的，标签名才是资源类别的标志；同时不同种类的资源可以写在同一个xml文件中。但是为了清晰，我没习惯给`values/`下的xml文件合理命名，并按类型将资源存放与不同的xml文件中。\n\n### 提供动态可选资源\n\n#### 子目录及命名\n\n使用动态可选资源，需要借助`res/`下的子目录。首先建立名称格式为`<resource_name>[-<config_qualifier>...]`格式的子目录，然后把可选资源以完全相同的名称命名并放置在不同后缀的子目录下。\n\n注意，子目录的`<config_qualifier>`后缀可以有多个，后缀次序有严格定义(在后面表中的次序)，如果不安次序命名这个子目录会被系统忽略。\n\n#### 后缀一览表\n\nAndroid支持的config后缀表如下，表中的顺序和后缀出现在文件名中的顺序相同:\n\n|后缀类型 |后缀示例 | 解释 |\n|:--------|:------|:-----|\n|MCC & MNC| mcc310、mcc310-mnc004 | Mobile Country Code(MCC) & Mobile Network Code(MNC)，从SIM卡中读出。|\n|语言和地区 | en、en-rUs | 当前机器使用的语言(和地区)，格式为`<语言code>[-r<地区code>]` |\n|布局方向 | ldrtl、ldltr | 布局是从右向左(ldrtl)还是从左向右(ldltr，这是默认行为)。|\n|最小宽度 |sw<N>dp、sw600dp | 实际上是指屏幕宽度和高度中最小的dp数(并不仅是指宽度，所以也不随orientation变化)。 |\n|可用宽度 | w<N>dp、w720dp | 当前可用的屏幕宽度，随orientation变化。 |\n|可用高度 | h<N>dp、h720dp | 当前可用的屏幕高度，随orientation变化。 |\n|屏幕尺寸 | small、normal、large、xlarge | \n|是否长屏幕 | long & notlong | |\n|是否圆屏幕 | round & notround| |\n|orientation | port & land | |\n|UI mode | {car, desk, television, appliance, watch, vrheadset} |\n|是否夜间模式 | night & notnight | |\n|屏幕像素密度 | ldpi、mdpi | |\n|触屏类型 |notouch & finger | | \n|是否有键盘 | keysexposed & keyshidden & keyssoft | |\n|键盘输入方式 | nokeys & qwerty & 12key | |\n|系统版本 | v3、v11、v17 | |\n\n使用从右向左布局，需要把`<application>`标签的android:supportsRtl属性设置为true并且targetSdkVersion大于17。\n对于不用屏幕尺寸的资源(small、xlarge)，如果没有完全匹配的资源系统会选相最匹配的资源；但是系统不会选择更大尺寸的资源，所以如果所有可选尺寸都大于当前尺寸，运行时会报错。\n\n使用新版本系统才添加后缀，相当于自动为子目录添加了系统版本后缀，老版本系统会自动忽略这个子目录。例如可用宽度后缀来自api13，所以添加w600dp后缀的功效等于w600dp-v13。\n\n#### 可选资源子目录命名规则   \n\n* 同一个子目录可以包含多个后缀，用`-`符号分隔。\n* 后缀必须按照*后缀一览表*中的次序排列。\n* 子目录都需要直接存放在`res/`目录下。\n* 子目录名不区分大小写，在编译时编译器会将子目录名统一变为小写。\n* 同一个类后缀在一个子目录中只能出现一次。\n\n#### 使用资源引用  \n\n为了防止将重复资源拷贝到不同的子目录下(比如在rES、rFR用图片A，rCA用图片B)，可以使用资源引用来解决；单并非所用类型的资源都支持资源引用。\n\ndrawble资源以及string、color等value资源可以通过在`values／`目录下新建item来建立引用；layout资源可以通过`<merge>`标签和`<include>`标签来建立引用。\n\n### 可选资源最佳实践\n\n永远提供default资源(屏幕像素密度后缀是个例外)；低版本系统无法识别高版本加入的后缀，找不到匹配的资源会抛出异常。\n\n### Android系统的资源匹配规则 \n\n1. 剔除所有后缀和当前configuration有冲突的子目录(除了屏幕像素密度后缀)。\n2. 在*后缀一览表*中，按优先级从高到低的顺序选中一类后缀。\n3. 如果有子目录包含这类后缀，执行步骤4；否则返回步骤2。\n4. 剔除所有不包含选中后缀的子目录(针对屏幕像素密度后缀则是选择最接近的)。\n5. 如果只剩下一个子目录，则匹配资源确定；否则返回步骤2。\n\n\n## Accessing Resources\n\naapt脚本会根据资源生成R类，每个资源类型对应一个子类，没个资源对应一个静态整数常量。 \n\n## Handling Configuration Changes\n\n当Configuration变化时，Activity会被销毁重建，以便根据新的Configuration加载可选资源。在SaveInstanceState以外，本章将介绍其他两个应对Configuration变化的技巧。\n即便自行处理Configuration变化，也不意味着可以避免处理SaveInstanceState，因为还有进程回收这个问题。\n\n### 在Configuration变化时保留对象\n\n当重启Activity加载资源量较大，尤其涉及网络请求时，可以利用一个*被保留的*Fragment来协助保存数据。\n创建一个不包含layout的Fragment(add by tag)，用它来保存状态数据，并对调用`Fragment. setRetainInstance(true)`。\n注意不要让被保留的Fragment持有Activity的引用，否则在Activity销毁重建时会发生内存泄漏。\n\n### 自行处理Configuration变化\n\n* 在`<activity>`标签的android:configChanges声明想要自行处理的Configuration变化。\n* 当被声明的Configuration发生变化时，Activity的onConfigurationChanged()被调用，当前的Configuration被作为参数传入。\n\n## Localizing with Resources\n\n使用`<xliff:g>`标签来标记string资源中不希望被翻译的部分：\n\n>`<string name=\"countdown\">`   \n>&emsp;&emsp;`<xliff:g id=\"time\" example=\"5 days>%1$s</xliff:g>until holiday`   \n>`</string>`\n\n使用App Translation Service来翻译string资源，在Android Studio中就有入口。\n\n//TODO: in detail\n\n### 测试本地化\n\n使用adb更改语言 adb shell -> setprop persist.sys.locale [BCP-47 language tag;e.g. fr-CA];stop;sleep 5;start。\n\n测试default资源的方式：将系统设置为你应用所不支持的configuration。\n\n## Inline Complex XML Resources\n\n有一些复杂的资源是需要依赖多个其他资源的，在这种情况下，就会产生很多资源文件。如果被依赖的资源不会用在别处，可以借助inline资源(`<aapt:attr>`标签)将多个资源放在同一文件中。\n`<aapt:attr>`标签所包裹的区域就是一个inline的资源xml，在编译时会被生成为单独的资源文件；这个inline的资源会被用作`<aapt:attr>`标签父标签的属性，属性名由`<aapt:attr>`标签的name属性制定。\n\n例如：\n>`<target android:name=\"rotationGroup\">`   \n>&emsp;&emsp;`<aapt:attr name=\"android:animation\" >`    \n>&emsp;&emsp;&emsp;&emsp;`<objectAnimator`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:duration=\"6000\"`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:propertyName=\"rotation\"`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:valueFrom=\"0\"`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:valueTo=\"360\" />`   \n>&emsp;&emsp;`</aapt:attr>`   \n>`</target>`   \n\n\n\n\n\n\n\n","source":"_posts/android-developers-guide-note-app-resources.md","raw":"---\ntitle: Android Developer Guide中的Resource\nsubtitle: Android官方guide随笔 - Resource\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-09-04 16:27:21\n---\n\n\n## 展开点 \n* [New Tools For Managing Screen Sizes](https://android-developers.googleblog.com/2011/07/new-tools-for-managing-screen-sizes.html)。\n* [Holo Everywhere](https://android-developers.googleblog.com/2012/01/holo-everywhere.html)。\n* [New Mode for Apps on Large Screens](https://android-developers.googleblog.com/2011/07/new-mode-for-apps-on-large-screens.html)。  \n* Fragment.setRetainInstance()的原理。\n* [Localization Checklist](https://developer.android.google.cn/guide/topics/resources/localization.html#strategies)。\n* [App Translation Service](https://support.google.com/l10n/answer/6359997)。\n* ICU4J。\n* 在xml中`@`引用和`?`引用。\n* library工程的R类是否与app的R类进行合并；在xml中资源的包名，例如@android:;library工程是否有单独的包名。\n\n## Caution   \n\n* 直接把resource文件放置在res/目录下，会导致编译错误。\n* configuration后缀有固定的顺序，其次序不能随意安排。\n* aapt负责生成R类。\n* 在api13之后，orientation变化同时也会引发可用宽高变化；所以要自行处理orientation变化需要声明`android:configChanges=\"orientation|screenSize\"`。\n\n## Resources Overview\n\n所有的资源文件存放在`res/`目录下，并通过类型和configuration后缀安置在不同的子目录中。Android将资源和代码分离，除了保持整洁的结构之外，还便于随着configuration的变化在运行来变更所使用的资源。\n\n## Providing Resources\n\n### 资源类型和组织方式\n\n每一个资源文件(或资源item)都应该被放置在`res/`目录下的某个子目录里(对于item则是存在某个子目录的某个文件里)。不考虑config后缀，`res/`下的子目录是按照资源类型区分命名的。\n\n#### 子目录一览\n\nResource子目录类型表:\n\n|子目录名 | 用途            | \n|:--------|:----------------| \n|`animator/` | 属性动画的xml文件。 |\n|`anim/` | view动画的xml文件。 |\n|`color/` | color state list的xml文件。 |\n|`drawable/` | 包含bitmap文件(.png、.g.png、.jgp、.gif等)；包含用xml描述的drawable文件(stat list、shape、帧动画等)。 |\n|`mipmap/` | 应用图标。 |\n|`layout/` | 布局xml。 |\n|`menu/` | menu xml。 |\n|`raw/` | 不会被解释为任何类型的资源，单纯视为文件 |\n|`values/` | 存放包含各种value的xml文件。 |\n|`xml/` | xml格式的配置文件，这些文件通常用于某些Android自带的framework中，如widget framework。 |\n|`font/` | 包含字体文件(.ttf、.otf、.ttc)；包含xml描述的字体。|\n\n#### `values/`\n\n这些子目录中`values/`目录比较特殊，也容易让初学者困惑。在其他目录中，单个文件就代表单个资源；在`values/`目录中，单个xml文件往往包含了一组资源，在xml中的单个特定标签代表单个资源。\n事实上`values/`下的xml文件是可以随意命名的，标签名才是资源类别的标志；同时不同种类的资源可以写在同一个xml文件中。但是为了清晰，我没习惯给`values/`下的xml文件合理命名，并按类型将资源存放与不同的xml文件中。\n\n### 提供动态可选资源\n\n#### 子目录及命名\n\n使用动态可选资源，需要借助`res/`下的子目录。首先建立名称格式为`<resource_name>[-<config_qualifier>...]`格式的子目录，然后把可选资源以完全相同的名称命名并放置在不同后缀的子目录下。\n\n注意，子目录的`<config_qualifier>`后缀可以有多个，后缀次序有严格定义(在后面表中的次序)，如果不安次序命名这个子目录会被系统忽略。\n\n#### 后缀一览表\n\nAndroid支持的config后缀表如下，表中的顺序和后缀出现在文件名中的顺序相同:\n\n|后缀类型 |后缀示例 | 解释 |\n|:--------|:------|:-----|\n|MCC & MNC| mcc310、mcc310-mnc004 | Mobile Country Code(MCC) & Mobile Network Code(MNC)，从SIM卡中读出。|\n|语言和地区 | en、en-rUs | 当前机器使用的语言(和地区)，格式为`<语言code>[-r<地区code>]` |\n|布局方向 | ldrtl、ldltr | 布局是从右向左(ldrtl)还是从左向右(ldltr，这是默认行为)。|\n|最小宽度 |sw<N>dp、sw600dp | 实际上是指屏幕宽度和高度中最小的dp数(并不仅是指宽度，所以也不随orientation变化)。 |\n|可用宽度 | w<N>dp、w720dp | 当前可用的屏幕宽度，随orientation变化。 |\n|可用高度 | h<N>dp、h720dp | 当前可用的屏幕高度，随orientation变化。 |\n|屏幕尺寸 | small、normal、large、xlarge | \n|是否长屏幕 | long & notlong | |\n|是否圆屏幕 | round & notround| |\n|orientation | port & land | |\n|UI mode | {car, desk, television, appliance, watch, vrheadset} |\n|是否夜间模式 | night & notnight | |\n|屏幕像素密度 | ldpi、mdpi | |\n|触屏类型 |notouch & finger | | \n|是否有键盘 | keysexposed & keyshidden & keyssoft | |\n|键盘输入方式 | nokeys & qwerty & 12key | |\n|系统版本 | v3、v11、v17 | |\n\n使用从右向左布局，需要把`<application>`标签的android:supportsRtl属性设置为true并且targetSdkVersion大于17。\n对于不用屏幕尺寸的资源(small、xlarge)，如果没有完全匹配的资源系统会选相最匹配的资源；但是系统不会选择更大尺寸的资源，所以如果所有可选尺寸都大于当前尺寸，运行时会报错。\n\n使用新版本系统才添加后缀，相当于自动为子目录添加了系统版本后缀，老版本系统会自动忽略这个子目录。例如可用宽度后缀来自api13，所以添加w600dp后缀的功效等于w600dp-v13。\n\n#### 可选资源子目录命名规则   \n\n* 同一个子目录可以包含多个后缀，用`-`符号分隔。\n* 后缀必须按照*后缀一览表*中的次序排列。\n* 子目录都需要直接存放在`res/`目录下。\n* 子目录名不区分大小写，在编译时编译器会将子目录名统一变为小写。\n* 同一个类后缀在一个子目录中只能出现一次。\n\n#### 使用资源引用  \n\n为了防止将重复资源拷贝到不同的子目录下(比如在rES、rFR用图片A，rCA用图片B)，可以使用资源引用来解决；单并非所用类型的资源都支持资源引用。\n\ndrawble资源以及string、color等value资源可以通过在`values／`目录下新建item来建立引用；layout资源可以通过`<merge>`标签和`<include>`标签来建立引用。\n\n### 可选资源最佳实践\n\n永远提供default资源(屏幕像素密度后缀是个例外)；低版本系统无法识别高版本加入的后缀，找不到匹配的资源会抛出异常。\n\n### Android系统的资源匹配规则 \n\n1. 剔除所有后缀和当前configuration有冲突的子目录(除了屏幕像素密度后缀)。\n2. 在*后缀一览表*中，按优先级从高到低的顺序选中一类后缀。\n3. 如果有子目录包含这类后缀，执行步骤4；否则返回步骤2。\n4. 剔除所有不包含选中后缀的子目录(针对屏幕像素密度后缀则是选择最接近的)。\n5. 如果只剩下一个子目录，则匹配资源确定；否则返回步骤2。\n\n\n## Accessing Resources\n\naapt脚本会根据资源生成R类，每个资源类型对应一个子类，没个资源对应一个静态整数常量。 \n\n## Handling Configuration Changes\n\n当Configuration变化时，Activity会被销毁重建，以便根据新的Configuration加载可选资源。在SaveInstanceState以外，本章将介绍其他两个应对Configuration变化的技巧。\n即便自行处理Configuration变化，也不意味着可以避免处理SaveInstanceState，因为还有进程回收这个问题。\n\n### 在Configuration变化时保留对象\n\n当重启Activity加载资源量较大，尤其涉及网络请求时，可以利用一个*被保留的*Fragment来协助保存数据。\n创建一个不包含layout的Fragment(add by tag)，用它来保存状态数据，并对调用`Fragment. setRetainInstance(true)`。\n注意不要让被保留的Fragment持有Activity的引用，否则在Activity销毁重建时会发生内存泄漏。\n\n### 自行处理Configuration变化\n\n* 在`<activity>`标签的android:configChanges声明想要自行处理的Configuration变化。\n* 当被声明的Configuration发生变化时，Activity的onConfigurationChanged()被调用，当前的Configuration被作为参数传入。\n\n## Localizing with Resources\n\n使用`<xliff:g>`标签来标记string资源中不希望被翻译的部分：\n\n>`<string name=\"countdown\">`   \n>&emsp;&emsp;`<xliff:g id=\"time\" example=\"5 days>%1$s</xliff:g>until holiday`   \n>`</string>`\n\n使用App Translation Service来翻译string资源，在Android Studio中就有入口。\n\n//TODO: in detail\n\n### 测试本地化\n\n使用adb更改语言 adb shell -> setprop persist.sys.locale [BCP-47 language tag;e.g. fr-CA];stop;sleep 5;start。\n\n测试default资源的方式：将系统设置为你应用所不支持的configuration。\n\n## Inline Complex XML Resources\n\n有一些复杂的资源是需要依赖多个其他资源的，在这种情况下，就会产生很多资源文件。如果被依赖的资源不会用在别处，可以借助inline资源(`<aapt:attr>`标签)将多个资源放在同一文件中。\n`<aapt:attr>`标签所包裹的区域就是一个inline的资源xml，在编译时会被生成为单独的资源文件；这个inline的资源会被用作`<aapt:attr>`标签父标签的属性，属性名由`<aapt:attr>`标签的name属性制定。\n\n例如：\n>`<target android:name=\"rotationGroup\">`   \n>&emsp;&emsp;`<aapt:attr name=\"android:animation\" >`    \n>&emsp;&emsp;&emsp;&emsp;`<objectAnimator`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:duration=\"6000\"`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:propertyName=\"rotation\"`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:valueFrom=\"0\"`   \n>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`android:valueTo=\"360\" />`   \n>&emsp;&emsp;`</aapt:attr>`   \n>`</target>`   \n\n\n\n\n\n\n\n","slug":"android-developers-guide-note-app-resources","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p3000q3mrf71ve7jpm","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/07/new-tools-for-managing-screen-sizes.html\">New Tools For Managing Screen Sizes</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2012/01/holo-everywhere.html\">Holo Everywhere</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/07/new-mode-for-apps-on-large-screens.html\">New Mode for Apps on Large Screens</a>。  </li>\n<li>Fragment.setRetainInstance()的原理。</li>\n<li><a href=\"https://developer.android.google.cn/guide/topics/resources/localization.html#strategies\">Localization Checklist</a>。</li>\n<li><a href=\"https://support.google.com/l10n/answer/6359997\">App Translation Service</a>。</li>\n<li>ICU4J。</li>\n<li>在xml中<code>@</code>引用和<code>?</code>引用。</li>\n<li>library工程的R类是否与app的R类进行合并；在xml中资源的包名，例如@android:;library工程是否有单独的包名。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>直接把resource文件放置在res/目录下，会导致编译错误。</li>\n<li>configuration后缀有固定的顺序，其次序不能随意安排。</li>\n<li>aapt负责生成R类。</li>\n<li>在api13之后，orientation变化同时也会引发可用宽高变化；所以要自行处理orientation变化需要声明<code>android:configChanges=&quot;orientation|screenSize&quot;</code>。</li>\n</ul>\n<h2 id=\"Resources-Overview\"><a href=\"#Resources-Overview\" class=\"headerlink\" title=\"Resources Overview\"></a>Resources Overview</h2><p>所有的资源文件存放在<code>res/</code>目录下，并通过类型和configuration后缀安置在不同的子目录中。Android将资源和代码分离，除了保持整洁的结构之外，还便于随着configuration的变化在运行来变更所使用的资源。</p>\n<h2 id=\"Providing-Resources\"><a href=\"#Providing-Resources\" class=\"headerlink\" title=\"Providing Resources\"></a>Providing Resources</h2><h3 id=\"资源类型和组织方式\"><a href=\"#资源类型和组织方式\" class=\"headerlink\" title=\"资源类型和组织方式\"></a>资源类型和组织方式</h3><p>每一个资源文件(或资源item)都应该被放置在<code>res/</code>目录下的某个子目录里(对于item则是存在某个子目录的某个文件里)。不考虑config后缀，<code>res/</code>下的子目录是按照资源类型区分命名的。</p>\n<h4 id=\"子目录一览\"><a href=\"#子目录一览\" class=\"headerlink\" title=\"子目录一览\"></a>子目录一览</h4><p>Resource子目录类型表:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子目录名</th>\n<th style=\"text-align:left\">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>animator/</code></td>\n<td style=\"text-align:left\">属性动画的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>anim/</code></td>\n<td style=\"text-align:left\">view动画的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>color/</code></td>\n<td style=\"text-align:left\">color state list的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>drawable/</code></td>\n<td style=\"text-align:left\">包含bitmap文件(.png、.g.png、.jgp、.gif等)；包含用xml描述的drawable文件(stat list、shape、帧动画等)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>mipmap/</code></td>\n<td style=\"text-align:left\">应用图标。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>layout/</code></td>\n<td style=\"text-align:left\">布局xml。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>menu/</code></td>\n<td style=\"text-align:left\">menu xml。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>raw/</code></td>\n<td style=\"text-align:left\">不会被解释为任何类型的资源，单纯视为文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>values/</code></td>\n<td style=\"text-align:left\">存放包含各种value的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>xml/</code></td>\n<td style=\"text-align:left\">xml格式的配置文件，这些文件通常用于某些Android自带的framework中，如widget framework。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>font/</code></td>\n<td style=\"text-align:left\">包含字体文件(.ttf、.otf、.ttc)；包含xml描述的字体。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"values\"><a href=\"#values\" class=\"headerlink\" title=\"values/\"></a><code>values/</code></h4><p>这些子目录中<code>values/</code>目录比较特殊，也容易让初学者困惑。在其他目录中，单个文件就代表单个资源；在<code>values/</code>目录中，单个xml文件往往包含了一组资源，在xml中的单个特定标签代表单个资源。<br>事实上<code>values/</code>下的xml文件是可以随意命名的，标签名才是资源类别的标志；同时不同种类的资源可以写在同一个xml文件中。但是为了清晰，我没习惯给<code>values/</code>下的xml文件合理命名，并按类型将资源存放与不同的xml文件中。</p>\n<h3 id=\"提供动态可选资源\"><a href=\"#提供动态可选资源\" class=\"headerlink\" title=\"提供动态可选资源\"></a>提供动态可选资源</h3><h4 id=\"子目录及命名\"><a href=\"#子目录及命名\" class=\"headerlink\" title=\"子目录及命名\"></a>子目录及命名</h4><p>使用动态可选资源，需要借助<code>res/</code>下的子目录。首先建立名称格式为<code>&lt;resource_name&gt;[-&lt;config_qualifier&gt;...]</code>格式的子目录，然后把可选资源以完全相同的名称命名并放置在不同后缀的子目录下。</p>\n<p>注意，子目录的<code>&lt;config_qualifier&gt;</code>后缀可以有多个，后缀次序有严格定义(在后面表中的次序)，如果不安次序命名这个子目录会被系统忽略。</p>\n<h4 id=\"后缀一览表\"><a href=\"#后缀一览表\" class=\"headerlink\" title=\"后缀一览表\"></a>后缀一览表</h4><p>Android支持的config后缀表如下，表中的顺序和后缀出现在文件名中的顺序相同:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">后缀类型</th>\n<th style=\"text-align:left\">后缀示例</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">MCC &amp; MNC</td>\n<td style=\"text-align:left\">mcc310、mcc310-mnc004</td>\n<td style=\"text-align:left\">Mobile Country Code(MCC) &amp; Mobile Network Code(MNC)，从SIM卡中读出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">语言和地区</td>\n<td style=\"text-align:left\">en、en-rUs</td>\n<td style=\"text-align:left\">当前机器使用的语言(和地区)，格式为<code>&lt;语言code&gt;[-r&lt;地区code&gt;]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">布局方向</td>\n<td style=\"text-align:left\">ldrtl、ldltr</td>\n<td style=\"text-align:left\">布局是从右向左(ldrtl)还是从左向右(ldltr，这是默认行为)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">最小宽度</td>\n<td style=\"text-align:left\">sw<N>dp、sw600dp</td>\n<td style=\"text-align:left\">实际上是指屏幕宽度和高度中最小的dp数(并不仅是指宽度，所以也不随orientation变化)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可用宽度</td>\n<td style=\"text-align:left\">w<N>dp、w720dp</td>\n<td style=\"text-align:left\">当前可用的屏幕宽度，随orientation变化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可用高度</td>\n<td style=\"text-align:left\">h<N>dp、h720dp</td>\n<td style=\"text-align:left\">当前可用的屏幕高度，随orientation变化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">屏幕尺寸</td>\n<td style=\"text-align:left\">small、normal、large、xlarge</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否长屏幕</td>\n<td style=\"text-align:left\">long &amp; notlong</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否圆屏幕</td>\n<td style=\"text-align:left\">round &amp; notround</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">orientation</td>\n<td style=\"text-align:left\">port &amp; land</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UI mode</td>\n<td style=\"text-align:left\">{car, desk, television, appliance, watch, vrheadset}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否夜间模式</td>\n<td style=\"text-align:left\">night &amp; notnight</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">屏幕像素密度</td>\n<td style=\"text-align:left\">ldpi、mdpi</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">触屏类型</td>\n<td style=\"text-align:left\">notouch &amp; finger</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否有键盘</td>\n<td style=\"text-align:left\">keysexposed &amp; keyshidden &amp; keyssoft</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键盘输入方式</td>\n<td style=\"text-align:left\">nokeys &amp; qwerty &amp; 12key</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">系统版本</td>\n<td style=\"text-align:left\">v3、v11、v17</td>\n</tr>\n</tbody>\n</table>\n<p>使用从右向左布局，需要把<code>&lt;application&gt;</code>标签的android:supportsRtl属性设置为true并且targetSdkVersion大于17。<br>对于不用屏幕尺寸的资源(small、xlarge)，如果没有完全匹配的资源系统会选相最匹配的资源；但是系统不会选择更大尺寸的资源，所以如果所有可选尺寸都大于当前尺寸，运行时会报错。</p>\n<p>使用新版本系统才添加后缀，相当于自动为子目录添加了系统版本后缀，老版本系统会自动忽略这个子目录。例如可用宽度后缀来自api13，所以添加w600dp后缀的功效等于w600dp-v13。</p>\n<h4 id=\"可选资源子目录命名规则\"><a href=\"#可选资源子目录命名规则\" class=\"headerlink\" title=\"可选资源子目录命名规则\"></a>可选资源子目录命名规则</h4><ul>\n<li>同一个子目录可以包含多个后缀，用<code>-</code>符号分隔。</li>\n<li>后缀必须按照<em>后缀一览表</em>中的次序排列。</li>\n<li>子目录都需要直接存放在<code>res/</code>目录下。</li>\n<li>子目录名不区分大小写，在编译时编译器会将子目录名统一变为小写。</li>\n<li>同一个类后缀在一个子目录中只能出现一次。</li>\n</ul>\n<h4 id=\"使用资源引用\"><a href=\"#使用资源引用\" class=\"headerlink\" title=\"使用资源引用\"></a>使用资源引用</h4><p>为了防止将重复资源拷贝到不同的子目录下(比如在rES、rFR用图片A，rCA用图片B)，可以使用资源引用来解决；单并非所用类型的资源都支持资源引用。</p>\n<p>drawble资源以及string、color等value资源可以通过在<code>values／</code>目录下新建item来建立引用；layout资源可以通过<code>&lt;merge&gt;</code>标签和<code>&lt;include&gt;</code>标签来建立引用。</p>\n<h3 id=\"可选资源最佳实践\"><a href=\"#可选资源最佳实践\" class=\"headerlink\" title=\"可选资源最佳实践\"></a>可选资源最佳实践</h3><p>永远提供default资源(屏幕像素密度后缀是个例外)；低版本系统无法识别高版本加入的后缀，找不到匹配的资源会抛出异常。</p>\n<h3 id=\"Android系统的资源匹配规则\"><a href=\"#Android系统的资源匹配规则\" class=\"headerlink\" title=\"Android系统的资源匹配规则\"></a>Android系统的资源匹配规则</h3><ol>\n<li>剔除所有后缀和当前configuration有冲突的子目录(除了屏幕像素密度后缀)。</li>\n<li>在<em>后缀一览表</em>中，按优先级从高到低的顺序选中一类后缀。</li>\n<li>如果有子目录包含这类后缀，执行步骤4；否则返回步骤2。</li>\n<li>剔除所有不包含选中后缀的子目录(针对屏幕像素密度后缀则是选择最接近的)。</li>\n<li>如果只剩下一个子目录，则匹配资源确定；否则返回步骤2。</li>\n</ol>\n<h2 id=\"Accessing-Resources\"><a href=\"#Accessing-Resources\" class=\"headerlink\" title=\"Accessing Resources\"></a>Accessing Resources</h2><p>aapt脚本会根据资源生成R类，每个资源类型对应一个子类，没个资源对应一个静态整数常量。 </p>\n<h2 id=\"Handling-Configuration-Changes\"><a href=\"#Handling-Configuration-Changes\" class=\"headerlink\" title=\"Handling Configuration Changes\"></a>Handling Configuration Changes</h2><p>当Configuration变化时，Activity会被销毁重建，以便根据新的Configuration加载可选资源。在SaveInstanceState以外，本章将介绍其他两个应对Configuration变化的技巧。<br>即便自行处理Configuration变化，也不意味着可以避免处理SaveInstanceState，因为还有进程回收这个问题。</p>\n<h3 id=\"在Configuration变化时保留对象\"><a href=\"#在Configuration变化时保留对象\" class=\"headerlink\" title=\"在Configuration变化时保留对象\"></a>在Configuration变化时保留对象</h3><p>当重启Activity加载资源量较大，尤其涉及网络请求时，可以利用一个<em>被保留的</em>Fragment来协助保存数据。<br>创建一个不包含layout的Fragment(add by tag)，用它来保存状态数据，并对调用<code>Fragment. setRetainInstance(true)</code>。<br>注意不要让被保留的Fragment持有Activity的引用，否则在Activity销毁重建时会发生内存泄漏。</p>\n<h3 id=\"自行处理Configuration变化\"><a href=\"#自行处理Configuration变化\" class=\"headerlink\" title=\"自行处理Configuration变化\"></a>自行处理Configuration变化</h3><ul>\n<li>在<code>&lt;activity&gt;</code>标签的android:configChanges声明想要自行处理的Configuration变化。</li>\n<li>当被声明的Configuration发生变化时，Activity的onConfigurationChanged()被调用，当前的Configuration被作为参数传入。</li>\n</ul>\n<h2 id=\"Localizing-with-Resources\"><a href=\"#Localizing-with-Resources\" class=\"headerlink\" title=\"Localizing with Resources\"></a>Localizing with Resources</h2><p>使用<code>&lt;xliff:g&gt;</code>标签来标记string资源中不希望被翻译的部分：</p>\n<blockquote>\n<p><code>&lt;string name=&quot;countdown&quot;&gt;</code><br>&emsp;&emsp;<code>&lt;xliff:g id=&quot;time&quot; example=&quot;5 days&gt;%1$s&lt;/xliff:g&gt;until holiday</code><br><code>&lt;/string&gt;</code></p>\n</blockquote>\n<p>使用App Translation Service来翻译string资源，在Android Studio中就有入口。</p>\n<p>//TODO: in detail</p>\n<h3 id=\"测试本地化\"><a href=\"#测试本地化\" class=\"headerlink\" title=\"测试本地化\"></a>测试本地化</h3><p>使用adb更改语言 adb shell -&gt; setprop persist.sys.locale [BCP-47 language tag;e.g. fr-CA];stop;sleep 5;start。</p>\n<p>测试default资源的方式：将系统设置为你应用所不支持的configuration。</p>\n<h2 id=\"Inline-Complex-XML-Resources\"><a href=\"#Inline-Complex-XML-Resources\" class=\"headerlink\" title=\"Inline Complex XML Resources\"></a>Inline Complex XML Resources</h2><p>有一些复杂的资源是需要依赖多个其他资源的，在这种情况下，就会产生很多资源文件。如果被依赖的资源不会用在别处，可以借助inline资源(<code>&lt;aapt:attr&gt;</code>标签)将多个资源放在同一文件中。<br><code>&lt;aapt:attr&gt;</code>标签所包裹的区域就是一个inline的资源xml，在编译时会被生成为单独的资源文件；这个inline的资源会被用作<code>&lt;aapt:attr&gt;</code>标签父标签的属性，属性名由<code>&lt;aapt:attr&gt;</code>标签的name属性制定。</p>\n<p>例如：</p>\n<blockquote>\n<p><code>&lt;target android:name=&quot;rotationGroup&quot;&gt;</code><br>&emsp;&emsp;<code>&lt;aapt:attr name=&quot;android:animation&quot; &gt;</code><br>&emsp;&emsp;&emsp;&emsp;<code>&lt;objectAnimator</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:duration=&quot;6000&quot;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:propertyName=&quot;rotation&quot;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:valueFrom=&quot;0&quot;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:valueTo=&quot;360&quot; /&gt;</code><br>&emsp;&emsp;<code>&lt;/aapt:attr&gt;</code><br><code>&lt;/target&gt;</code>   </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li><a href=\"https://android-developers.googleblog.com/2011/07/new-tools-for-managing-screen-sizes.html\">New Tools For Managing Screen Sizes</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2012/01/holo-everywhere.html\">Holo Everywhere</a>。</li>\n<li><a href=\"https://android-developers.googleblog.com/2011/07/new-mode-for-apps-on-large-screens.html\">New Mode for Apps on Large Screens</a>。  </li>\n<li>Fragment.setRetainInstance()的原理。</li>\n<li><a href=\"https://developer.android.google.cn/guide/topics/resources/localization.html#strategies\">Localization Checklist</a>。</li>\n<li><a href=\"https://support.google.com/l10n/answer/6359997\">App Translation Service</a>。</li>\n<li>ICU4J。</li>\n<li>在xml中<code>@</code>引用和<code>?</code>引用。</li>\n<li>library工程的R类是否与app的R类进行合并；在xml中资源的包名，例如@android:;library工程是否有单独的包名。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>直接把resource文件放置在res/目录下，会导致编译错误。</li>\n<li>configuration后缀有固定的顺序，其次序不能随意安排。</li>\n<li>aapt负责生成R类。</li>\n<li>在api13之后，orientation变化同时也会引发可用宽高变化；所以要自行处理orientation变化需要声明<code>android:configChanges=&quot;orientation|screenSize&quot;</code>。</li>\n</ul>\n<h2 id=\"Resources-Overview\"><a href=\"#Resources-Overview\" class=\"headerlink\" title=\"Resources Overview\"></a>Resources Overview</h2><p>所有的资源文件存放在<code>res/</code>目录下，并通过类型和configuration后缀安置在不同的子目录中。Android将资源和代码分离，除了保持整洁的结构之外，还便于随着configuration的变化在运行来变更所使用的资源。</p>\n<h2 id=\"Providing-Resources\"><a href=\"#Providing-Resources\" class=\"headerlink\" title=\"Providing Resources\"></a>Providing Resources</h2><h3 id=\"资源类型和组织方式\"><a href=\"#资源类型和组织方式\" class=\"headerlink\" title=\"资源类型和组织方式\"></a>资源类型和组织方式</h3><p>每一个资源文件(或资源item)都应该被放置在<code>res/</code>目录下的某个子目录里(对于item则是存在某个子目录的某个文件里)。不考虑config后缀，<code>res/</code>下的子目录是按照资源类型区分命名的。</p>\n<h4 id=\"子目录一览\"><a href=\"#子目录一览\" class=\"headerlink\" title=\"子目录一览\"></a>子目录一览</h4><p>Resource子目录类型表:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">子目录名</th>\n<th style=\"text-align:left\">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>animator/</code></td>\n<td style=\"text-align:left\">属性动画的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>anim/</code></td>\n<td style=\"text-align:left\">view动画的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>color/</code></td>\n<td style=\"text-align:left\">color state list的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>drawable/</code></td>\n<td style=\"text-align:left\">包含bitmap文件(.png、.g.png、.jgp、.gif等)；包含用xml描述的drawable文件(stat list、shape、帧动画等)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>mipmap/</code></td>\n<td style=\"text-align:left\">应用图标。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>layout/</code></td>\n<td style=\"text-align:left\">布局xml。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>menu/</code></td>\n<td style=\"text-align:left\">menu xml。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>raw/</code></td>\n<td style=\"text-align:left\">不会被解释为任何类型的资源，单纯视为文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>values/</code></td>\n<td style=\"text-align:left\">存放包含各种value的xml文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>xml/</code></td>\n<td style=\"text-align:left\">xml格式的配置文件，这些文件通常用于某些Android自带的framework中，如widget framework。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>font/</code></td>\n<td style=\"text-align:left\">包含字体文件(.ttf、.otf、.ttc)；包含xml描述的字体。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"values\"><a href=\"#values\" class=\"headerlink\" title=\"values/\"></a><code>values/</code></h4><p>这些子目录中<code>values/</code>目录比较特殊，也容易让初学者困惑。在其他目录中，单个文件就代表单个资源；在<code>values/</code>目录中，单个xml文件往往包含了一组资源，在xml中的单个特定标签代表单个资源。<br>事实上<code>values/</code>下的xml文件是可以随意命名的，标签名才是资源类别的标志；同时不同种类的资源可以写在同一个xml文件中。但是为了清晰，我没习惯给<code>values/</code>下的xml文件合理命名，并按类型将资源存放与不同的xml文件中。</p>\n<h3 id=\"提供动态可选资源\"><a href=\"#提供动态可选资源\" class=\"headerlink\" title=\"提供动态可选资源\"></a>提供动态可选资源</h3><h4 id=\"子目录及命名\"><a href=\"#子目录及命名\" class=\"headerlink\" title=\"子目录及命名\"></a>子目录及命名</h4><p>使用动态可选资源，需要借助<code>res/</code>下的子目录。首先建立名称格式为<code>&lt;resource_name&gt;[-&lt;config_qualifier&gt;...]</code>格式的子目录，然后把可选资源以完全相同的名称命名并放置在不同后缀的子目录下。</p>\n<p>注意，子目录的<code>&lt;config_qualifier&gt;</code>后缀可以有多个，后缀次序有严格定义(在后面表中的次序)，如果不安次序命名这个子目录会被系统忽略。</p>\n<h4 id=\"后缀一览表\"><a href=\"#后缀一览表\" class=\"headerlink\" title=\"后缀一览表\"></a>后缀一览表</h4><p>Android支持的config后缀表如下，表中的顺序和后缀出现在文件名中的顺序相同:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">后缀类型</th>\n<th style=\"text-align:left\">后缀示例</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">MCC &amp; MNC</td>\n<td style=\"text-align:left\">mcc310、mcc310-mnc004</td>\n<td style=\"text-align:left\">Mobile Country Code(MCC) &amp; Mobile Network Code(MNC)，从SIM卡中读出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">语言和地区</td>\n<td style=\"text-align:left\">en、en-rUs</td>\n<td style=\"text-align:left\">当前机器使用的语言(和地区)，格式为<code>&lt;语言code&gt;[-r&lt;地区code&gt;]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">布局方向</td>\n<td style=\"text-align:left\">ldrtl、ldltr</td>\n<td style=\"text-align:left\">布局是从右向左(ldrtl)还是从左向右(ldltr，这是默认行为)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">最小宽度</td>\n<td style=\"text-align:left\">sw<N>dp、sw600dp</td>\n<td style=\"text-align:left\">实际上是指屏幕宽度和高度中最小的dp数(并不仅是指宽度，所以也不随orientation变化)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可用宽度</td>\n<td style=\"text-align:left\">w<N>dp、w720dp</td>\n<td style=\"text-align:left\">当前可用的屏幕宽度，随orientation变化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可用高度</td>\n<td style=\"text-align:left\">h<N>dp、h720dp</td>\n<td style=\"text-align:left\">当前可用的屏幕高度，随orientation变化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">屏幕尺寸</td>\n<td style=\"text-align:left\">small、normal、large、xlarge</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否长屏幕</td>\n<td style=\"text-align:left\">long &amp; notlong</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否圆屏幕</td>\n<td style=\"text-align:left\">round &amp; notround</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">orientation</td>\n<td style=\"text-align:left\">port &amp; land</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UI mode</td>\n<td style=\"text-align:left\">{car, desk, television, appliance, watch, vrheadset}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否夜间模式</td>\n<td style=\"text-align:left\">night &amp; notnight</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">屏幕像素密度</td>\n<td style=\"text-align:left\">ldpi、mdpi</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">触屏类型</td>\n<td style=\"text-align:left\">notouch &amp; finger</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否有键盘</td>\n<td style=\"text-align:left\">keysexposed &amp; keyshidden &amp; keyssoft</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键盘输入方式</td>\n<td style=\"text-align:left\">nokeys &amp; qwerty &amp; 12key</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">系统版本</td>\n<td style=\"text-align:left\">v3、v11、v17</td>\n</tr>\n</tbody>\n</table>\n<p>使用从右向左布局，需要把<code>&lt;application&gt;</code>标签的android:supportsRtl属性设置为true并且targetSdkVersion大于17。<br>对于不用屏幕尺寸的资源(small、xlarge)，如果没有完全匹配的资源系统会选相最匹配的资源；但是系统不会选择更大尺寸的资源，所以如果所有可选尺寸都大于当前尺寸，运行时会报错。</p>\n<p>使用新版本系统才添加后缀，相当于自动为子目录添加了系统版本后缀，老版本系统会自动忽略这个子目录。例如可用宽度后缀来自api13，所以添加w600dp后缀的功效等于w600dp-v13。</p>\n<h4 id=\"可选资源子目录命名规则\"><a href=\"#可选资源子目录命名规则\" class=\"headerlink\" title=\"可选资源子目录命名规则\"></a>可选资源子目录命名规则</h4><ul>\n<li>同一个子目录可以包含多个后缀，用<code>-</code>符号分隔。</li>\n<li>后缀必须按照<em>后缀一览表</em>中的次序排列。</li>\n<li>子目录都需要直接存放在<code>res/</code>目录下。</li>\n<li>子目录名不区分大小写，在编译时编译器会将子目录名统一变为小写。</li>\n<li>同一个类后缀在一个子目录中只能出现一次。</li>\n</ul>\n<h4 id=\"使用资源引用\"><a href=\"#使用资源引用\" class=\"headerlink\" title=\"使用资源引用\"></a>使用资源引用</h4><p>为了防止将重复资源拷贝到不同的子目录下(比如在rES、rFR用图片A，rCA用图片B)，可以使用资源引用来解决；单并非所用类型的资源都支持资源引用。</p>\n<p>drawble资源以及string、color等value资源可以通过在<code>values／</code>目录下新建item来建立引用；layout资源可以通过<code>&lt;merge&gt;</code>标签和<code>&lt;include&gt;</code>标签来建立引用。</p>\n<h3 id=\"可选资源最佳实践\"><a href=\"#可选资源最佳实践\" class=\"headerlink\" title=\"可选资源最佳实践\"></a>可选资源最佳实践</h3><p>永远提供default资源(屏幕像素密度后缀是个例外)；低版本系统无法识别高版本加入的后缀，找不到匹配的资源会抛出异常。</p>\n<h3 id=\"Android系统的资源匹配规则\"><a href=\"#Android系统的资源匹配规则\" class=\"headerlink\" title=\"Android系统的资源匹配规则\"></a>Android系统的资源匹配规则</h3><ol>\n<li>剔除所有后缀和当前configuration有冲突的子目录(除了屏幕像素密度后缀)。</li>\n<li>在<em>后缀一览表</em>中，按优先级从高到低的顺序选中一类后缀。</li>\n<li>如果有子目录包含这类后缀，执行步骤4；否则返回步骤2。</li>\n<li>剔除所有不包含选中后缀的子目录(针对屏幕像素密度后缀则是选择最接近的)。</li>\n<li>如果只剩下一个子目录，则匹配资源确定；否则返回步骤2。</li>\n</ol>\n<h2 id=\"Accessing-Resources\"><a href=\"#Accessing-Resources\" class=\"headerlink\" title=\"Accessing Resources\"></a>Accessing Resources</h2><p>aapt脚本会根据资源生成R类，每个资源类型对应一个子类，没个资源对应一个静态整数常量。 </p>\n<h2 id=\"Handling-Configuration-Changes\"><a href=\"#Handling-Configuration-Changes\" class=\"headerlink\" title=\"Handling Configuration Changes\"></a>Handling Configuration Changes</h2><p>当Configuration变化时，Activity会被销毁重建，以便根据新的Configuration加载可选资源。在SaveInstanceState以外，本章将介绍其他两个应对Configuration变化的技巧。<br>即便自行处理Configuration变化，也不意味着可以避免处理SaveInstanceState，因为还有进程回收这个问题。</p>\n<h3 id=\"在Configuration变化时保留对象\"><a href=\"#在Configuration变化时保留对象\" class=\"headerlink\" title=\"在Configuration变化时保留对象\"></a>在Configuration变化时保留对象</h3><p>当重启Activity加载资源量较大，尤其涉及网络请求时，可以利用一个<em>被保留的</em>Fragment来协助保存数据。<br>创建一个不包含layout的Fragment(add by tag)，用它来保存状态数据，并对调用<code>Fragment. setRetainInstance(true)</code>。<br>注意不要让被保留的Fragment持有Activity的引用，否则在Activity销毁重建时会发生内存泄漏。</p>\n<h3 id=\"自行处理Configuration变化\"><a href=\"#自行处理Configuration变化\" class=\"headerlink\" title=\"自行处理Configuration变化\"></a>自行处理Configuration变化</h3><ul>\n<li>在<code>&lt;activity&gt;</code>标签的android:configChanges声明想要自行处理的Configuration变化。</li>\n<li>当被声明的Configuration发生变化时，Activity的onConfigurationChanged()被调用，当前的Configuration被作为参数传入。</li>\n</ul>\n<h2 id=\"Localizing-with-Resources\"><a href=\"#Localizing-with-Resources\" class=\"headerlink\" title=\"Localizing with Resources\"></a>Localizing with Resources</h2><p>使用<code>&lt;xliff:g&gt;</code>标签来标记string资源中不希望被翻译的部分：</p>\n<blockquote>\n<p><code>&lt;string name=&quot;countdown&quot;&gt;</code><br>&emsp;&emsp;<code>&lt;xliff:g id=&quot;time&quot; example=&quot;5 days&gt;%1$s&lt;/xliff:g&gt;until holiday</code><br><code>&lt;/string&gt;</code></p>\n</blockquote>\n<p>使用App Translation Service来翻译string资源，在Android Studio中就有入口。</p>\n<p>//TODO: in detail</p>\n<h3 id=\"测试本地化\"><a href=\"#测试本地化\" class=\"headerlink\" title=\"测试本地化\"></a>测试本地化</h3><p>使用adb更改语言 adb shell -&gt; setprop persist.sys.locale [BCP-47 language tag;e.g. fr-CA];stop;sleep 5;start。</p>\n<p>测试default资源的方式：将系统设置为你应用所不支持的configuration。</p>\n<h2 id=\"Inline-Complex-XML-Resources\"><a href=\"#Inline-Complex-XML-Resources\" class=\"headerlink\" title=\"Inline Complex XML Resources\"></a>Inline Complex XML Resources</h2><p>有一些复杂的资源是需要依赖多个其他资源的，在这种情况下，就会产生很多资源文件。如果被依赖的资源不会用在别处，可以借助inline资源(<code>&lt;aapt:attr&gt;</code>标签)将多个资源放在同一文件中。<br><code>&lt;aapt:attr&gt;</code>标签所包裹的区域就是一个inline的资源xml，在编译时会被生成为单独的资源文件；这个inline的资源会被用作<code>&lt;aapt:attr&gt;</code>标签父标签的属性，属性名由<code>&lt;aapt:attr&gt;</code>标签的name属性制定。</p>\n<p>例如：</p>\n<blockquote>\n<p><code>&lt;target android:name=&quot;rotationGroup&quot;&gt;</code><br>&emsp;&emsp;<code>&lt;aapt:attr name=&quot;android:animation&quot; &gt;</code><br>&emsp;&emsp;&emsp;&emsp;<code>&lt;objectAnimator</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:duration=&quot;6000&quot;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:propertyName=&quot;rotation&quot;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:valueFrom=&quot;0&quot;</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>android:valueTo=&quot;360&quot; /&gt;</code><br>&emsp;&emsp;<code>&lt;/aapt:attr&gt;</code><br><code>&lt;/target&gt;</code>   </p>\n</blockquote>\n"},{"title":"Android Developer Guide中的Manifest","subtitle":"Android官方guide随笔 - Manifest","catalog":true,"header-img":"/img/header_img/android-note-header.jpg","date":"2017-09-09T09:57:22.000Z","_content":"\n\n# 展开点   \n\n* `<activity-alias>`。\n* `<instrumentation>`。\n* [Google Cloud（backend）](https://cloud.google.com/tools/android-studio/app_engine/run_test_deploy)。\n* App自身组件声明的permission对本app是否有限制作用；App自己定义的permission对本app是否有限制作用。\n\n## App Manifest \n\nManifest文件包含了App向系统注册的信息，相当于系统如何使用这个App的参考手册。\n\n### Manifest文件书写惯例\n\n#### 标签使用惯例 \n\n* 必要标签，只有`<manifest>`和`<application>`标签在Manifest文件中必须有且仅有一个。\n* 标签顺序，大部分平级标签是无序的，除了两个例外情况。\n    - `<activity-alias>`标签必须在其引用的`<activity>`标签之后。\n    - `<application>`标签必须是`<manifest>`标签下的**最后一个**标签。\n\n#### 属性使用惯例\n\n除了`<manifest>`中的几个属性，所有属性名都包含android:前缀。\n\n#### 引用Java Class\n\n在Manifest中引用Java Class需要使用包名+类名的完全格式；如果Java Class引用以`.`符号开头，会用`<manifest>`的packageName属性来补全`.`之前部分。\n如果component标签中没有在android:name指定subclass，系统会使用baseClass来创建对象(即Activity，Service)。\n\n#### 引用资源\n\n和在资源文件中引用资源相同，格式为`@[package:]type/name`或者`?[package:]type/name`(in theme)。其中package必须是App包名或者`android`。\n\n#### 字符串值\n\nManifest中的纯字符串值需要使用`\\\\`作为转意符，例如`\\n`需要写作`\\\\n`。\n\n### Manifest文件中的功能\n\n#### Intent filters\n\n见[Intent相关笔记](http://blog.overspark.me/2017/07/26/android-developers-guide-note-app-components-intents/)\n\n#### Icon和Label\n\n很多表情都包含android:icon和android:label属性，这两个属性的默认值会继承自父标签。这两个属性的默认值继承树的根节点一般是`<application>`标签(应用Icon和应用名)。有时候一些抽象标签，例如`intent-filter`的android:icon和android:label属性会被某些系统UI使用，例如Setting App。\n\n### Manifest结构一览表\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n[`<manifest>`](https://developer.android.com/guide/topics/manifest/manifest-element.html)\n \n&emsp;&emsp;[`<uses-permission />`](https://developer.android.com/guide/topics/manifest/uses-permission-element.html)   \n&emsp;&emsp;[`<permission />`](https://developer.android.com/guide/topics/manifest/permission-element.html)   \n&emsp;&emsp;[`<permission-tree />`](https://developer.android.com/guide/topics/manifest/permission-tree-element.html)   \n&emsp;&emsp;[`<permission-group />`](https://developer.android.com/guide/topics/manifest/permission-group-element.html)   \n&emsp;&emsp;[`<instrumentation />`](https://developer.android.com/guide/topics/manifest/instrumentation-element.html)   \n&emsp;&emsp;[`<uses-sdk />`](https://developer.android.com/guide/topics/manifest/uses-sdk-element.html)   \n&emsp;&emsp;[`<uses-configuration />`](https://developer.android.com/guide/topics/manifest/uses-configuration-element.html)  \n&emsp;&emsp;[`<uses-feature />`](https://developer.android.com/guide/topics/manifest/uses-feature-element.html)   \n&emsp;&emsp;[`<supports-screens />`](https://developer.android.com/guide/topics/manifest/supports-screens-element.html)   \n&emsp;&emsp;[`<compatible-screens />`](https://developer.android.com/guide/topics/manifest/compatible-screens-element.html)    \n&emsp;&emsp;[`<supports-gl-texture />`](https://developer.android.com/guide/topics/manifest/supports-gl-texture-element.html)   \n\n&emsp;&emsp;[`<application>`](https://developer.android.com/guide/topics/manifest/application-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<activity>`](https://developer.android.com/guide/topics/manifest/activity-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<action />`](https://developer.android.com/guide/topics/manifest/action-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<category />`](https://developer.android.com/guide/topics/manifest/category-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<data />`](https://developer.android.com/guide/topics/manifest/data-element.html)  \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`</intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n &emsp;&emsp;&emsp;&emsp;[`</activity>`](https://developer.android.com/guide/topics/manifest/activity-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<activity-alias>`](https://developer.android.com/guide/topics/manifest/activity-alias-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter> . . . </intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</activity-alias>`](https://developer.android.com/guide/topics/manifest/activity-alias-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<service>`](https://developer.android.com/guide/topics/manifest/service-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter> . . . </intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data/>`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</service>`](https://developer.android.com/guide/topics/manifest/service-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<receiver>`](https://developer.android.com/guide/topics/manifest/receiver-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter> . . . </intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</receiver>`](https://developer.android.com/guide/topics/manifest/receiver-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<grant-uri-permission />`](https://developer.android.com/guide/topics/manifest/grant-uri-permission-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<path-permission />`](https://developer.android.com/guide/topics/manifest/path-permission-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</provider>`](https://developer.android.com/guide/topics/manifest/provider-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<uses-library />`](https://developer.android.com/guide/topics/manifest/uses-library-element.html)   \n\n&emsp;&emsp;[`</application>`](https://developer.android.com/guide/topics/manifest/application-element.html)   \n\n[`</manifest>`](https://developer.android.com/guide/topics/manifest/manifest-element.html)   ","source":"_posts/android-developers-guide-note-app-manifest.md","raw":"---\ntitle: Android Developer Guide中的Manifest\nsubtitle: Android官方guide随笔 - Manifest\ncatalog: true\nheader-img: /img/header_img/android-note-header.jpg\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-09-09 17:57:22\n---\n\n\n# 展开点   \n\n* `<activity-alias>`。\n* `<instrumentation>`。\n* [Google Cloud（backend）](https://cloud.google.com/tools/android-studio/app_engine/run_test_deploy)。\n* App自身组件声明的permission对本app是否有限制作用；App自己定义的permission对本app是否有限制作用。\n\n## App Manifest \n\nManifest文件包含了App向系统注册的信息，相当于系统如何使用这个App的参考手册。\n\n### Manifest文件书写惯例\n\n#### 标签使用惯例 \n\n* 必要标签，只有`<manifest>`和`<application>`标签在Manifest文件中必须有且仅有一个。\n* 标签顺序，大部分平级标签是无序的，除了两个例外情况。\n    - `<activity-alias>`标签必须在其引用的`<activity>`标签之后。\n    - `<application>`标签必须是`<manifest>`标签下的**最后一个**标签。\n\n#### 属性使用惯例\n\n除了`<manifest>`中的几个属性，所有属性名都包含android:前缀。\n\n#### 引用Java Class\n\n在Manifest中引用Java Class需要使用包名+类名的完全格式；如果Java Class引用以`.`符号开头，会用`<manifest>`的packageName属性来补全`.`之前部分。\n如果component标签中没有在android:name指定subclass，系统会使用baseClass来创建对象(即Activity，Service)。\n\n#### 引用资源\n\n和在资源文件中引用资源相同，格式为`@[package:]type/name`或者`?[package:]type/name`(in theme)。其中package必须是App包名或者`android`。\n\n#### 字符串值\n\nManifest中的纯字符串值需要使用`\\\\`作为转意符，例如`\\n`需要写作`\\\\n`。\n\n### Manifest文件中的功能\n\n#### Intent filters\n\n见[Intent相关笔记](http://blog.overspark.me/2017/07/26/android-developers-guide-note-app-components-intents/)\n\n#### Icon和Label\n\n很多表情都包含android:icon和android:label属性，这两个属性的默认值会继承自父标签。这两个属性的默认值继承树的根节点一般是`<application>`标签(应用Icon和应用名)。有时候一些抽象标签，例如`intent-filter`的android:icon和android:label属性会被某些系统UI使用，例如Setting App。\n\n### Manifest结构一览表\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n[`<manifest>`](https://developer.android.com/guide/topics/manifest/manifest-element.html)\n \n&emsp;&emsp;[`<uses-permission />`](https://developer.android.com/guide/topics/manifest/uses-permission-element.html)   \n&emsp;&emsp;[`<permission />`](https://developer.android.com/guide/topics/manifest/permission-element.html)   \n&emsp;&emsp;[`<permission-tree />`](https://developer.android.com/guide/topics/manifest/permission-tree-element.html)   \n&emsp;&emsp;[`<permission-group />`](https://developer.android.com/guide/topics/manifest/permission-group-element.html)   \n&emsp;&emsp;[`<instrumentation />`](https://developer.android.com/guide/topics/manifest/instrumentation-element.html)   \n&emsp;&emsp;[`<uses-sdk />`](https://developer.android.com/guide/topics/manifest/uses-sdk-element.html)   \n&emsp;&emsp;[`<uses-configuration />`](https://developer.android.com/guide/topics/manifest/uses-configuration-element.html)  \n&emsp;&emsp;[`<uses-feature />`](https://developer.android.com/guide/topics/manifest/uses-feature-element.html)   \n&emsp;&emsp;[`<supports-screens />`](https://developer.android.com/guide/topics/manifest/supports-screens-element.html)   \n&emsp;&emsp;[`<compatible-screens />`](https://developer.android.com/guide/topics/manifest/compatible-screens-element.html)    \n&emsp;&emsp;[`<supports-gl-texture />`](https://developer.android.com/guide/topics/manifest/supports-gl-texture-element.html)   \n\n&emsp;&emsp;[`<application>`](https://developer.android.com/guide/topics/manifest/application-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<activity>`](https://developer.android.com/guide/topics/manifest/activity-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<action />`](https://developer.android.com/guide/topics/manifest/action-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<category />`](https://developer.android.com/guide/topics/manifest/category-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<data />`](https://developer.android.com/guide/topics/manifest/data-element.html)  \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`</intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n &emsp;&emsp;&emsp;&emsp;[`</activity>`](https://developer.android.com/guide/topics/manifest/activity-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<activity-alias>`](https://developer.android.com/guide/topics/manifest/activity-alias-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter> . . . </intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</activity-alias>`](https://developer.android.com/guide/topics/manifest/activity-alias-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<service>`](https://developer.android.com/guide/topics/manifest/service-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter> . . . </intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data/>`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</service>`](https://developer.android.com/guide/topics/manifest/service-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<receiver>`](https://developer.android.com/guide/topics/manifest/receiver-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<intent-filter> . . . </intent-filter>`](https://developer.android.com/guide/topics/manifest/intent-filter-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</receiver>`](https://developer.android.com/guide/topics/manifest/receiver-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<grant-uri-permission />`](https://developer.android.com/guide/topics/manifest/grant-uri-permission-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<meta-data />`](https://developer.android.com/guide/topics/manifest/meta-data-element.html)   \n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[`<path-permission />`](https://developer.android.com/guide/topics/manifest/path-permission-element.html)   \n&emsp;&emsp;&emsp;&emsp;[`</provider>`](https://developer.android.com/guide/topics/manifest/provider-element.html)   \n\n&emsp;&emsp;&emsp;&emsp;[`<uses-library />`](https://developer.android.com/guide/topics/manifest/uses-library-element.html)   \n\n&emsp;&emsp;[`</application>`](https://developer.android.com/guide/topics/manifest/application-element.html)   \n\n[`</manifest>`](https://developer.android.com/guide/topics/manifest/manifest-element.html)   ","slug":"android-developers-guide-note-app-manifest","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p3000r3mrf773jcvim","content":"<h1 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h1><ul>\n<li><code>&lt;activity-alias&gt;</code>。</li>\n<li><code>&lt;instrumentation&gt;</code>。</li>\n<li><a href=\"https://cloud.google.com/tools/android-studio/app_engine/run_test_deploy\">Google Cloud（backend）</a>。</li>\n<li>App自身组件声明的permission对本app是否有限制作用；App自己定义的permission对本app是否有限制作用。</li>\n</ul>\n<h2 id=\"App-Manifest\"><a href=\"#App-Manifest\" class=\"headerlink\" title=\"App Manifest\"></a>App Manifest</h2><p>Manifest文件包含了App向系统注册的信息，相当于系统如何使用这个App的参考手册。</p>\n<h3 id=\"Manifest文件书写惯例\"><a href=\"#Manifest文件书写惯例\" class=\"headerlink\" title=\"Manifest文件书写惯例\"></a>Manifest文件书写惯例</h3><h4 id=\"标签使用惯例\"><a href=\"#标签使用惯例\" class=\"headerlink\" title=\"标签使用惯例\"></a>标签使用惯例</h4><ul>\n<li>必要标签，只有<code>&lt;manifest&gt;</code>和<code>&lt;application&gt;</code>标签在Manifest文件中必须有且仅有一个。</li>\n<li>标签顺序，大部分平级标签是无序的，除了两个例外情况。<ul>\n<li><code>&lt;activity-alias&gt;</code>标签必须在其引用的<code>&lt;activity&gt;</code>标签之后。</li>\n<li><code>&lt;application&gt;</code>标签必须是<code>&lt;manifest&gt;</code>标签下的<strong>最后一个</strong>标签。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"属性使用惯例\"><a href=\"#属性使用惯例\" class=\"headerlink\" title=\"属性使用惯例\"></a>属性使用惯例</h4><p>除了<code>&lt;manifest&gt;</code>中的几个属性，所有属性名都包含android:前缀。</p>\n<h4 id=\"引用Java-Class\"><a href=\"#引用Java-Class\" class=\"headerlink\" title=\"引用Java Class\"></a>引用Java Class</h4><p>在Manifest中引用Java Class需要使用包名+类名的完全格式；如果Java Class引用以<code>.</code>符号开头，会用<code>&lt;manifest&gt;</code>的packageName属性来补全<code>.</code>之前部分。<br>如果component标签中没有在android:name指定subclass，系统会使用baseClass来创建对象(即Activity，Service)。</p>\n<h4 id=\"引用资源\"><a href=\"#引用资源\" class=\"headerlink\" title=\"引用资源\"></a>引用资源</h4><p>和在资源文件中引用资源相同，格式为<code>@[package:]type/name</code>或者<code>?[package:]type/name</code>(in theme)。其中package必须是App包名或者<code>android</code>。</p>\n<h4 id=\"字符串值\"><a href=\"#字符串值\" class=\"headerlink\" title=\"字符串值\"></a>字符串值</h4><p>Manifest中的纯字符串值需要使用<code>\\\\</code>作为转意符，例如<code>\\n</code>需要写作<code>\\\\n</code>。</p>\n<h3 id=\"Manifest文件中的功能\"><a href=\"#Manifest文件中的功能\" class=\"headerlink\" title=\"Manifest文件中的功能\"></a>Manifest文件中的功能</h3><h4 id=\"Intent-filters\"><a href=\"#Intent-filters\" class=\"headerlink\" title=\"Intent filters\"></a>Intent filters</h4><p>见<a href=\"http://blog.overspark.me/2017/07/26/android-developers-guide-note-app-components-intents/\">Intent相关笔记</a></p>\n<h4 id=\"Icon和Label\"><a href=\"#Icon和Label\" class=\"headerlink\" title=\"Icon和Label\"></a>Icon和Label</h4><p>很多表情都包含android:icon和android:label属性，这两个属性的默认值会继承自父标签。这两个属性的默认值继承树的根节点一般是<code>&lt;application&gt;</code>标签(应用Icon和应用名)。有时候一些抽象标签，例如<code>intent-filter</code>的android:icon和android:label属性会被某些系统UI使用，例如Setting App。</p>\n<h3 id=\"Manifest结构一览表\"><a href=\"#Manifest结构一览表\" class=\"headerlink\" title=\"Manifest结构一览表\"></a>Manifest结构一览表</h3><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>\n<p><a href=\"https://developer.android.com/guide/topics/manifest/manifest-element.html\"><code>&lt;manifest&gt;</code></a></p>\n<p>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-permission-element.html\"><code>&lt;uses-permission /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/permission-element.html\"><code>&lt;permission /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/permission-tree-element.html\"><code>&lt;permission-tree /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/permission-group-element.html\"><code>&lt;permission-group /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/instrumentation-element.html\"><code>&lt;instrumentation /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-sdk-element.html\"><code>&lt;uses-sdk /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-configuration-element.html\"><code>&lt;uses-configuration /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-feature-element.html\"><code>&lt;uses-feature /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/supports-screens-element.html\"><code>&lt;supports-screens /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/compatible-screens-element.html\"><code>&lt;compatible-screens /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/supports-gl-texture-element.html\"><code>&lt;supports-gl-texture /&gt;</code></a>   </p>\n<p>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/application-element.html\"><code>&lt;application&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-element.html\"><code>&lt;activity&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/action-element.html\"><code>&lt;action /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/category-element.html\"><code>&lt;category /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/data-element.html\"><code>&lt;data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br> &emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-element.html\"><code>&lt;/activity&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-alias-element.html\"><code>&lt;activity-alias&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt; . . . &lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-alias-element.html\"><code>&lt;/activity-alias&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/service-element.html\"><code>&lt;service&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt; . . . &lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data/&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/service-element.html\"><code>&lt;/service&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/receiver-element.html\"><code>&lt;receiver&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt; . . . &lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/receiver-element.html\"><code>&lt;/receiver&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/provider-element.html\"><code>&lt;provider&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/grant-uri-permission-element.html\"><code>&lt;grant-uri-permission /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/path-permission-element.html\"><code>&lt;path-permission /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/provider-element.html\"><code>&lt;/provider&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-library-element.html\"><code>&lt;uses-library /&gt;</code></a>   </p>\n<p>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/application-element.html\"><code>&lt;/application&gt;</code></a>   </p>\n<p><a href=\"https://developer.android.com/guide/topics/manifest/manifest-element.html\"><code>&lt;/manifest&gt;</code></a>   </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h1><ul>\n<li><code>&lt;activity-alias&gt;</code>。</li>\n<li><code>&lt;instrumentation&gt;</code>。</li>\n<li><a href=\"https://cloud.google.com/tools/android-studio/app_engine/run_test_deploy\">Google Cloud（backend）</a>。</li>\n<li>App自身组件声明的permission对本app是否有限制作用；App自己定义的permission对本app是否有限制作用。</li>\n</ul>\n<h2 id=\"App-Manifest\"><a href=\"#App-Manifest\" class=\"headerlink\" title=\"App Manifest\"></a>App Manifest</h2><p>Manifest文件包含了App向系统注册的信息，相当于系统如何使用这个App的参考手册。</p>\n<h3 id=\"Manifest文件书写惯例\"><a href=\"#Manifest文件书写惯例\" class=\"headerlink\" title=\"Manifest文件书写惯例\"></a>Manifest文件书写惯例</h3><h4 id=\"标签使用惯例\"><a href=\"#标签使用惯例\" class=\"headerlink\" title=\"标签使用惯例\"></a>标签使用惯例</h4><ul>\n<li>必要标签，只有<code>&lt;manifest&gt;</code>和<code>&lt;application&gt;</code>标签在Manifest文件中必须有且仅有一个。</li>\n<li>标签顺序，大部分平级标签是无序的，除了两个例外情况。<ul>\n<li><code>&lt;activity-alias&gt;</code>标签必须在其引用的<code>&lt;activity&gt;</code>标签之后。</li>\n<li><code>&lt;application&gt;</code>标签必须是<code>&lt;manifest&gt;</code>标签下的<strong>最后一个</strong>标签。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"属性使用惯例\"><a href=\"#属性使用惯例\" class=\"headerlink\" title=\"属性使用惯例\"></a>属性使用惯例</h4><p>除了<code>&lt;manifest&gt;</code>中的几个属性，所有属性名都包含android:前缀。</p>\n<h4 id=\"引用Java-Class\"><a href=\"#引用Java-Class\" class=\"headerlink\" title=\"引用Java Class\"></a>引用Java Class</h4><p>在Manifest中引用Java Class需要使用包名+类名的完全格式；如果Java Class引用以<code>.</code>符号开头，会用<code>&lt;manifest&gt;</code>的packageName属性来补全<code>.</code>之前部分。<br>如果component标签中没有在android:name指定subclass，系统会使用baseClass来创建对象(即Activity，Service)。</p>\n<h4 id=\"引用资源\"><a href=\"#引用资源\" class=\"headerlink\" title=\"引用资源\"></a>引用资源</h4><p>和在资源文件中引用资源相同，格式为<code>@[package:]type/name</code>或者<code>?[package:]type/name</code>(in theme)。其中package必须是App包名或者<code>android</code>。</p>\n<h4 id=\"字符串值\"><a href=\"#字符串值\" class=\"headerlink\" title=\"字符串值\"></a>字符串值</h4><p>Manifest中的纯字符串值需要使用<code>\\\\</code>作为转意符，例如<code>\\n</code>需要写作<code>\\\\n</code>。</p>\n<h3 id=\"Manifest文件中的功能\"><a href=\"#Manifest文件中的功能\" class=\"headerlink\" title=\"Manifest文件中的功能\"></a>Manifest文件中的功能</h3><h4 id=\"Intent-filters\"><a href=\"#Intent-filters\" class=\"headerlink\" title=\"Intent filters\"></a>Intent filters</h4><p>见<a href=\"http://blog.overspark.me/2017/07/26/android-developers-guide-note-app-components-intents/\">Intent相关笔记</a></p>\n<h4 id=\"Icon和Label\"><a href=\"#Icon和Label\" class=\"headerlink\" title=\"Icon和Label\"></a>Icon和Label</h4><p>很多表情都包含android:icon和android:label属性，这两个属性的默认值会继承自父标签。这两个属性的默认值继承树的根节点一般是<code>&lt;application&gt;</code>标签(应用Icon和应用名)。有时候一些抽象标签，例如<code>intent-filter</code>的android:icon和android:label属性会被某些系统UI使用，例如Setting App。</p>\n<h3 id=\"Manifest结构一览表\"><a href=\"#Manifest结构一览表\" class=\"headerlink\" title=\"Manifest结构一览表\"></a>Manifest结构一览表</h3><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>\n<p><a href=\"https://developer.android.com/guide/topics/manifest/manifest-element.html\"><code>&lt;manifest&gt;</code></a></p>\n<p>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-permission-element.html\"><code>&lt;uses-permission /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/permission-element.html\"><code>&lt;permission /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/permission-tree-element.html\"><code>&lt;permission-tree /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/permission-group-element.html\"><code>&lt;permission-group /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/instrumentation-element.html\"><code>&lt;instrumentation /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-sdk-element.html\"><code>&lt;uses-sdk /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-configuration-element.html\"><code>&lt;uses-configuration /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-feature-element.html\"><code>&lt;uses-feature /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/supports-screens-element.html\"><code>&lt;supports-screens /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/compatible-screens-element.html\"><code>&lt;compatible-screens /&gt;</code></a><br>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/supports-gl-texture-element.html\"><code>&lt;supports-gl-texture /&gt;</code></a>   </p>\n<p>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/application-element.html\"><code>&lt;application&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-element.html\"><code>&lt;activity&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/action-element.html\"><code>&lt;action /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/category-element.html\"><code>&lt;category /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/data-element.html\"><code>&lt;data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br> &emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-element.html\"><code>&lt;/activity&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-alias-element.html\"><code>&lt;activity-alias&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt; . . . &lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/activity-alias-element.html\"><code>&lt;/activity-alias&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/service-element.html\"><code>&lt;service&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt; . . . &lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data/&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/service-element.html\"><code>&lt;/service&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/receiver-element.html\"><code>&lt;receiver&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\"><code>&lt;intent-filter&gt; . . . &lt;/intent-filter&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/receiver-element.html\"><code>&lt;/receiver&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/provider-element.html\"><code>&lt;provider&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/grant-uri-permission-element.html\"><code>&lt;grant-uri-permission /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/meta-data-element.html\"><code>&lt;meta-data /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/path-permission-element.html\"><code>&lt;path-permission /&gt;</code></a><br>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/provider-element.html\"><code>&lt;/provider&gt;</code></a>   </p>\n<p>&emsp;&emsp;&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/uses-library-element.html\"><code>&lt;uses-library /&gt;</code></a>   </p>\n<p>&emsp;&emsp;<a href=\"https://developer.android.com/guide/topics/manifest/application-element.html\"><code>&lt;/application&gt;</code></a>   </p>\n<p><a href=\"https://developer.android.com/guide/topics/manifest/manifest-element.html\"><code>&lt;/manifest&gt;</code></a>   </p>\n"},{"title":"Android Developer Guide中的Android概览","subtitle":"Android官方guide随笔 - Introduction","header-img":"/img/header_img/android-note-header.jpg","catalog":true,"date":"2017-07-18T07:51:38.000Z","_content":"\n## 展开点\n\n* Android app、Android进程、Linux UID、Android VM的对应关系。\n* 令不同app使用同一个Linux UID的方法与用处（文中提到了share UID的app需要有相同签名）。\n* Android各个组件状态(background、foreground、service是否被bind)和进程回收优先级的关系。\n* JobScheduler、JobScheduler和Service的关系。\n* [Android compatibility program](https://source.android.com/compatibility/overview)，Android系统对设备的要求。\n* PackageManager的职责。\n* google play filter\n* [Google I/O 2015 - Android M Permissions](https://www.youtube.com/watch?v=f17qe9vZ8RM)。\n* SYSTEM_ALERT_WINDOW和WRITE_SETTINGS这两个属于Special Permissions，不是normal or dangerous permissions。\n* [Android系统的安全模型](https://source.android.com/security/)。\n* 实验自动权限调整，查看自动加入的权限会否在安装时显示，实验自动权限调整是怎么影响dangerous权限的。\n* 自定义权限和签名的关系（相同的签名的App可以自动获取权限？）& `<permission>`标签android:protectionLevel属性的取值，signature。\n* 如何做验证签名，App-to-App，App-to-Server。\n* Context.registerReceiver()时添加权限限制的方法。\n* Context.checkCallingPermission()的用法（在IDL中的使用）。\n* URI Permission的生命周期。\n* URI Permission。\n* 自定义Permission Group的方法与应用场景。\n\n## Caution   \n\n* (出于安全原因)对Service不能使用implicit intent\n* `<user-feature>`标签中的feature IDs，定义在PackageManager的String类型静态常量中；可以调用PackageManager.hasSystemFeature()来查询feature是否可用。\n* 某些`<user-permission>`会隐含`<user-feature>`，例如\"android.permission.BLUETOOTH\"会隐含\"android.hardware.bluetooth\"（PackageManager.FEATURE_BLUETOOTH）。如果需要避免`<user-permission>`去影响google play filter，需要显示声明`<user-feature>`并将require设为false。\n* normal permission的permission group作用不大。\n* 请求dangerous permission时的系统dialog***不能***自定义。\n* Manifest类定义了permission常量(String)和permission group常量(String)。\n* 如果两个不同App需要share UID的话，它们需要使用相同的签名；share UID通过manifest文件中的`<manifest>`标签的sharedUserId属性来定义。\n* App A **签名级别**的自定义权限，App B需要有与A相同的签名才能获得。\n* Android系统不允许不同的App(原文是package)定义相同名称的permisson，除非它们(apps)有相同的签名。如果已经安装一个定义permisson的App，那么再安装另一个定义同名permisson的App(不同签名)会安装失败。\n\n\n## Application Fundamentals\n\n首先介绍Android App和Android系统的关系。\n\n* 一个Apk文件包括了一个Android App的全部内容。\n* 每个Android App在Android Linux上使用独立UID，通过Linux权限系统来实现安全性（私有文件不会被其他app访问）。\n* 每个Android进程运行在单独的Android VM上，每个Android app运行在自己的进程上，Android app所属的进程由Android系统负责。\n\n然后介绍Android App所包含的几类内容。\n\n* app components，即Android组件，定义了App的功能。\n* manifest文件，声明App包含的所有app components；声明App对设备的筛选要求(sdk、软件&硬件功能等)。\n* 资源，把资源和代码分离的重要目的是，便于在不同的系统配置下使用不同的资源。\n\n文章的之后几节分类介绍了Android App的各类内容。\n\n### *app components*   \n“四大组件”。\n\n### *manifest*   \n介绍manifest包含的重点功能。\n\n* 声明App包含的app components，通过`<activity>`、`<service>`、`<receiver>`、`<provider>`标签。\n* 声明每个App component能力（即能执行哪些Action），通过intent-filter。\n* 声明App对设备能力的筛选要求（sdk、软件&硬件功能等）。\n\n### *资源*   \n概述而已。\n\n## Device Compatibility\n\n支持Android操作系统的设备多种多样，App应该支持尽量多的设备；同时也有方法对App可以被安装到的设备进行筛选（借助Google Play）。本章介绍App筛选设备的方式。\n\n### *基于技术原因筛选设备*   \n借助google play，App可以依赖以下条件筛选设备，设备功能(device feature)、系统版本、屏幕规格。\n这些筛选条件声明在manifest文件中。\n\n* 设备功能，在mainfest中通过`<uses-feature>`标签增加对设备功能的筛选条件（例如需要蓝牙、重力感应、系统支持widget等）。\n* 系统版本，在mainfest中通过`<uses-sdk>`标签的minSdkVersion属性和targetSdkVersion属性来筛选系统版本。minSdkVersion表示可安装的最低版本；targetSdkVersion表示App完全适配的最高版本，要求比targetSdkVersion更高版本的系统对App行为进行向前兼容。\n* 屏幕规格，不能通过屏幕规格筛选设备，请进行适配。\n\n### *基于非技术原因筛选设备*   \n在Google Play控制台中，可以对App可安装的设备增加更多的条件，例如地区、年龄等，通常出于商业&产品的顾虑。\n基数技术原因的筛选条件通常声明在Apk文件中（manifest）；基于非技术原因的筛选条件通畅声明在google play控制台。\n\n## System Permissions——Requesting Permissions    \n\n本章介绍如何请求Android系统的标准权限，下一章介绍如何自定义权限。\n\n### *请求权限*   \n\nApp需要请求的权限都需要通过`<uses-permission>`标签在manifest文件中声明（无论normal还是dangerous），其中normal权限会自动获得；dangerous权限则需要用户显示授予。\n\n大多情况下，违反权限规则的接口调用（还未请求权限就使用权限），会抛出异常&打印错误日志。   \n\n### *动态请求权限*   \n\nDangerous权限和动态权限授予的功能是从6.0（23）加入Android系统的，所以Android对动态权限的兼容方式如下：\n\n* App的targetSdkVersion大于等于23***且***系统大于等于6.0时，App需要在运行时请求dangerous权限（请求之后，系统弹出权限授予dialog，用户选择后回调App）；dangerous权限可以随时被剥夺（在 Settings -> Apps 中）。\n*  App的targetSdkVersion小于等于22***且***系统大于等于6.0时，dangerous权限在App安装时请求用户授予，否则不能被安装；dangerous权限可以随时被剥夺（在 Settings -> Apps 中）。\n* 系统小于等于5.1时，dangerous权限在App安装时请求用户授予，否则不能被安装；当系统小于等于5.1时dangerous权限只能在删除App之后被剥夺。\n\n所以即便App的targetSdkVersion小于等于22，也要测试App在没有所需权限时能否适当的运行，因为系统大于等于6.0后用户可以在安装后剥夺dangerous权限。\n\n使用ContextCompat和ActivityCompat中的方法来检查动态权限和请求动态权限。\n\n如果用户在显示授予dialog拒绝授予权限并且勾选“don't show again”，再次请求这个权限会直接被拒绝（不弹出dialog）。\n\n### *自动权限调整*   \n\n当Android系统版本更新之后，可能会加入新的权限种类。当App的targetSdkVersion较小，并且后续Android版本加入新的权限种类时，Android会自动为App加入新的权限声明（就像App在manifest里声明了这些新权限一样）。\n\n自动加入的权限，也会被列在Google Play的权限列表中。   \n\n这种自动权限调整的行为很奇怪对不对，新权限不一定需要对不对，那么及时更新App的targetSdkVersion哦。（呵呵...）\n\n### *查看权限列表*   \nadb shell pm list permissions；Settings -> Apps。\n\n### *permission group*   \n\n对于同组的dangerous权限，如果App已经获得了其中一个，请求组内其他的权限时就无需用户显示授权，**但是在App代码中仍然需要请求这些同组权限**。\n\n## System Permissions——Defining Permissons   \n\n这一章简单介绍自定义权限，主要描述定义权限和要求权限的方式。\n\n### *背景知识*   \n\n自定义权限的背景知识是，Android系统包括UID和签名的安全模型。\n\n### *定义权限*   \n\n通过在mainfest文件中定义`<permission>`标签来定义权限，`<permission>`标签包含了protectionLevel、permissionGroup、label、description等属性。\n\n* protectionLevel是必填字段，定义了权限类型，其值域包括normal、dangerous、signature、signatureOrSystem等。\n* permissionGroup选填，仅在dangerous权限时有意义(大概)。可以通过`<permission-group>`可以自定义permissionGroup，不过大多数情况应该使用系统标准的permissionGroup。\n* label和description用于提供权限的文字描述，按照惯例label为权限名字；description分为两句话，一句描述权限，一句恶意应用获得这个权限能造成的危害。\n\n### *自定义权限的建议*   \n\n* 小心评估是否需要自定义权限。\n* 如果需要设计一组互相协作App，尽量让每个permission在这些App中只被定义一次（如果这些App的签名不同，那么必须只被定义一次）。\n* 如果权限尽在共享签名的App之间使用，则无需自定义权限，尽在跨App请求时进行签名验证。\n* 使用单独的App，不提供任何功能，仅定义权限。\n\n### *要求权限* \n\n在manifest文件中的四大组件标签中声明android:permisson属性，可以要求在访问该组件时所需的权限。\n\n* Activity的权限检查发生在Context.startActivity()和 Activity.startActivityForResult()调用时。无权限会抛出异常。\n* Service的权限检查发生在Context.startService(), Context.stopService()和Context.bindService() 调用时。无权限会抛出异常。\n* BroadcastReceiver 的权限检查发生在 Context.sendBroadcast() 之后，BroadcastReceiver 的权限定义为  是否有权限向 BroadcastReceiver 发送广播。无权限时不会抛出异常，仅仅是广播无效。\n* ContentProvider 的权限分为 android:readPermission 和 android:writePermission ，在请求 ContentProvider 是检查权限。无权限会抛出异常。\n\n### *广播接收权限*   \n\n出了定义是否有权限向 BroadcastReceiver 发送广播，还可以定义 BroadcastReceiver 是否有权限接受广播。在 Context.sendBroadcast() 方法中加入 receiverPermission（String）参数可以定义接收者所需权限。\n\n### *其他要求权限方法*   \n\n Context.checkCallingPermission()、Context.checkPermission(String, int, int)、Context.checkPermission(String, int, int)。\n\n### *URI权限*   \n\n通过URI权限，可以赋予App通向ContentProvider的特定URI的临时权限（尽管App不具有访问 ContentProvider的权限）。\n\n通过Intent.FLAG_GRANT_READ_URI_PERMISSION或 Intent.FLAG_GRANT_WRITE_URI_PERMISSION向activity发Intent（包括返回result），activity将被赋予Intent所包含data URI的 URI权限。Context.grantUriPermission()方法也可以赋予URI权限，但尽量使用Intent来赋予URI权限，因为通过Intent方法赋予的URI权限有自动过期特性。\n\n支持的URI权限的ContentProvider需要在`<provider>`标签中定义grantUriPermissions属性；或在`<provider>`标签先定义`<grant-uri-permissions>`标签。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/android-developers-guide-note-introduction.md","raw":"---\ntitle: Android Developer Guide中的Android概览\nsubtitle: Android官方guide随笔 - Introduction\nheader-img: \"/img/header_img/android-note-header.jpg\"\ncatalog: true\ntags:\n  - Android\ncategories:\n  - 读书笔记\ndate: 2017-07-18 15:51:38\n---\n\n## 展开点\n\n* Android app、Android进程、Linux UID、Android VM的对应关系。\n* 令不同app使用同一个Linux UID的方法与用处（文中提到了share UID的app需要有相同签名）。\n* Android各个组件状态(background、foreground、service是否被bind)和进程回收优先级的关系。\n* JobScheduler、JobScheduler和Service的关系。\n* [Android compatibility program](https://source.android.com/compatibility/overview)，Android系统对设备的要求。\n* PackageManager的职责。\n* google play filter\n* [Google I/O 2015 - Android M Permissions](https://www.youtube.com/watch?v=f17qe9vZ8RM)。\n* SYSTEM_ALERT_WINDOW和WRITE_SETTINGS这两个属于Special Permissions，不是normal or dangerous permissions。\n* [Android系统的安全模型](https://source.android.com/security/)。\n* 实验自动权限调整，查看自动加入的权限会否在安装时显示，实验自动权限调整是怎么影响dangerous权限的。\n* 自定义权限和签名的关系（相同的签名的App可以自动获取权限？）& `<permission>`标签android:protectionLevel属性的取值，signature。\n* 如何做验证签名，App-to-App，App-to-Server。\n* Context.registerReceiver()时添加权限限制的方法。\n* Context.checkCallingPermission()的用法（在IDL中的使用）。\n* URI Permission的生命周期。\n* URI Permission。\n* 自定义Permission Group的方法与应用场景。\n\n## Caution   \n\n* (出于安全原因)对Service不能使用implicit intent\n* `<user-feature>`标签中的feature IDs，定义在PackageManager的String类型静态常量中；可以调用PackageManager.hasSystemFeature()来查询feature是否可用。\n* 某些`<user-permission>`会隐含`<user-feature>`，例如\"android.permission.BLUETOOTH\"会隐含\"android.hardware.bluetooth\"（PackageManager.FEATURE_BLUETOOTH）。如果需要避免`<user-permission>`去影响google play filter，需要显示声明`<user-feature>`并将require设为false。\n* normal permission的permission group作用不大。\n* 请求dangerous permission时的系统dialog***不能***自定义。\n* Manifest类定义了permission常量(String)和permission group常量(String)。\n* 如果两个不同App需要share UID的话，它们需要使用相同的签名；share UID通过manifest文件中的`<manifest>`标签的sharedUserId属性来定义。\n* App A **签名级别**的自定义权限，App B需要有与A相同的签名才能获得。\n* Android系统不允许不同的App(原文是package)定义相同名称的permisson，除非它们(apps)有相同的签名。如果已经安装一个定义permisson的App，那么再安装另一个定义同名permisson的App(不同签名)会安装失败。\n\n\n## Application Fundamentals\n\n首先介绍Android App和Android系统的关系。\n\n* 一个Apk文件包括了一个Android App的全部内容。\n* 每个Android App在Android Linux上使用独立UID，通过Linux权限系统来实现安全性（私有文件不会被其他app访问）。\n* 每个Android进程运行在单独的Android VM上，每个Android app运行在自己的进程上，Android app所属的进程由Android系统负责。\n\n然后介绍Android App所包含的几类内容。\n\n* app components，即Android组件，定义了App的功能。\n* manifest文件，声明App包含的所有app components；声明App对设备的筛选要求(sdk、软件&硬件功能等)。\n* 资源，把资源和代码分离的重要目的是，便于在不同的系统配置下使用不同的资源。\n\n文章的之后几节分类介绍了Android App的各类内容。\n\n### *app components*   \n“四大组件”。\n\n### *manifest*   \n介绍manifest包含的重点功能。\n\n* 声明App包含的app components，通过`<activity>`、`<service>`、`<receiver>`、`<provider>`标签。\n* 声明每个App component能力（即能执行哪些Action），通过intent-filter。\n* 声明App对设备能力的筛选要求（sdk、软件&硬件功能等）。\n\n### *资源*   \n概述而已。\n\n## Device Compatibility\n\n支持Android操作系统的设备多种多样，App应该支持尽量多的设备；同时也有方法对App可以被安装到的设备进行筛选（借助Google Play）。本章介绍App筛选设备的方式。\n\n### *基于技术原因筛选设备*   \n借助google play，App可以依赖以下条件筛选设备，设备功能(device feature)、系统版本、屏幕规格。\n这些筛选条件声明在manifest文件中。\n\n* 设备功能，在mainfest中通过`<uses-feature>`标签增加对设备功能的筛选条件（例如需要蓝牙、重力感应、系统支持widget等）。\n* 系统版本，在mainfest中通过`<uses-sdk>`标签的minSdkVersion属性和targetSdkVersion属性来筛选系统版本。minSdkVersion表示可安装的最低版本；targetSdkVersion表示App完全适配的最高版本，要求比targetSdkVersion更高版本的系统对App行为进行向前兼容。\n* 屏幕规格，不能通过屏幕规格筛选设备，请进行适配。\n\n### *基于非技术原因筛选设备*   \n在Google Play控制台中，可以对App可安装的设备增加更多的条件，例如地区、年龄等，通常出于商业&产品的顾虑。\n基数技术原因的筛选条件通常声明在Apk文件中（manifest）；基于非技术原因的筛选条件通畅声明在google play控制台。\n\n## System Permissions——Requesting Permissions    \n\n本章介绍如何请求Android系统的标准权限，下一章介绍如何自定义权限。\n\n### *请求权限*   \n\nApp需要请求的权限都需要通过`<uses-permission>`标签在manifest文件中声明（无论normal还是dangerous），其中normal权限会自动获得；dangerous权限则需要用户显示授予。\n\n大多情况下，违反权限规则的接口调用（还未请求权限就使用权限），会抛出异常&打印错误日志。   \n\n### *动态请求权限*   \n\nDangerous权限和动态权限授予的功能是从6.0（23）加入Android系统的，所以Android对动态权限的兼容方式如下：\n\n* App的targetSdkVersion大于等于23***且***系统大于等于6.0时，App需要在运行时请求dangerous权限（请求之后，系统弹出权限授予dialog，用户选择后回调App）；dangerous权限可以随时被剥夺（在 Settings -> Apps 中）。\n*  App的targetSdkVersion小于等于22***且***系统大于等于6.0时，dangerous权限在App安装时请求用户授予，否则不能被安装；dangerous权限可以随时被剥夺（在 Settings -> Apps 中）。\n* 系统小于等于5.1时，dangerous权限在App安装时请求用户授予，否则不能被安装；当系统小于等于5.1时dangerous权限只能在删除App之后被剥夺。\n\n所以即便App的targetSdkVersion小于等于22，也要测试App在没有所需权限时能否适当的运行，因为系统大于等于6.0后用户可以在安装后剥夺dangerous权限。\n\n使用ContextCompat和ActivityCompat中的方法来检查动态权限和请求动态权限。\n\n如果用户在显示授予dialog拒绝授予权限并且勾选“don't show again”，再次请求这个权限会直接被拒绝（不弹出dialog）。\n\n### *自动权限调整*   \n\n当Android系统版本更新之后，可能会加入新的权限种类。当App的targetSdkVersion较小，并且后续Android版本加入新的权限种类时，Android会自动为App加入新的权限声明（就像App在manifest里声明了这些新权限一样）。\n\n自动加入的权限，也会被列在Google Play的权限列表中。   \n\n这种自动权限调整的行为很奇怪对不对，新权限不一定需要对不对，那么及时更新App的targetSdkVersion哦。（呵呵...）\n\n### *查看权限列表*   \nadb shell pm list permissions；Settings -> Apps。\n\n### *permission group*   \n\n对于同组的dangerous权限，如果App已经获得了其中一个，请求组内其他的权限时就无需用户显示授权，**但是在App代码中仍然需要请求这些同组权限**。\n\n## System Permissions——Defining Permissons   \n\n这一章简单介绍自定义权限，主要描述定义权限和要求权限的方式。\n\n### *背景知识*   \n\n自定义权限的背景知识是，Android系统包括UID和签名的安全模型。\n\n### *定义权限*   \n\n通过在mainfest文件中定义`<permission>`标签来定义权限，`<permission>`标签包含了protectionLevel、permissionGroup、label、description等属性。\n\n* protectionLevel是必填字段，定义了权限类型，其值域包括normal、dangerous、signature、signatureOrSystem等。\n* permissionGroup选填，仅在dangerous权限时有意义(大概)。可以通过`<permission-group>`可以自定义permissionGroup，不过大多数情况应该使用系统标准的permissionGroup。\n* label和description用于提供权限的文字描述，按照惯例label为权限名字；description分为两句话，一句描述权限，一句恶意应用获得这个权限能造成的危害。\n\n### *自定义权限的建议*   \n\n* 小心评估是否需要自定义权限。\n* 如果需要设计一组互相协作App，尽量让每个permission在这些App中只被定义一次（如果这些App的签名不同，那么必须只被定义一次）。\n* 如果权限尽在共享签名的App之间使用，则无需自定义权限，尽在跨App请求时进行签名验证。\n* 使用单独的App，不提供任何功能，仅定义权限。\n\n### *要求权限* \n\n在manifest文件中的四大组件标签中声明android:permisson属性，可以要求在访问该组件时所需的权限。\n\n* Activity的权限检查发生在Context.startActivity()和 Activity.startActivityForResult()调用时。无权限会抛出异常。\n* Service的权限检查发生在Context.startService(), Context.stopService()和Context.bindService() 调用时。无权限会抛出异常。\n* BroadcastReceiver 的权限检查发生在 Context.sendBroadcast() 之后，BroadcastReceiver 的权限定义为  是否有权限向 BroadcastReceiver 发送广播。无权限时不会抛出异常，仅仅是广播无效。\n* ContentProvider 的权限分为 android:readPermission 和 android:writePermission ，在请求 ContentProvider 是检查权限。无权限会抛出异常。\n\n### *广播接收权限*   \n\n出了定义是否有权限向 BroadcastReceiver 发送广播，还可以定义 BroadcastReceiver 是否有权限接受广播。在 Context.sendBroadcast() 方法中加入 receiverPermission（String）参数可以定义接收者所需权限。\n\n### *其他要求权限方法*   \n\n Context.checkCallingPermission()、Context.checkPermission(String, int, int)、Context.checkPermission(String, int, int)。\n\n### *URI权限*   \n\n通过URI权限，可以赋予App通向ContentProvider的特定URI的临时权限（尽管App不具有访问 ContentProvider的权限）。\n\n通过Intent.FLAG_GRANT_READ_URI_PERMISSION或 Intent.FLAG_GRANT_WRITE_URI_PERMISSION向activity发Intent（包括返回result），activity将被赋予Intent所包含data URI的 URI权限。Context.grantUriPermission()方法也可以赋予URI权限，但尽量使用Intent来赋予URI权限，因为通过Intent方法赋予的URI权限有自动过期特性。\n\n支持的URI权限的ContentProvider需要在`<provider>`标签中定义grantUriPermissions属性；或在`<provider>`标签先定义`<grant-uri-permissions>`标签。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"android-developers-guide-note-introduction","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p4000s3mrffzfv5pzw","content":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>Android app、Android进程、Linux UID、Android VM的对应关系。</li>\n<li>令不同app使用同一个Linux UID的方法与用处（文中提到了share UID的app需要有相同签名）。</li>\n<li>Android各个组件状态(background、foreground、service是否被bind)和进程回收优先级的关系。</li>\n<li>JobScheduler、JobScheduler和Service的关系。</li>\n<li><a href=\"https://source.android.com/compatibility/overview\">Android compatibility program</a>，Android系统对设备的要求。</li>\n<li>PackageManager的职责。</li>\n<li>google play filter</li>\n<li><a href=\"https://www.youtube.com/watch?v=f17qe9vZ8RM\">Google I/O 2015 - Android M Permissions</a>。</li>\n<li>SYSTEM_ALERT_WINDOW和WRITE_SETTINGS这两个属于Special Permissions，不是normal or dangerous permissions。</li>\n<li><a href=\"https://source.android.com/security/\">Android系统的安全模型</a>。</li>\n<li>实验自动权限调整，查看自动加入的权限会否在安装时显示，实验自动权限调整是怎么影响dangerous权限的。</li>\n<li>自定义权限和签名的关系（相同的签名的App可以自动获取权限？）&amp; <code>&lt;permission&gt;</code>标签android:protectionLevel属性的取值，signature。</li>\n<li>如何做验证签名，App-to-App，App-to-Server。</li>\n<li>Context.registerReceiver()时添加权限限制的方法。</li>\n<li>Context.checkCallingPermission()的用法（在IDL中的使用）。</li>\n<li>URI Permission的生命周期。</li>\n<li>URI Permission。</li>\n<li>自定义Permission Group的方法与应用场景。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>(出于安全原因)对Service不能使用implicit intent</li>\n<li><code>&lt;user-feature&gt;</code>标签中的feature IDs，定义在PackageManager的String类型静态常量中；可以调用PackageManager.hasSystemFeature()来查询feature是否可用。</li>\n<li>某些<code>&lt;user-permission&gt;</code>会隐含<code>&lt;user-feature&gt;</code>，例如”android.permission.BLUETOOTH”会隐含”android.hardware.bluetooth”（PackageManager.FEATURE_BLUETOOTH）。如果需要避免<code>&lt;user-permission&gt;</code>去影响google play filter，需要显示声明<code>&lt;user-feature&gt;</code>并将require设为false。</li>\n<li>normal permission的permission group作用不大。</li>\n<li>请求dangerous permission时的系统dialog<strong><em>不能</em></strong>自定义。</li>\n<li>Manifest类定义了permission常量(String)和permission group常量(String)。</li>\n<li>如果两个不同App需要share UID的话，它们需要使用相同的签名；share UID通过manifest文件中的<code>&lt;manifest&gt;</code>标签的sharedUserId属性来定义。</li>\n<li>App A <strong>签名级别</strong>的自定义权限，App B需要有与A相同的签名才能获得。</li>\n<li>Android系统不允许不同的App(原文是package)定义相同名称的permisson，除非它们(apps)有相同的签名。如果已经安装一个定义permisson的App，那么再安装另一个定义同名permisson的App(不同签名)会安装失败。</li>\n</ul>\n<h2 id=\"Application-Fundamentals\"><a href=\"#Application-Fundamentals\" class=\"headerlink\" title=\"Application Fundamentals\"></a>Application Fundamentals</h2><p>首先介绍Android App和Android系统的关系。</p>\n<ul>\n<li>一个Apk文件包括了一个Android App的全部内容。</li>\n<li>每个Android App在Android Linux上使用独立UID，通过Linux权限系统来实现安全性（私有文件不会被其他app访问）。</li>\n<li>每个Android进程运行在单独的Android VM上，每个Android app运行在自己的进程上，Android app所属的进程由Android系统负责。</li>\n</ul>\n<p>然后介绍Android App所包含的几类内容。</p>\n<ul>\n<li>app components，即Android组件，定义了App的功能。</li>\n<li>manifest文件，声明App包含的所有app components；声明App对设备的筛选要求(sdk、软件&amp;硬件功能等)。</li>\n<li>资源，把资源和代码分离的重要目的是，便于在不同的系统配置下使用不同的资源。</li>\n</ul>\n<p>文章的之后几节分类介绍了Android App的各类内容。</p>\n<h3 id=\"app-components\"><a href=\"#app-components\" class=\"headerlink\" title=\"app components\"></a><em>app components</em></h3><p>“四大组件”。</p>\n<h3 id=\"manifest\"><a href=\"#manifest\" class=\"headerlink\" title=\"manifest\"></a><em>manifest</em></h3><p>介绍manifest包含的重点功能。</p>\n<ul>\n<li>声明App包含的app components，通过<code>&lt;activity&gt;</code>、<code>&lt;service&gt;</code>、<code>&lt;receiver&gt;</code>、<code>&lt;provider&gt;</code>标签。</li>\n<li>声明每个App component能力（即能执行哪些Action），通过intent-filter。</li>\n<li>声明App对设备能力的筛选要求（sdk、软件&amp;硬件功能等）。</li>\n</ul>\n<h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a><em>资源</em></h3><p>概述而已。</p>\n<h2 id=\"Device-Compatibility\"><a href=\"#Device-Compatibility\" class=\"headerlink\" title=\"Device Compatibility\"></a>Device Compatibility</h2><p>支持Android操作系统的设备多种多样，App应该支持尽量多的设备；同时也有方法对App可以被安装到的设备进行筛选（借助Google Play）。本章介绍App筛选设备的方式。</p>\n<h3 id=\"基于技术原因筛选设备\"><a href=\"#基于技术原因筛选设备\" class=\"headerlink\" title=\"基于技术原因筛选设备\"></a><em>基于技术原因筛选设备</em></h3><p>借助google play，App可以依赖以下条件筛选设备，设备功能(device feature)、系统版本、屏幕规格。<br>这些筛选条件声明在manifest文件中。</p>\n<ul>\n<li>设备功能，在mainfest中通过<code>&lt;uses-feature&gt;</code>标签增加对设备功能的筛选条件（例如需要蓝牙、重力感应、系统支持widget等）。</li>\n<li>系统版本，在mainfest中通过<code>&lt;uses-sdk&gt;</code>标签的minSdkVersion属性和targetSdkVersion属性来筛选系统版本。minSdkVersion表示可安装的最低版本；targetSdkVersion表示App完全适配的最高版本，要求比targetSdkVersion更高版本的系统对App行为进行向前兼容。</li>\n<li>屏幕规格，不能通过屏幕规格筛选设备，请进行适配。</li>\n</ul>\n<h3 id=\"基于非技术原因筛选设备\"><a href=\"#基于非技术原因筛选设备\" class=\"headerlink\" title=\"基于非技术原因筛选设备\"></a><em>基于非技术原因筛选设备</em></h3><p>在Google Play控制台中，可以对App可安装的设备增加更多的条件，例如地区、年龄等，通常出于商业&amp;产品的顾虑。<br>基数技术原因的筛选条件通常声明在Apk文件中（manifest）；基于非技术原因的筛选条件通畅声明在google play控制台。</p>\n<h2 id=\"System-Permissions——Requesting-Permissions\"><a href=\"#System-Permissions——Requesting-Permissions\" class=\"headerlink\" title=\"System Permissions——Requesting Permissions\"></a>System Permissions——Requesting Permissions</h2><p>本章介绍如何请求Android系统的标准权限，下一章介绍如何自定义权限。</p>\n<h3 id=\"请求权限\"><a href=\"#请求权限\" class=\"headerlink\" title=\"请求权限\"></a><em>请求权限</em></h3><p>App需要请求的权限都需要通过<code>&lt;uses-permission&gt;</code>标签在manifest文件中声明（无论normal还是dangerous），其中normal权限会自动获得；dangerous权限则需要用户显示授予。</p>\n<p>大多情况下，违反权限规则的接口调用（还未请求权限就使用权限），会抛出异常&amp;打印错误日志。   </p>\n<h3 id=\"动态请求权限\"><a href=\"#动态请求权限\" class=\"headerlink\" title=\"动态请求权限\"></a><em>动态请求权限</em></h3><p>Dangerous权限和动态权限授予的功能是从6.0（23）加入Android系统的，所以Android对动态权限的兼容方式如下：</p>\n<ul>\n<li>App的targetSdkVersion大于等于23<strong><em>且</em></strong>系统大于等于6.0时，App需要在运行时请求dangerous权限（请求之后，系统弹出权限授予dialog，用户选择后回调App）；dangerous权限可以随时被剥夺（在 Settings -&gt; Apps 中）。</li>\n<li>App的targetSdkVersion小于等于22<strong><em>且</em></strong>系统大于等于6.0时，dangerous权限在App安装时请求用户授予，否则不能被安装；dangerous权限可以随时被剥夺（在 Settings -&gt; Apps 中）。</li>\n<li>系统小于等于5.1时，dangerous权限在App安装时请求用户授予，否则不能被安装；当系统小于等于5.1时dangerous权限只能在删除App之后被剥夺。</li>\n</ul>\n<p>所以即便App的targetSdkVersion小于等于22，也要测试App在没有所需权限时能否适当的运行，因为系统大于等于6.0后用户可以在安装后剥夺dangerous权限。</p>\n<p>使用ContextCompat和ActivityCompat中的方法来检查动态权限和请求动态权限。</p>\n<p>如果用户在显示授予dialog拒绝授予权限并且勾选“don’t show again”，再次请求这个权限会直接被拒绝（不弹出dialog）。</p>\n<h3 id=\"自动权限调整\"><a href=\"#自动权限调整\" class=\"headerlink\" title=\"自动权限调整\"></a><em>自动权限调整</em></h3><p>当Android系统版本更新之后，可能会加入新的权限种类。当App的targetSdkVersion较小，并且后续Android版本加入新的权限种类时，Android会自动为App加入新的权限声明（就像App在manifest里声明了这些新权限一样）。</p>\n<p>自动加入的权限，也会被列在Google Play的权限列表中。   </p>\n<p>这种自动权限调整的行为很奇怪对不对，新权限不一定需要对不对，那么及时更新App的targetSdkVersion哦。（呵呵…）</p>\n<h3 id=\"查看权限列表\"><a href=\"#查看权限列表\" class=\"headerlink\" title=\"查看权限列表\"></a><em>查看权限列表</em></h3><p>adb shell pm list permissions；Settings -&gt; Apps。</p>\n<h3 id=\"permission-group\"><a href=\"#permission-group\" class=\"headerlink\" title=\"permission group\"></a><em>permission group</em></h3><p>对于同组的dangerous权限，如果App已经获得了其中一个，请求组内其他的权限时就无需用户显示授权，<strong>但是在App代码中仍然需要请求这些同组权限</strong>。</p>\n<h2 id=\"System-Permissions——Defining-Permissons\"><a href=\"#System-Permissions——Defining-Permissons\" class=\"headerlink\" title=\"System Permissions——Defining Permissons\"></a>System Permissions——Defining Permissons</h2><p>这一章简单介绍自定义权限，主要描述定义权限和要求权限的方式。</p>\n<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a><em>背景知识</em></h3><p>自定义权限的背景知识是，Android系统包括UID和签名的安全模型。</p>\n<h3 id=\"定义权限\"><a href=\"#定义权限\" class=\"headerlink\" title=\"定义权限\"></a><em>定义权限</em></h3><p>通过在mainfest文件中定义<code>&lt;permission&gt;</code>标签来定义权限，<code>&lt;permission&gt;</code>标签包含了protectionLevel、permissionGroup、label、description等属性。</p>\n<ul>\n<li>protectionLevel是必填字段，定义了权限类型，其值域包括normal、dangerous、signature、signatureOrSystem等。</li>\n<li>permissionGroup选填，仅在dangerous权限时有意义(大概)。可以通过<code>&lt;permission-group&gt;</code>可以自定义permissionGroup，不过大多数情况应该使用系统标准的permissionGroup。</li>\n<li>label和description用于提供权限的文字描述，按照惯例label为权限名字；description分为两句话，一句描述权限，一句恶意应用获得这个权限能造成的危害。</li>\n</ul>\n<h3 id=\"自定义权限的建议\"><a href=\"#自定义权限的建议\" class=\"headerlink\" title=\"自定义权限的建议\"></a><em>自定义权限的建议</em></h3><ul>\n<li>小心评估是否需要自定义权限。</li>\n<li>如果需要设计一组互相协作App，尽量让每个permission在这些App中只被定义一次（如果这些App的签名不同，那么必须只被定义一次）。</li>\n<li>如果权限尽在共享签名的App之间使用，则无需自定义权限，尽在跨App请求时进行签名验证。</li>\n<li>使用单独的App，不提供任何功能，仅定义权限。</li>\n</ul>\n<h3 id=\"要求权限\"><a href=\"#要求权限\" class=\"headerlink\" title=\"要求权限\"></a><em>要求权限</em></h3><p>在manifest文件中的四大组件标签中声明android:permisson属性，可以要求在访问该组件时所需的权限。</p>\n<ul>\n<li>Activity的权限检查发生在Context.startActivity()和 Activity.startActivityForResult()调用时。无权限会抛出异常。</li>\n<li>Service的权限检查发生在Context.startService(), Context.stopService()和Context.bindService() 调用时。无权限会抛出异常。</li>\n<li>BroadcastReceiver 的权限检查发生在 Context.sendBroadcast() 之后，BroadcastReceiver 的权限定义为  是否有权限向 BroadcastReceiver 发送广播。无权限时不会抛出异常，仅仅是广播无效。</li>\n<li>ContentProvider 的权限分为 android:readPermission 和 android:writePermission ，在请求 ContentProvider 是检查权限。无权限会抛出异常。</li>\n</ul>\n<h3 id=\"广播接收权限\"><a href=\"#广播接收权限\" class=\"headerlink\" title=\"广播接收权限\"></a><em>广播接收权限</em></h3><p>出了定义是否有权限向 BroadcastReceiver 发送广播，还可以定义 BroadcastReceiver 是否有权限接受广播。在 Context.sendBroadcast() 方法中加入 receiverPermission（String）参数可以定义接收者所需权限。</p>\n<h3 id=\"其他要求权限方法\"><a href=\"#其他要求权限方法\" class=\"headerlink\" title=\"其他要求权限方法\"></a><em>其他要求权限方法</em></h3><p> Context.checkCallingPermission()、Context.checkPermission(String, int, int)、Context.checkPermission(String, int, int)。</p>\n<h3 id=\"URI权限\"><a href=\"#URI权限\" class=\"headerlink\" title=\"URI权限\"></a><em>URI权限</em></h3><p>通过URI权限，可以赋予App通向ContentProvider的特定URI的临时权限（尽管App不具有访问 ContentProvider的权限）。</p>\n<p>通过Intent.FLAG_GRANT_READ_URI_PERMISSION或 Intent.FLAG_GRANT_WRITE_URI_PERMISSION向activity发Intent（包括返回result），activity将被赋予Intent所包含data URI的 URI权限。Context.grantUriPermission()方法也可以赋予URI权限，但尽量使用Intent来赋予URI权限，因为通过Intent方法赋予的URI权限有自动过期特性。</p>\n<p>支持的URI权限的ContentProvider需要在<code>&lt;provider&gt;</code>标签中定义grantUriPermissions属性；或在<code>&lt;provider&gt;</code>标签先定义<code>&lt;grant-uri-permissions&gt;</code>标签。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"展开点\"><a href=\"#展开点\" class=\"headerlink\" title=\"展开点\"></a>展开点</h2><ul>\n<li>Android app、Android进程、Linux UID、Android VM的对应关系。</li>\n<li>令不同app使用同一个Linux UID的方法与用处（文中提到了share UID的app需要有相同签名）。</li>\n<li>Android各个组件状态(background、foreground、service是否被bind)和进程回收优先级的关系。</li>\n<li>JobScheduler、JobScheduler和Service的关系。</li>\n<li><a href=\"https://source.android.com/compatibility/overview\">Android compatibility program</a>，Android系统对设备的要求。</li>\n<li>PackageManager的职责。</li>\n<li>google play filter</li>\n<li><a href=\"https://www.youtube.com/watch?v=f17qe9vZ8RM\">Google I/O 2015 - Android M Permissions</a>。</li>\n<li>SYSTEM_ALERT_WINDOW和WRITE_SETTINGS这两个属于Special Permissions，不是normal or dangerous permissions。</li>\n<li><a href=\"https://source.android.com/security/\">Android系统的安全模型</a>。</li>\n<li>实验自动权限调整，查看自动加入的权限会否在安装时显示，实验自动权限调整是怎么影响dangerous权限的。</li>\n<li>自定义权限和签名的关系（相同的签名的App可以自动获取权限？）&amp; <code>&lt;permission&gt;</code>标签android:protectionLevel属性的取值，signature。</li>\n<li>如何做验证签名，App-to-App，App-to-Server。</li>\n<li>Context.registerReceiver()时添加权限限制的方法。</li>\n<li>Context.checkCallingPermission()的用法（在IDL中的使用）。</li>\n<li>URI Permission的生命周期。</li>\n<li>URI Permission。</li>\n<li>自定义Permission Group的方法与应用场景。</li>\n</ul>\n<h2 id=\"Caution\"><a href=\"#Caution\" class=\"headerlink\" title=\"Caution\"></a>Caution</h2><ul>\n<li>(出于安全原因)对Service不能使用implicit intent</li>\n<li><code>&lt;user-feature&gt;</code>标签中的feature IDs，定义在PackageManager的String类型静态常量中；可以调用PackageManager.hasSystemFeature()来查询feature是否可用。</li>\n<li>某些<code>&lt;user-permission&gt;</code>会隐含<code>&lt;user-feature&gt;</code>，例如”android.permission.BLUETOOTH”会隐含”android.hardware.bluetooth”（PackageManager.FEATURE_BLUETOOTH）。如果需要避免<code>&lt;user-permission&gt;</code>去影响google play filter，需要显示声明<code>&lt;user-feature&gt;</code>并将require设为false。</li>\n<li>normal permission的permission group作用不大。</li>\n<li>请求dangerous permission时的系统dialog<strong><em>不能</em></strong>自定义。</li>\n<li>Manifest类定义了permission常量(String)和permission group常量(String)。</li>\n<li>如果两个不同App需要share UID的话，它们需要使用相同的签名；share UID通过manifest文件中的<code>&lt;manifest&gt;</code>标签的sharedUserId属性来定义。</li>\n<li>App A <strong>签名级别</strong>的自定义权限，App B需要有与A相同的签名才能获得。</li>\n<li>Android系统不允许不同的App(原文是package)定义相同名称的permisson，除非它们(apps)有相同的签名。如果已经安装一个定义permisson的App，那么再安装另一个定义同名permisson的App(不同签名)会安装失败。</li>\n</ul>\n<h2 id=\"Application-Fundamentals\"><a href=\"#Application-Fundamentals\" class=\"headerlink\" title=\"Application Fundamentals\"></a>Application Fundamentals</h2><p>首先介绍Android App和Android系统的关系。</p>\n<ul>\n<li>一个Apk文件包括了一个Android App的全部内容。</li>\n<li>每个Android App在Android Linux上使用独立UID，通过Linux权限系统来实现安全性（私有文件不会被其他app访问）。</li>\n<li>每个Android进程运行在单独的Android VM上，每个Android app运行在自己的进程上，Android app所属的进程由Android系统负责。</li>\n</ul>\n<p>然后介绍Android App所包含的几类内容。</p>\n<ul>\n<li>app components，即Android组件，定义了App的功能。</li>\n<li>manifest文件，声明App包含的所有app components；声明App对设备的筛选要求(sdk、软件&amp;硬件功能等)。</li>\n<li>资源，把资源和代码分离的重要目的是，便于在不同的系统配置下使用不同的资源。</li>\n</ul>\n<p>文章的之后几节分类介绍了Android App的各类内容。</p>\n<h3 id=\"app-components\"><a href=\"#app-components\" class=\"headerlink\" title=\"app components\"></a><em>app components</em></h3><p>“四大组件”。</p>\n<h3 id=\"manifest\"><a href=\"#manifest\" class=\"headerlink\" title=\"manifest\"></a><em>manifest</em></h3><p>介绍manifest包含的重点功能。</p>\n<ul>\n<li>声明App包含的app components，通过<code>&lt;activity&gt;</code>、<code>&lt;service&gt;</code>、<code>&lt;receiver&gt;</code>、<code>&lt;provider&gt;</code>标签。</li>\n<li>声明每个App component能力（即能执行哪些Action），通过intent-filter。</li>\n<li>声明App对设备能力的筛选要求（sdk、软件&amp;硬件功能等）。</li>\n</ul>\n<h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a><em>资源</em></h3><p>概述而已。</p>\n<h2 id=\"Device-Compatibility\"><a href=\"#Device-Compatibility\" class=\"headerlink\" title=\"Device Compatibility\"></a>Device Compatibility</h2><p>支持Android操作系统的设备多种多样，App应该支持尽量多的设备；同时也有方法对App可以被安装到的设备进行筛选（借助Google Play）。本章介绍App筛选设备的方式。</p>\n<h3 id=\"基于技术原因筛选设备\"><a href=\"#基于技术原因筛选设备\" class=\"headerlink\" title=\"基于技术原因筛选设备\"></a><em>基于技术原因筛选设备</em></h3><p>借助google play，App可以依赖以下条件筛选设备，设备功能(device feature)、系统版本、屏幕规格。<br>这些筛选条件声明在manifest文件中。</p>\n<ul>\n<li>设备功能，在mainfest中通过<code>&lt;uses-feature&gt;</code>标签增加对设备功能的筛选条件（例如需要蓝牙、重力感应、系统支持widget等）。</li>\n<li>系统版本，在mainfest中通过<code>&lt;uses-sdk&gt;</code>标签的minSdkVersion属性和targetSdkVersion属性来筛选系统版本。minSdkVersion表示可安装的最低版本；targetSdkVersion表示App完全适配的最高版本，要求比targetSdkVersion更高版本的系统对App行为进行向前兼容。</li>\n<li>屏幕规格，不能通过屏幕规格筛选设备，请进行适配。</li>\n</ul>\n<h3 id=\"基于非技术原因筛选设备\"><a href=\"#基于非技术原因筛选设备\" class=\"headerlink\" title=\"基于非技术原因筛选设备\"></a><em>基于非技术原因筛选设备</em></h3><p>在Google Play控制台中，可以对App可安装的设备增加更多的条件，例如地区、年龄等，通常出于商业&amp;产品的顾虑。<br>基数技术原因的筛选条件通常声明在Apk文件中（manifest）；基于非技术原因的筛选条件通畅声明在google play控制台。</p>\n<h2 id=\"System-Permissions——Requesting-Permissions\"><a href=\"#System-Permissions——Requesting-Permissions\" class=\"headerlink\" title=\"System Permissions——Requesting Permissions\"></a>System Permissions——Requesting Permissions</h2><p>本章介绍如何请求Android系统的标准权限，下一章介绍如何自定义权限。</p>\n<h3 id=\"请求权限\"><a href=\"#请求权限\" class=\"headerlink\" title=\"请求权限\"></a><em>请求权限</em></h3><p>App需要请求的权限都需要通过<code>&lt;uses-permission&gt;</code>标签在manifest文件中声明（无论normal还是dangerous），其中normal权限会自动获得；dangerous权限则需要用户显示授予。</p>\n<p>大多情况下，违反权限规则的接口调用（还未请求权限就使用权限），会抛出异常&amp;打印错误日志。   </p>\n<h3 id=\"动态请求权限\"><a href=\"#动态请求权限\" class=\"headerlink\" title=\"动态请求权限\"></a><em>动态请求权限</em></h3><p>Dangerous权限和动态权限授予的功能是从6.0（23）加入Android系统的，所以Android对动态权限的兼容方式如下：</p>\n<ul>\n<li>App的targetSdkVersion大于等于23<strong><em>且</em></strong>系统大于等于6.0时，App需要在运行时请求dangerous权限（请求之后，系统弹出权限授予dialog，用户选择后回调App）；dangerous权限可以随时被剥夺（在 Settings -&gt; Apps 中）。</li>\n<li>App的targetSdkVersion小于等于22<strong><em>且</em></strong>系统大于等于6.0时，dangerous权限在App安装时请求用户授予，否则不能被安装；dangerous权限可以随时被剥夺（在 Settings -&gt; Apps 中）。</li>\n<li>系统小于等于5.1时，dangerous权限在App安装时请求用户授予，否则不能被安装；当系统小于等于5.1时dangerous权限只能在删除App之后被剥夺。</li>\n</ul>\n<p>所以即便App的targetSdkVersion小于等于22，也要测试App在没有所需权限时能否适当的运行，因为系统大于等于6.0后用户可以在安装后剥夺dangerous权限。</p>\n<p>使用ContextCompat和ActivityCompat中的方法来检查动态权限和请求动态权限。</p>\n<p>如果用户在显示授予dialog拒绝授予权限并且勾选“don’t show again”，再次请求这个权限会直接被拒绝（不弹出dialog）。</p>\n<h3 id=\"自动权限调整\"><a href=\"#自动权限调整\" class=\"headerlink\" title=\"自动权限调整\"></a><em>自动权限调整</em></h3><p>当Android系统版本更新之后，可能会加入新的权限种类。当App的targetSdkVersion较小，并且后续Android版本加入新的权限种类时，Android会自动为App加入新的权限声明（就像App在manifest里声明了这些新权限一样）。</p>\n<p>自动加入的权限，也会被列在Google Play的权限列表中。   </p>\n<p>这种自动权限调整的行为很奇怪对不对，新权限不一定需要对不对，那么及时更新App的targetSdkVersion哦。（呵呵…）</p>\n<h3 id=\"查看权限列表\"><a href=\"#查看权限列表\" class=\"headerlink\" title=\"查看权限列表\"></a><em>查看权限列表</em></h3><p>adb shell pm list permissions；Settings -&gt; Apps。</p>\n<h3 id=\"permission-group\"><a href=\"#permission-group\" class=\"headerlink\" title=\"permission group\"></a><em>permission group</em></h3><p>对于同组的dangerous权限，如果App已经获得了其中一个，请求组内其他的权限时就无需用户显示授权，<strong>但是在App代码中仍然需要请求这些同组权限</strong>。</p>\n<h2 id=\"System-Permissions——Defining-Permissons\"><a href=\"#System-Permissions——Defining-Permissons\" class=\"headerlink\" title=\"System Permissions——Defining Permissons\"></a>System Permissions——Defining Permissons</h2><p>这一章简单介绍自定义权限，主要描述定义权限和要求权限的方式。</p>\n<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a><em>背景知识</em></h3><p>自定义权限的背景知识是，Android系统包括UID和签名的安全模型。</p>\n<h3 id=\"定义权限\"><a href=\"#定义权限\" class=\"headerlink\" title=\"定义权限\"></a><em>定义权限</em></h3><p>通过在mainfest文件中定义<code>&lt;permission&gt;</code>标签来定义权限，<code>&lt;permission&gt;</code>标签包含了protectionLevel、permissionGroup、label、description等属性。</p>\n<ul>\n<li>protectionLevel是必填字段，定义了权限类型，其值域包括normal、dangerous、signature、signatureOrSystem等。</li>\n<li>permissionGroup选填，仅在dangerous权限时有意义(大概)。可以通过<code>&lt;permission-group&gt;</code>可以自定义permissionGroup，不过大多数情况应该使用系统标准的permissionGroup。</li>\n<li>label和description用于提供权限的文字描述，按照惯例label为权限名字；description分为两句话，一句描述权限，一句恶意应用获得这个权限能造成的危害。</li>\n</ul>\n<h3 id=\"自定义权限的建议\"><a href=\"#自定义权限的建议\" class=\"headerlink\" title=\"自定义权限的建议\"></a><em>自定义权限的建议</em></h3><ul>\n<li>小心评估是否需要自定义权限。</li>\n<li>如果需要设计一组互相协作App，尽量让每个permission在这些App中只被定义一次（如果这些App的签名不同，那么必须只被定义一次）。</li>\n<li>如果权限尽在共享签名的App之间使用，则无需自定义权限，尽在跨App请求时进行签名验证。</li>\n<li>使用单独的App，不提供任何功能，仅定义权限。</li>\n</ul>\n<h3 id=\"要求权限\"><a href=\"#要求权限\" class=\"headerlink\" title=\"要求权限\"></a><em>要求权限</em></h3><p>在manifest文件中的四大组件标签中声明android:permisson属性，可以要求在访问该组件时所需的权限。</p>\n<ul>\n<li>Activity的权限检查发生在Context.startActivity()和 Activity.startActivityForResult()调用时。无权限会抛出异常。</li>\n<li>Service的权限检查发生在Context.startService(), Context.stopService()和Context.bindService() 调用时。无权限会抛出异常。</li>\n<li>BroadcastReceiver 的权限检查发生在 Context.sendBroadcast() 之后，BroadcastReceiver 的权限定义为  是否有权限向 BroadcastReceiver 发送广播。无权限时不会抛出异常，仅仅是广播无效。</li>\n<li>ContentProvider 的权限分为 android:readPermission 和 android:writePermission ，在请求 ContentProvider 是检查权限。无权限会抛出异常。</li>\n</ul>\n<h3 id=\"广播接收权限\"><a href=\"#广播接收权限\" class=\"headerlink\" title=\"广播接收权限\"></a><em>广播接收权限</em></h3><p>出了定义是否有权限向 BroadcastReceiver 发送广播，还可以定义 BroadcastReceiver 是否有权限接受广播。在 Context.sendBroadcast() 方法中加入 receiverPermission（String）参数可以定义接收者所需权限。</p>\n<h3 id=\"其他要求权限方法\"><a href=\"#其他要求权限方法\" class=\"headerlink\" title=\"其他要求权限方法\"></a><em>其他要求权限方法</em></h3><p> Context.checkCallingPermission()、Context.checkPermission(String, int, int)、Context.checkPermission(String, int, int)。</p>\n<h3 id=\"URI权限\"><a href=\"#URI权限\" class=\"headerlink\" title=\"URI权限\"></a><em>URI权限</em></h3><p>通过URI权限，可以赋予App通向ContentProvider的特定URI的临时权限（尽管App不具有访问 ContentProvider的权限）。</p>\n<p>通过Intent.FLAG_GRANT_READ_URI_PERMISSION或 Intent.FLAG_GRANT_WRITE_URI_PERMISSION向activity发Intent（包括返回result），activity将被赋予Intent所包含data URI的 URI权限。Context.grantUriPermission()方法也可以赋予URI权限，但尽量使用Intent来赋予URI权限，因为通过Intent方法赋予的URI权限有自动过期特性。</p>\n<p>支持的URI权限的ContentProvider需要在<code>&lt;provider&gt;</code>标签中定义grantUriPermissions属性；或在<code>&lt;provider&gt;</code>标签先定义<code>&lt;grant-uri-permissions&gt;</code>标签。</p>\n"},{"title":"反编译Android厂商的ROM","catalog":true,"date":"2018-05-04T07:28:59.000Z","header-img":"/img/header_img/tips-header.jpg","_content":"\n为了解释某些厂商ROM反直觉的现象，或者绕过厂商ROM埋的坑，有时反编译ROM源码是一条不错的途径。\n\n### 获取Rom包\n\ngoogle 搜索 + 下载；也许需要百度网盘。\n\n### 解压System.img文件\n\n参考[解压 Android 系统中的 system.img](https://www.jianshu.com/p/db70835d41c8)\n\n如果Rom包中不包含system.img文件，而是有system.new.dat、system.patch.dat、system.transfer.list三个文件，需要使用[sdat2img工具](https://github.com/xpirt/sdat2img)生成system.img。\n\n使用file命令确定system.img文件的文件类型，如果是“Linux rev 1.0 ext4 filesystem data”文件可以使用[ext4fuse工具](https://github.com/gerard/ext4fuse)在MacOS上挂载。\n\n成功挂载之后就可以读取system.img中的文件了。\n\n### 在System.img中寻找代码文件\n\n不同rom的system.img中的文件布局各异，以vivo X9S为例，代码文件通常是在/framework目录下的.odex文件或.oat文件。\n\n### 反编译.odex或.oat文件成.jar文件\n\n.odex&.oat -> .smali -> .dex ：使用[smail工具](https://bitbucket.org/JesusFreke/smali/overview)，baksmali.jar可以将.odex&.oat转成.smali，smali.jar可以将.smali转成.dex。\n.dex -> .jar：dex2jar工具。\n\n有了.jar文件之后就可以开心的看厂商ROM都留了哪些坑了。\n\n\n","source":"_posts/tips-decompile-android-rom.md","raw":"---\ntitle: 反编译Android厂商的ROM\ncatalog: true\ntags:\n  - Android\ncategories:\n  - 经验\ndate: 2018-05-04 15:28:59\nheader-img: /img/header_img/tips-header.jpg\n---\n\n为了解释某些厂商ROM反直觉的现象，或者绕过厂商ROM埋的坑，有时反编译ROM源码是一条不错的途径。\n\n### 获取Rom包\n\ngoogle 搜索 + 下载；也许需要百度网盘。\n\n### 解压System.img文件\n\n参考[解压 Android 系统中的 system.img](https://www.jianshu.com/p/db70835d41c8)\n\n如果Rom包中不包含system.img文件，而是有system.new.dat、system.patch.dat、system.transfer.list三个文件，需要使用[sdat2img工具](https://github.com/xpirt/sdat2img)生成system.img。\n\n使用file命令确定system.img文件的文件类型，如果是“Linux rev 1.0 ext4 filesystem data”文件可以使用[ext4fuse工具](https://github.com/gerard/ext4fuse)在MacOS上挂载。\n\n成功挂载之后就可以读取system.img中的文件了。\n\n### 在System.img中寻找代码文件\n\n不同rom的system.img中的文件布局各异，以vivo X9S为例，代码文件通常是在/framework目录下的.odex文件或.oat文件。\n\n### 反编译.odex或.oat文件成.jar文件\n\n.odex&.oat -> .smali -> .dex ：使用[smail工具](https://bitbucket.org/JesusFreke/smali/overview)，baksmali.jar可以将.odex&.oat转成.smali，smali.jar可以将.smali转成.dex。\n.dex -> .jar：dex2jar工具。\n\n有了.jar文件之后就可以开心的看厂商ROM都留了哪些坑了。\n\n\n","slug":"tips-decompile-android-rom","published":1,"updated":"2018-05-04T07:54:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p4000t3mrfgmrh0c0u","content":"<p>为了解释某些厂商ROM反直觉的现象，或者绕过厂商ROM埋的坑，有时反编译ROM源码是一条不错的途径。</p>\n<h3 id=\"获取Rom包\"><a href=\"#获取Rom包\" class=\"headerlink\" title=\"获取Rom包\"></a>获取Rom包</h3><p>google 搜索 + 下载；也许需要百度网盘。</p>\n<h3 id=\"解压System-img文件\"><a href=\"#解压System-img文件\" class=\"headerlink\" title=\"解压System.img文件\"></a>解压System.img文件</h3><p>参考<a href=\"https://www.jianshu.com/p/db70835d41c8\">解压 Android 系统中的 system.img</a></p>\n<p>如果Rom包中不包含system.img文件，而是有system.new.dat、system.patch.dat、system.transfer.list三个文件，需要使用<a href=\"https://github.com/xpirt/sdat2img\">sdat2img工具</a>生成system.img。</p>\n<p>使用file命令确定system.img文件的文件类型，如果是“Linux rev 1.0 ext4 filesystem data”文件可以使用<a href=\"https://github.com/gerard/ext4fuse\">ext4fuse工具</a>在MacOS上挂载。</p>\n<p>成功挂载之后就可以读取system.img中的文件了。</p>\n<h3 id=\"在System-img中寻找代码文件\"><a href=\"#在System-img中寻找代码文件\" class=\"headerlink\" title=\"在System.img中寻找代码文件\"></a>在System.img中寻找代码文件</h3><p>不同rom的system.img中的文件布局各异，以vivo X9S为例，代码文件通常是在/framework目录下的.odex文件或.oat文件。</p>\n<h3 id=\"反编译-odex或-oat文件成-jar文件\"><a href=\"#反编译-odex或-oat文件成-jar文件\" class=\"headerlink\" title=\"反编译.odex或.oat文件成.jar文件\"></a>反编译.odex或.oat文件成.jar文件</h3><p>.odex&amp;.oat -&gt; .smali -&gt; .dex ：使用<a href=\"https://bitbucket.org/JesusFreke/smali/overview\">smail工具</a>，baksmali.jar可以将.odex&amp;.oat转成.smali，smali.jar可以将.smali转成.dex。<br>.dex -&gt; .jar：dex2jar工具。</p>\n<p>有了.jar文件之后就可以开心的看厂商ROM都留了哪些坑了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了解释某些厂商ROM反直觉的现象，或者绕过厂商ROM埋的坑，有时反编译ROM源码是一条不错的途径。</p>\n<h3 id=\"获取Rom包\"><a href=\"#获取Rom包\" class=\"headerlink\" title=\"获取Rom包\"></a>获取Rom包</h3><p>google 搜索 + 下载；也许需要百度网盘。</p>\n<h3 id=\"解压System-img文件\"><a href=\"#解压System-img文件\" class=\"headerlink\" title=\"解压System.img文件\"></a>解压System.img文件</h3><p>参考<a href=\"https://www.jianshu.com/p/db70835d41c8\">解压 Android 系统中的 system.img</a></p>\n<p>如果Rom包中不包含system.img文件，而是有system.new.dat、system.patch.dat、system.transfer.list三个文件，需要使用<a href=\"https://github.com/xpirt/sdat2img\">sdat2img工具</a>生成system.img。</p>\n<p>使用file命令确定system.img文件的文件类型，如果是“Linux rev 1.0 ext4 filesystem data”文件可以使用<a href=\"https://github.com/gerard/ext4fuse\">ext4fuse工具</a>在MacOS上挂载。</p>\n<p>成功挂载之后就可以读取system.img中的文件了。</p>\n<h3 id=\"在System-img中寻找代码文件\"><a href=\"#在System-img中寻找代码文件\" class=\"headerlink\" title=\"在System.img中寻找代码文件\"></a>在System.img中寻找代码文件</h3><p>不同rom的system.img中的文件布局各异，以vivo X9S为例，代码文件通常是在/framework目录下的.odex文件或.oat文件。</p>\n<h3 id=\"反编译-odex或-oat文件成-jar文件\"><a href=\"#反编译-odex或-oat文件成-jar文件\" class=\"headerlink\" title=\"反编译.odex或.oat文件成.jar文件\"></a>反编译.odex或.oat文件成.jar文件</h3><p>.odex&amp;.oat -&gt; .smali -&gt; .dex ：使用<a href=\"https://bitbucket.org/JesusFreke/smali/overview\">smail工具</a>，baksmali.jar可以将.odex&amp;.oat转成.smali，smali.jar可以将.smali转成.dex。<br>.dex -&gt; .jar：dex2jar工具。</p>\n<p>有了.jar文件之后就可以开心的看厂商ROM都留了哪些坑了。</p>\n"},{"title":"在迁移 Git 仓库时保留历史","catalog":true,"header-img":"/img/header_img/tips-header.jpg","date":"2021-06-17T07:41:39.000Z","subtitle":null,"_content":"\n\n\n公司做“组件化”的时候热爱新建 Git 仓库，但是有些代码被搬来搬去之后丢掉了 Git 历史，导致不好追溯代码是怎么被写残的。所以在这里简短的存档一下文明有爱的迁移步骤。\n\n## 操作步骤\n\n假定要将仓库 A 下面的 \"/module_0\" 目录迁移到新建的仓库 B 中。\n\n### 在本地仓库 A 挑选 Git 历史\n\n这一步的目标是从仓库 A 中挑选仅仅和 \"/module_0\" 目录有关的 Git 历史。\n\n* 在初始化本地仓库 A\n\n> `git clone <git repository A url> repoA`\n> `cd repoA`\n\n* (optional) 删除远端，防止将远端仓库写坏了。实际上在生产环境中，远端的重要分支会被 \"protected\"，可以忽略这个步骤。\n\n> `git remote rm origin`\n\n* 删除掉与 \"/module_0\" 目录无关的历史。注意这一步将破坏本地的 Git 历史，如果还有没同步到远端的提交，建议先 push 到远端再进行这一步。\n\n> `git filter-branch --subdirectory-filter <directory e.g. module_0> -- --all`\n\n\n### 同步本地仓库 A 的 Git 历史到本地仓库 B \n\n* 在初始化仓库 B 的本地仓库\n\n> `git clone <git repository B url> repoB`\n> `cd repoB`\n\n* 为本地仓库 B 添加一个远端，指向本地仓库 A\n\n> `git remote add remote-a <directory e.g. repoA>`\n\n* 同步本地仓库 A 特定分支的文件和 Git 历史到本地仓库 B\n\n> `git pull remote-a <branch> --allow-unrelated-histories`\n\n* 删除指向本地仓库 A 的远端\n\n> `git remote rm remote-a`\n\n### push 仓库 B 到远端\n\n> `git push origin HEAD:<remote branch>`\n\n## 闲话\n\n* `git-filter-branch` 是一个关键命令, [Understanding Git Filter-branch](https://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/)。\n*  在使用 `git-filter-branch` 时，命令行弹出了 Warning 建议使用 [git-filter-repo](https://github.com/newren/git-filter-repo/) 来 替代 `git-filter-branch` 命令。\n","source":"_posts/tips-move-git-with-history.md","raw":"---\ntitle: 在迁移 Git 仓库时保留历史\ncatalog: true\nheader-img: /img/header_img/tips-header.jpg\ntags:\n  - Git\ncategories:\n  - 经验\ndate: 2021-06-17 15:41:39\nsubtitle:\n---\n\n\n\n公司做“组件化”的时候热爱新建 Git 仓库，但是有些代码被搬来搬去之后丢掉了 Git 历史，导致不好追溯代码是怎么被写残的。所以在这里简短的存档一下文明有爱的迁移步骤。\n\n## 操作步骤\n\n假定要将仓库 A 下面的 \"/module_0\" 目录迁移到新建的仓库 B 中。\n\n### 在本地仓库 A 挑选 Git 历史\n\n这一步的目标是从仓库 A 中挑选仅仅和 \"/module_0\" 目录有关的 Git 历史。\n\n* 在初始化本地仓库 A\n\n> `git clone <git repository A url> repoA`\n> `cd repoA`\n\n* (optional) 删除远端，防止将远端仓库写坏了。实际上在生产环境中，远端的重要分支会被 \"protected\"，可以忽略这个步骤。\n\n> `git remote rm origin`\n\n* 删除掉与 \"/module_0\" 目录无关的历史。注意这一步将破坏本地的 Git 历史，如果还有没同步到远端的提交，建议先 push 到远端再进行这一步。\n\n> `git filter-branch --subdirectory-filter <directory e.g. module_0> -- --all`\n\n\n### 同步本地仓库 A 的 Git 历史到本地仓库 B \n\n* 在初始化仓库 B 的本地仓库\n\n> `git clone <git repository B url> repoB`\n> `cd repoB`\n\n* 为本地仓库 B 添加一个远端，指向本地仓库 A\n\n> `git remote add remote-a <directory e.g. repoA>`\n\n* 同步本地仓库 A 特定分支的文件和 Git 历史到本地仓库 B\n\n> `git pull remote-a <branch> --allow-unrelated-histories`\n\n* 删除指向本地仓库 A 的远端\n\n> `git remote rm remote-a`\n\n### push 仓库 B 到远端\n\n> `git push origin HEAD:<remote branch>`\n\n## 闲话\n\n* `git-filter-branch` 是一个关键命令, [Understanding Git Filter-branch](https://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/)。\n*  在使用 `git-filter-branch` 时，命令行弹出了 Warning 建议使用 [git-filter-repo](https://github.com/newren/git-filter-repo/) 来 替代 `git-filter-branch` 命令。\n","slug":"tips-move-git-with-history","published":1,"updated":"2021-06-17T07:41:39.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p4000u3mrf044jg0p7","content":"<p>公司做“组件化”的时候热爱新建 Git 仓库，但是有些代码被搬来搬去之后丢掉了 Git 历史，导致不好追溯代码是怎么被写残的。所以在这里简短的存档一下文明有爱的迁移步骤。</p>\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><p>假定要将仓库 A 下面的 “/module_0” 目录迁移到新建的仓库 B 中。</p>\n<h3 id=\"在本地仓库-A-挑选-Git-历史\"><a href=\"#在本地仓库-A-挑选-Git-历史\" class=\"headerlink\" title=\"在本地仓库 A 挑选 Git 历史\"></a>在本地仓库 A 挑选 Git 历史</h3><p>这一步的目标是从仓库 A 中挑选仅仅和 “/module_0” 目录有关的 Git 历史。</p>\n<ul>\n<li>在初始化本地仓库 A</li>\n</ul>\n<blockquote>\n<p><code>git clone &lt;git repository A url&gt; repoA</code><br><code>cd repoA</code></p>\n</blockquote>\n<ul>\n<li>(optional) 删除远端，防止将远端仓库写坏了。实际上在生产环境中，远端的重要分支会被 “protected”，可以忽略这个步骤。</li>\n</ul>\n<blockquote>\n<p><code>git remote rm origin</code></p>\n</blockquote>\n<ul>\n<li>删除掉与 “/module_0” 目录无关的历史。注意这一步将破坏本地的 Git 历史，如果还有没同步到远端的提交，建议先 push 到远端再进行这一步。</li>\n</ul>\n<blockquote>\n<p><code>git filter-branch --subdirectory-filter &lt;directory e.g. module_0&gt; -- --all</code></p>\n</blockquote>\n<h3 id=\"同步本地仓库-A-的-Git-历史到本地仓库-B\"><a href=\"#同步本地仓库-A-的-Git-历史到本地仓库-B\" class=\"headerlink\" title=\"同步本地仓库 A 的 Git 历史到本地仓库 B\"></a>同步本地仓库 A 的 Git 历史到本地仓库 B</h3><ul>\n<li>在初始化仓库 B 的本地仓库</li>\n</ul>\n<blockquote>\n<p><code>git clone &lt;git repository B url&gt; repoB</code><br><code>cd repoB</code></p>\n</blockquote>\n<ul>\n<li>为本地仓库 B 添加一个远端，指向本地仓库 A</li>\n</ul>\n<blockquote>\n<p><code>git remote add remote-a &lt;directory e.g. repoA&gt;</code></p>\n</blockquote>\n<ul>\n<li>同步本地仓库 A 特定分支的文件和 Git 历史到本地仓库 B</li>\n</ul>\n<blockquote>\n<p><code>git pull remote-a &lt;branch&gt; --allow-unrelated-histories</code></p>\n</blockquote>\n<ul>\n<li>删除指向本地仓库 A 的远端</li>\n</ul>\n<blockquote>\n<p><code>git remote rm remote-a</code></p>\n</blockquote>\n<h3 id=\"push-仓库-B-到远端\"><a href=\"#push-仓库-B-到远端\" class=\"headerlink\" title=\"push 仓库 B 到远端\"></a>push 仓库 B 到远端</h3><blockquote>\n<p><code>git push origin HEAD:&lt;remote branch&gt;</code></p>\n</blockquote>\n<h2 id=\"闲话\"><a href=\"#闲话\" class=\"headerlink\" title=\"闲话\"></a>闲话</h2><ul>\n<li><code>git-filter-branch</code> 是一个关键命令, <a href=\"https://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/\">Understanding Git Filter-branch</a>。</li>\n<li>在使用 <code>git-filter-branch</code> 时，命令行弹出了 Warning 建议使用 <a href=\"https://github.com/newren/git-filter-repo/\">git-filter-repo</a> 来 替代 <code>git-filter-branch</code> 命令。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>公司做“组件化”的时候热爱新建 Git 仓库，但是有些代码被搬来搬去之后丢掉了 Git 历史，导致不好追溯代码是怎么被写残的。所以在这里简短的存档一下文明有爱的迁移步骤。</p>\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><p>假定要将仓库 A 下面的 “/module_0” 目录迁移到新建的仓库 B 中。</p>\n<h3 id=\"在本地仓库-A-挑选-Git-历史\"><a href=\"#在本地仓库-A-挑选-Git-历史\" class=\"headerlink\" title=\"在本地仓库 A 挑选 Git 历史\"></a>在本地仓库 A 挑选 Git 历史</h3><p>这一步的目标是从仓库 A 中挑选仅仅和 “/module_0” 目录有关的 Git 历史。</p>\n<ul>\n<li>在初始化本地仓库 A</li>\n</ul>\n<blockquote>\n<p><code>git clone &lt;git repository A url&gt; repoA</code><br><code>cd repoA</code></p>\n</blockquote>\n<ul>\n<li>(optional) 删除远端，防止将远端仓库写坏了。实际上在生产环境中，远端的重要分支会被 “protected”，可以忽略这个步骤。</li>\n</ul>\n<blockquote>\n<p><code>git remote rm origin</code></p>\n</blockquote>\n<ul>\n<li>删除掉与 “/module_0” 目录无关的历史。注意这一步将破坏本地的 Git 历史，如果还有没同步到远端的提交，建议先 push 到远端再进行这一步。</li>\n</ul>\n<blockquote>\n<p><code>git filter-branch --subdirectory-filter &lt;directory e.g. module_0&gt; -- --all</code></p>\n</blockquote>\n<h3 id=\"同步本地仓库-A-的-Git-历史到本地仓库-B\"><a href=\"#同步本地仓库-A-的-Git-历史到本地仓库-B\" class=\"headerlink\" title=\"同步本地仓库 A 的 Git 历史到本地仓库 B\"></a>同步本地仓库 A 的 Git 历史到本地仓库 B</h3><ul>\n<li>在初始化仓库 B 的本地仓库</li>\n</ul>\n<blockquote>\n<p><code>git clone &lt;git repository B url&gt; repoB</code><br><code>cd repoB</code></p>\n</blockquote>\n<ul>\n<li>为本地仓库 B 添加一个远端，指向本地仓库 A</li>\n</ul>\n<blockquote>\n<p><code>git remote add remote-a &lt;directory e.g. repoA&gt;</code></p>\n</blockquote>\n<ul>\n<li>同步本地仓库 A 特定分支的文件和 Git 历史到本地仓库 B</li>\n</ul>\n<blockquote>\n<p><code>git pull remote-a &lt;branch&gt; --allow-unrelated-histories</code></p>\n</blockquote>\n<ul>\n<li>删除指向本地仓库 A 的远端</li>\n</ul>\n<blockquote>\n<p><code>git remote rm remote-a</code></p>\n</blockquote>\n<h3 id=\"push-仓库-B-到远端\"><a href=\"#push-仓库-B-到远端\" class=\"headerlink\" title=\"push 仓库 B 到远端\"></a>push 仓库 B 到远端</h3><blockquote>\n<p><code>git push origin HEAD:&lt;remote branch&gt;</code></p>\n</blockquote>\n<h2 id=\"闲话\"><a href=\"#闲话\" class=\"headerlink\" title=\"闲话\"></a>闲话</h2><ul>\n<li><code>git-filter-branch</code> 是一个关键命令, <a href=\"https://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/\">Understanding Git Filter-branch</a>。</li>\n<li>在使用 <code>git-filter-branch</code> 时，命令行弹出了 Warning 建议使用 <a href=\"https://github.com/newren/git-filter-repo/\">git-filter-repo</a> 来 替代 <code>git-filter-branch</code> 命令。</li>\n</ul>\n"},{"title":"使用Intellij/Android Studio阅读Android源码","catalog":true,"date":"2017-09-10T08:14:51.000Z","header-img":"/img/header_img/tips-header.jpg","_content":"\n\n最近想看看AOSP，对于Java／Android开发者来说，最习惯的方式就是在Intellij／Android Studio中阅读源码了，记录一下折腾的过程。\n\n## 硬件准备\n\n### 移动硬盘\n\n因为使用256G的MBP，硬盘空间常年吃紧，把AOSP直接下载到硬盘实在太奢侈了。所以准备了一块移动硬盘来放代码，这样大概会拖慢编译/IDE读工程的速度，但随后证明我这个决定是正确的。\n\n### 需要留多少硬盘空间\n\n因为需要作大小敏感的磁盘分区，所以要有分区空间预算，先说结论，对于master分支而言，120G+。\n\n在写这句话之前，我double-check了一下以防冤枉，AOSP文中写到\"完成编译至少需要 25GB 空间\"...\n最开始我留了50G，master分支还没拉完就阵亡了...\n然后按照*2规则，我留了100G，master拉完看了一眼用了60G+，但是编译时又阵亡了...\n然后改成200G，编译完成109G左右...\n\n## 下载源码\n\nmaster分支源码在我写这句话的时候大概60G，下载源码按照AOSP本来十分简单，阻力主要来自于GFW。\n\n### repo init失败\n\n第一次执行repo init的时候大概要去google服务器上下载最新的repo工具，然而连不上对吧。\n\n解决方法：\n\n去清华开源镜像站下载repo工具\n>`git clone https://gerrit-google.tuna.tsinghua.edu.cn/git-repo`   \n\n用git-repo/repo文件替换~/bin/repo；将git-repo重命名为repo替换<*你的aosp更目录*>/.repo/repo。\n这样repo init可以正确执行了。\n\n### Git访问失败\n\n拉源码的过程中肯定是要开代理的，但是Git似乎不使用全局代理，所以访问google source会失败。\n\n解决方法：\n\n设置Git代理\nGit代理可以通过以下命令来设置：\n>`git config --global https.proxy https://<*你的代理IP*>:<*你的代理端口号*>`   \n\n实际上Git代理的配置写在~/.gitconfig文件中，也可以直接改这个文件。\n>我的gitconfig文件：\n>\n>`[https]`\n>    `proxy = https://127.0.0.1:49689`\n>`[http]`\n>    `proxy = http://127.0.0.1:49689`\n>`[color]`\n>    `ui = auto`\n\n`git config --list`可以查看当前的git config配置。\n\n## 编译源码   \n\n我就读个源码，为什么还要编译？实际上如果不编译，就没有idegen.jar文件，进而也就没发用intellij打开。\n\n### 使用MacPorts获取Make、GPG失败\n\n第一次使用MacPorts的话，需要先执行`port sync`。\n执行`port sync`可能会失败，原因还是GFW，可以修改/opt/local/etc/macports/sources.conf文件中的同步地址。\n在sources.conf文件中默认地址为：\n> `rsync://rsync.macports.org/release/tarballs/ports.tar [default]`\n\n可以尝试将其改为：\n> `http://www.macports.org/files/ports.tar.gz [default]`  \n\n或者将ports.tar下载到本地解压缩，再将sources.conf配置为：\n> `file://*ports.tar的解压缩路径*`\n\n### make时出错 \n\n我在make时抛出如下错误：\n\n> build/core/base_rules.mk:130: *** external/webrtc/src/system_wrappers/\n> source:MODULE.TARGET.STATIC_LIBRARIES.libwebrtc_system_wrappers already \n> defined by external/webrtc/src/system_wrappers/source.  Stop.\n\n解决方法：\n将NDK_ROOT从环境变量里暂时移除...\n\n## 用Intellij/Android Studio打开工程\n\n想用intellij/Android Studio打开工程，需要编译生成的idegen.jar文件如果你make成功之后，发现在/out/host/linux-x86/framework目录下没有生成这个文件，那么可以自己手动编译：\n\n> `cd development/tools/idegen/`\n> `mm`\n\n这之后就会生成idegen.jar。\n\n然后在在源码根目录执行：\n\n> `development/tools/idegen/idegen.sh`\n\n过一会就会在根目录下生成两个文件，android.iml和android.ipr，这就是Intellij/Android Studio所需要的文件。\n\n通过android.ipr打开工程，会有很长的时间来建立索引。\n\n### 个人感觉Android Studio的浏览速度比Intellij快一些，也许是错觉\n\n## 闲话\n\n* 整个下载和编译过程，可以称为无痛了，只是占用硬盘空间大，等待时间较长。\n* repo工具很好，有时间要学一下；之前有人黑Git带支持超大代码库时会变得非常慢，将代码库分解是或许是解决之道。\n* 良心网站[清华开源镜像站](https://mirror.tuna.tsinghua.edu.cn/)。\n\n\n\n\n\n","source":"_posts/tips-read-aosp-in-intellij.md","raw":"---\ntitle: 使用Intellij/Android Studio阅读Android源码\ncatalog: true\ntags:\n  - Android\ncategories:\n  - 经验\ndate: 2017-09-10 16:14:51\nheader-img: /img/header_img/tips-header.jpg\n---\n\n\n最近想看看AOSP，对于Java／Android开发者来说，最习惯的方式就是在Intellij／Android Studio中阅读源码了，记录一下折腾的过程。\n\n## 硬件准备\n\n### 移动硬盘\n\n因为使用256G的MBP，硬盘空间常年吃紧，把AOSP直接下载到硬盘实在太奢侈了。所以准备了一块移动硬盘来放代码，这样大概会拖慢编译/IDE读工程的速度，但随后证明我这个决定是正确的。\n\n### 需要留多少硬盘空间\n\n因为需要作大小敏感的磁盘分区，所以要有分区空间预算，先说结论，对于master分支而言，120G+。\n\n在写这句话之前，我double-check了一下以防冤枉，AOSP文中写到\"完成编译至少需要 25GB 空间\"...\n最开始我留了50G，master分支还没拉完就阵亡了...\n然后按照*2规则，我留了100G，master拉完看了一眼用了60G+，但是编译时又阵亡了...\n然后改成200G，编译完成109G左右...\n\n## 下载源码\n\nmaster分支源码在我写这句话的时候大概60G，下载源码按照AOSP本来十分简单，阻力主要来自于GFW。\n\n### repo init失败\n\n第一次执行repo init的时候大概要去google服务器上下载最新的repo工具，然而连不上对吧。\n\n解决方法：\n\n去清华开源镜像站下载repo工具\n>`git clone https://gerrit-google.tuna.tsinghua.edu.cn/git-repo`   \n\n用git-repo/repo文件替换~/bin/repo；将git-repo重命名为repo替换<*你的aosp更目录*>/.repo/repo。\n这样repo init可以正确执行了。\n\n### Git访问失败\n\n拉源码的过程中肯定是要开代理的，但是Git似乎不使用全局代理，所以访问google source会失败。\n\n解决方法：\n\n设置Git代理\nGit代理可以通过以下命令来设置：\n>`git config --global https.proxy https://<*你的代理IP*>:<*你的代理端口号*>`   \n\n实际上Git代理的配置写在~/.gitconfig文件中，也可以直接改这个文件。\n>我的gitconfig文件：\n>\n>`[https]`\n>    `proxy = https://127.0.0.1:49689`\n>`[http]`\n>    `proxy = http://127.0.0.1:49689`\n>`[color]`\n>    `ui = auto`\n\n`git config --list`可以查看当前的git config配置。\n\n## 编译源码   \n\n我就读个源码，为什么还要编译？实际上如果不编译，就没有idegen.jar文件，进而也就没发用intellij打开。\n\n### 使用MacPorts获取Make、GPG失败\n\n第一次使用MacPorts的话，需要先执行`port sync`。\n执行`port sync`可能会失败，原因还是GFW，可以修改/opt/local/etc/macports/sources.conf文件中的同步地址。\n在sources.conf文件中默认地址为：\n> `rsync://rsync.macports.org/release/tarballs/ports.tar [default]`\n\n可以尝试将其改为：\n> `http://www.macports.org/files/ports.tar.gz [default]`  \n\n或者将ports.tar下载到本地解压缩，再将sources.conf配置为：\n> `file://*ports.tar的解压缩路径*`\n\n### make时出错 \n\n我在make时抛出如下错误：\n\n> build/core/base_rules.mk:130: *** external/webrtc/src/system_wrappers/\n> source:MODULE.TARGET.STATIC_LIBRARIES.libwebrtc_system_wrappers already \n> defined by external/webrtc/src/system_wrappers/source.  Stop.\n\n解决方法：\n将NDK_ROOT从环境变量里暂时移除...\n\n## 用Intellij/Android Studio打开工程\n\n想用intellij/Android Studio打开工程，需要编译生成的idegen.jar文件如果你make成功之后，发现在/out/host/linux-x86/framework目录下没有生成这个文件，那么可以自己手动编译：\n\n> `cd development/tools/idegen/`\n> `mm`\n\n这之后就会生成idegen.jar。\n\n然后在在源码根目录执行：\n\n> `development/tools/idegen/idegen.sh`\n\n过一会就会在根目录下生成两个文件，android.iml和android.ipr，这就是Intellij/Android Studio所需要的文件。\n\n通过android.ipr打开工程，会有很长的时间来建立索引。\n\n### 个人感觉Android Studio的浏览速度比Intellij快一些，也许是错觉\n\n## 闲话\n\n* 整个下载和编译过程，可以称为无痛了，只是占用硬盘空间大，等待时间较长。\n* repo工具很好，有时间要学一下；之前有人黑Git带支持超大代码库时会变得非常慢，将代码库分解是或许是解决之道。\n* 良心网站[清华开源镜像站](https://mirror.tuna.tsinghua.edu.cn/)。\n\n\n\n\n\n","slug":"tips-read-aosp-in-intellij","published":1,"updated":"2017-10-09T09:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p5000v3mrffqw48pz6","content":"<p>最近想看看AOSP，对于Java／Android开发者来说，最习惯的方式就是在Intellij／Android Studio中阅读源码了，记录一下折腾的过程。</p>\n<h2 id=\"硬件准备\"><a href=\"#硬件准备\" class=\"headerlink\" title=\"硬件准备\"></a>硬件准备</h2><h3 id=\"移动硬盘\"><a href=\"#移动硬盘\" class=\"headerlink\" title=\"移动硬盘\"></a>移动硬盘</h3><p>因为使用256G的MBP，硬盘空间常年吃紧，把AOSP直接下载到硬盘实在太奢侈了。所以准备了一块移动硬盘来放代码，这样大概会拖慢编译/IDE读工程的速度，但随后证明我这个决定是正确的。</p>\n<h3 id=\"需要留多少硬盘空间\"><a href=\"#需要留多少硬盘空间\" class=\"headerlink\" title=\"需要留多少硬盘空间\"></a>需要留多少硬盘空间</h3><p>因为需要作大小敏感的磁盘分区，所以要有分区空间预算，先说结论，对于master分支而言，120G+。</p>\n<p>在写这句话之前，我double-check了一下以防冤枉，AOSP文中写到”完成编译至少需要 25GB 空间”…<br>最开始我留了50G，master分支还没拉完就阵亡了…<br>然后按照*2规则，我留了100G，master拉完看了一眼用了60G+，但是编译时又阵亡了…<br>然后改成200G，编译完成109G左右…</p>\n<h2 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h2><p>master分支源码在我写这句话的时候大概60G，下载源码按照AOSP本来十分简单，阻力主要来自于GFW。</p>\n<h3 id=\"repo-init失败\"><a href=\"#repo-init失败\" class=\"headerlink\" title=\"repo init失败\"></a>repo init失败</h3><p>第一次执行repo init的时候大概要去google服务器上下载最新的repo工具，然而连不上对吧。</p>\n<p>解决方法：</p>\n<p>去清华开源镜像站下载repo工具</p>\n<blockquote>\n<p><code>git clone https://gerrit-google.tuna.tsinghua.edu.cn/git-repo</code>   </p>\n</blockquote>\n<p>用git-repo/repo文件替换~/bin/repo；将git-repo重命名为repo替换&lt;<em>你的aosp更目录</em>&gt;/.repo/repo。<br>这样repo init可以正确执行了。</p>\n<h3 id=\"Git访问失败\"><a href=\"#Git访问失败\" class=\"headerlink\" title=\"Git访问失败\"></a>Git访问失败</h3><p>拉源码的过程中肯定是要开代理的，但是Git似乎不使用全局代理，所以访问google source会失败。</p>\n<p>解决方法：</p>\n<p>设置Git代理<br>Git代理可以通过以下命令来设置：</p>\n<blockquote>\n<p><code>git config --global https.proxy https://&lt;*你的代理IP*&gt;:&lt;*你的代理端口号*&gt;</code>   </p>\n</blockquote>\n<p>实际上Git代理的配置写在~/.gitconfig文件中，也可以直接改这个文件。</p>\n<blockquote>\n<p>我的gitconfig文件：</p>\n<p><code>[https]</code><br>   <code>proxy = https://127.0.0.1:49689</code><br><code>[http]</code><br>   <code>proxy = http://127.0.0.1:49689</code><br><code>[color]</code><br>   <code>ui = auto</code></p>\n</blockquote>\n<p><code>git config --list</code>可以查看当前的git config配置。</p>\n<h2 id=\"编译源码\"><a href=\"#编译源码\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h2><p>我就读个源码，为什么还要编译？实际上如果不编译，就没有idegen.jar文件，进而也就没发用intellij打开。</p>\n<h3 id=\"使用MacPorts获取Make、GPG失败\"><a href=\"#使用MacPorts获取Make、GPG失败\" class=\"headerlink\" title=\"使用MacPorts获取Make、GPG失败\"></a>使用MacPorts获取Make、GPG失败</h3><p>第一次使用MacPorts的话，需要先执行<code>port sync</code>。<br>执行<code>port sync</code>可能会失败，原因还是GFW，可以修改/opt/local/etc/macports/sources.conf文件中的同步地址。<br>在sources.conf文件中默认地址为：</p>\n<blockquote>\n<p><code>rsync://rsync.macports.org/release/tarballs/ports.tar [default]</code></p>\n</blockquote>\n<p>可以尝试将其改为：</p>\n<blockquote>\n<p><code>http://www.macports.org/files/ports.tar.gz [default]</code>  </p>\n</blockquote>\n<p>或者将ports.tar下载到本地解压缩，再将sources.conf配置为：</p>\n<blockquote>\n<p><code>file://*ports.tar的解压缩路径*</code></p>\n</blockquote>\n<h3 id=\"make时出错\"><a href=\"#make时出错\" class=\"headerlink\" title=\"make时出错\"></a>make时出错</h3><p>我在make时抛出如下错误：</p>\n<blockquote>\n<p>build/core/base_rules.mk:130: <em>*</em> external/webrtc/src/system_wrappers/<br>source:MODULE.TARGET.STATIC_LIBRARIES.libwebrtc_system_wrappers already<br>defined by external/webrtc/src/system_wrappers/source.  Stop.</p>\n</blockquote>\n<p>解决方法：<br>将NDK_ROOT从环境变量里暂时移除…</p>\n<h2 id=\"用Intellij-Android-Studio打开工程\"><a href=\"#用Intellij-Android-Studio打开工程\" class=\"headerlink\" title=\"用Intellij/Android Studio打开工程\"></a>用Intellij/Android Studio打开工程</h2><p>想用intellij/Android Studio打开工程，需要编译生成的idegen.jar文件如果你make成功之后，发现在/out/host/linux-x86/framework目录下没有生成这个文件，那么可以自己手动编译：</p>\n<blockquote>\n<p><code>cd development/tools/idegen/</code><br><code>mm</code></p>\n</blockquote>\n<p>这之后就会生成idegen.jar。</p>\n<p>然后在在源码根目录执行：</p>\n<blockquote>\n<p><code>development/tools/idegen/idegen.sh</code></p>\n</blockquote>\n<p>过一会就会在根目录下生成两个文件，android.iml和android.ipr，这就是Intellij/Android Studio所需要的文件。</p>\n<p>通过android.ipr打开工程，会有很长的时间来建立索引。</p>\n<h3 id=\"个人感觉Android-Studio的浏览速度比Intellij快一些，也许是错觉\"><a href=\"#个人感觉Android-Studio的浏览速度比Intellij快一些，也许是错觉\" class=\"headerlink\" title=\"个人感觉Android Studio的浏览速度比Intellij快一些，也许是错觉\"></a>个人感觉Android Studio的浏览速度比Intellij快一些，也许是错觉</h3><h2 id=\"闲话\"><a href=\"#闲话\" class=\"headerlink\" title=\"闲话\"></a>闲话</h2><ul>\n<li>整个下载和编译过程，可以称为无痛了，只是占用硬盘空间大，等待时间较长。</li>\n<li>repo工具很好，有时间要学一下；之前有人黑Git带支持超大代码库时会变得非常慢，将代码库分解是或许是解决之道。</li>\n<li>良心网站<a href=\"https://mirror.tuna.tsinghua.edu.cn/\">清华开源镜像站</a>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>最近想看看AOSP，对于Java／Android开发者来说，最习惯的方式就是在Intellij／Android Studio中阅读源码了，记录一下折腾的过程。</p>\n<h2 id=\"硬件准备\"><a href=\"#硬件准备\" class=\"headerlink\" title=\"硬件准备\"></a>硬件准备</h2><h3 id=\"移动硬盘\"><a href=\"#移动硬盘\" class=\"headerlink\" title=\"移动硬盘\"></a>移动硬盘</h3><p>因为使用256G的MBP，硬盘空间常年吃紧，把AOSP直接下载到硬盘实在太奢侈了。所以准备了一块移动硬盘来放代码，这样大概会拖慢编译/IDE读工程的速度，但随后证明我这个决定是正确的。</p>\n<h3 id=\"需要留多少硬盘空间\"><a href=\"#需要留多少硬盘空间\" class=\"headerlink\" title=\"需要留多少硬盘空间\"></a>需要留多少硬盘空间</h3><p>因为需要作大小敏感的磁盘分区，所以要有分区空间预算，先说结论，对于master分支而言，120G+。</p>\n<p>在写这句话之前，我double-check了一下以防冤枉，AOSP文中写到”完成编译至少需要 25GB 空间”…<br>最开始我留了50G，master分支还没拉完就阵亡了…<br>然后按照*2规则，我留了100G，master拉完看了一眼用了60G+，但是编译时又阵亡了…<br>然后改成200G，编译完成109G左右…</p>\n<h2 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h2><p>master分支源码在我写这句话的时候大概60G，下载源码按照AOSP本来十分简单，阻力主要来自于GFW。</p>\n<h3 id=\"repo-init失败\"><a href=\"#repo-init失败\" class=\"headerlink\" title=\"repo init失败\"></a>repo init失败</h3><p>第一次执行repo init的时候大概要去google服务器上下载最新的repo工具，然而连不上对吧。</p>\n<p>解决方法：</p>\n<p>去清华开源镜像站下载repo工具</p>\n<blockquote>\n<p><code>git clone https://gerrit-google.tuna.tsinghua.edu.cn/git-repo</code>   </p>\n</blockquote>\n<p>用git-repo/repo文件替换~/bin/repo；将git-repo重命名为repo替换&lt;<em>你的aosp更目录</em>&gt;/.repo/repo。<br>这样repo init可以正确执行了。</p>\n<h3 id=\"Git访问失败\"><a href=\"#Git访问失败\" class=\"headerlink\" title=\"Git访问失败\"></a>Git访问失败</h3><p>拉源码的过程中肯定是要开代理的，但是Git似乎不使用全局代理，所以访问google source会失败。</p>\n<p>解决方法：</p>\n<p>设置Git代理<br>Git代理可以通过以下命令来设置：</p>\n<blockquote>\n<p><code>git config --global https.proxy https://&lt;*你的代理IP*&gt;:&lt;*你的代理端口号*&gt;</code>   </p>\n</blockquote>\n<p>实际上Git代理的配置写在~/.gitconfig文件中，也可以直接改这个文件。</p>\n<blockquote>\n<p>我的gitconfig文件：</p>\n<p><code>[https]</code><br>   <code>proxy = https://127.0.0.1:49689</code><br><code>[http]</code><br>   <code>proxy = http://127.0.0.1:49689</code><br><code>[color]</code><br>   <code>ui = auto</code></p>\n</blockquote>\n<p><code>git config --list</code>可以查看当前的git config配置。</p>\n<h2 id=\"编译源码\"><a href=\"#编译源码\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h2><p>我就读个源码，为什么还要编译？实际上如果不编译，就没有idegen.jar文件，进而也就没发用intellij打开。</p>\n<h3 id=\"使用MacPorts获取Make、GPG失败\"><a href=\"#使用MacPorts获取Make、GPG失败\" class=\"headerlink\" title=\"使用MacPorts获取Make、GPG失败\"></a>使用MacPorts获取Make、GPG失败</h3><p>第一次使用MacPorts的话，需要先执行<code>port sync</code>。<br>执行<code>port sync</code>可能会失败，原因还是GFW，可以修改/opt/local/etc/macports/sources.conf文件中的同步地址。<br>在sources.conf文件中默认地址为：</p>\n<blockquote>\n<p><code>rsync://rsync.macports.org/release/tarballs/ports.tar [default]</code></p>\n</blockquote>\n<p>可以尝试将其改为：</p>\n<blockquote>\n<p><code>http://www.macports.org/files/ports.tar.gz [default]</code>  </p>\n</blockquote>\n<p>或者将ports.tar下载到本地解压缩，再将sources.conf配置为：</p>\n<blockquote>\n<p><code>file://*ports.tar的解压缩路径*</code></p>\n</blockquote>\n<h3 id=\"make时出错\"><a href=\"#make时出错\" class=\"headerlink\" title=\"make时出错\"></a>make时出错</h3><p>我在make时抛出如下错误：</p>\n<blockquote>\n<p>build/core/base_rules.mk:130: <em>*</em> external/webrtc/src/system_wrappers/<br>source:MODULE.TARGET.STATIC_LIBRARIES.libwebrtc_system_wrappers already<br>defined by external/webrtc/src/system_wrappers/source.  Stop.</p>\n</blockquote>\n<p>解决方法：<br>将NDK_ROOT从环境变量里暂时移除…</p>\n<h2 id=\"用Intellij-Android-Studio打开工程\"><a href=\"#用Intellij-Android-Studio打开工程\" class=\"headerlink\" title=\"用Intellij/Android Studio打开工程\"></a>用Intellij/Android Studio打开工程</h2><p>想用intellij/Android Studio打开工程，需要编译生成的idegen.jar文件如果你make成功之后，发现在/out/host/linux-x86/framework目录下没有生成这个文件，那么可以自己手动编译：</p>\n<blockquote>\n<p><code>cd development/tools/idegen/</code><br><code>mm</code></p>\n</blockquote>\n<p>这之后就会生成idegen.jar。</p>\n<p>然后在在源码根目录执行：</p>\n<blockquote>\n<p><code>development/tools/idegen/idegen.sh</code></p>\n</blockquote>\n<p>过一会就会在根目录下生成两个文件，android.iml和android.ipr，这就是Intellij/Android Studio所需要的文件。</p>\n<p>通过android.ipr打开工程，会有很长的时间来建立索引。</p>\n<h3 id=\"个人感觉Android-Studio的浏览速度比Intellij快一些，也许是错觉\"><a href=\"#个人感觉Android-Studio的浏览速度比Intellij快一些，也许是错觉\" class=\"headerlink\" title=\"个人感觉Android Studio的浏览速度比Intellij快一些，也许是错觉\"></a>个人感觉Android Studio的浏览速度比Intellij快一些，也许是错觉</h3><h2 id=\"闲话\"><a href=\"#闲话\" class=\"headerlink\" title=\"闲话\"></a>闲话</h2><ul>\n<li>整个下载和编译过程，可以称为无痛了，只是占用硬盘空间大，等待时间较长。</li>\n<li>repo工具很好，有时间要学一下；之前有人黑Git带支持超大代码库时会变得非常慢，将代码库分解是或许是解决之道。</li>\n<li>良心网站<a href=\"https://mirror.tuna.tsinghua.edu.cn/\">清华开源镜像站</a>。</li>\n</ul>\n"},{"title":"thinking-in-java","catalog":true,"subtitle":null,"header-img":null,"_content":"\n## 2\n\n* Java中没有unsigned 数值类型(char是unsigned)。\n* char是16位的，值域为`\\u0000`-`\\uffff`。\n* Java中浮点数采用IEEE754格式，float的值域为`-2^127`-`2^127`，但只保证24个二进制位的精度(即对于整数而言float只能保证`2^24`以内的数字能精确表示)；double的值域为`-2^1023`-`2^1023`，但只保证53个二进制位的精度。\n* `java.lang`这个包会被自动import到源码。\n* javadoc中可以使用HTML标签，但不要使用标题标签。\n\n## 3\n\n* Java中指数计数法如：`float a = 1.27e16f`，其中`e`代表10的次方数。\n* 0x开头表示16进制数字，0开头表示8进制数字。\n* 位操作`&`与、`|`或、`^`异或、`～`非，其中`～`是一元操作符；`&=`、`|=`、`^=`都是合法的。\n* 位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为`2^5 = 32`位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。\n* 对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。\n* break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，`break <label>;`和`continue <label>`有助于跳出多层循环。例如：`label1: while () { while() { break label1;} }`。\n\n## 5\n\n* 当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。\n* 可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。\n* finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。\n* 类的属性的初始化的执行顺序取决于属性定义的顺序。\n* 实例初始化，其语法和`static { ... }`类似、但是去掉static关键字；这段代码执行于对象创建之后 & 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些公用的初始化逻辑。\n* Java中数组的长度是不可变的(C++难道不是么...)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。\n* 在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作*可变参数列表*来传递给方法。\n* 不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。\n\n## 6\n\n* 每个类--包括内部类、同一文件中的多个类--都会生成一个单独的.class文件。\n* Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。\n* 类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。\n* 如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。\n* 访问权限修饰词也可以用于修饰类。\n* 非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此...)。\n* 每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。\n\n## 7\n\n* 当对象需要被隐式转换成String时，**编译器**会调用其toString()方法。\n* 工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。\n* 当创建一个继承类的对象时，这个对象中包含了一个基类的对象。\n* 创建继承类时，想要正确的初始化基类，唯一的方法就是调用基类 的某个构造函数：\n    - 在不显式调用基类的构造函数的情况下，编译器(应该是编译器负责的)会自动调用基类的默认构造函数(不带参数的)。\n    - 编译器合成的默认构造函数也会调用基类的默认构造函数。\n    - 如果基类没有默认构造函数，则必须显式的调用基类的构造函数，否则编译器会报错。\n    - 显式的调用基类的构造函数(包括带参数的构造函数和默认构造函数)，必须发生在继承类构造函数的第一行，否则会编译报错。\n* 继承类对象的引用可以转型成基类对象的引用，这个被称为向上转型。\n* final关键字可以修饰数据、方法和类：\n    - final修饰属性时，如果属性是类对象，则表示这个引用不可改变，而所被引用的对象是可以改变的；Java没有提供C++的const关键字保证类对象不被改变的机制；注意数组也是类对象也符合类对象的规则。\n    - final修饰方法时，保证方法不会再继承类中被覆盖。private方法默认是final的，但其实继承类也看不到它，所以继承类依然可以定义一个与父类private方法同名的新方法。\n    - final修饰类时，保证类不会被继承。\n* 在某些(早期)的Java实现中，final修饰的方法也起到了C++中inline关键字的作用来优化执行效率，但这导致的代码膨胀反而有时会降低效率；更新的Java虚拟机会探测并消除这种inline，所以无需再把final视为inline的一种方式了。\n* 类加载和对象初始化顺序：基类加载 -> 基类静态初始化 -> 继承类加载 -> 继承类静态初始化 -> 将被分配的内存初始化为0 -> 基类对象的属性初始化 -> 基类对象构造函数 -> 继承类对象的属性初始化 -> 继承类对象构造函数。 \n\n## 8\n\n* 将方法调用(函数调用语句)和方法主体(函数所处的内存地址)关联起来的过程叫绑定，绑定包括前期绑定和动态绑定。前期绑定是在编译时发生的，而动态绑定是在运行时根据对象类型来进行的。\n* 不同语言实现动态绑定的方式略有不同。\n* Java语言中除了static方法和final方法(当然还有private方法，但上一章说过private方法默认是final方法)是采用前期绑定，其他方法都使用的动态绑定。所以final关键字除了防止override之外，还有关闭动态绑定的作用。\n* 一种错误是尝试override定义为private的方法。因为private方法是final的，所以override和多态是不会发生的，而实际上发生的是在导出类中多了一个和基类private方法同名的方法。所以通过基类引用调用这个private方法时，调用的是基类函数；通过导出类引用调用时，实际上是调用导出类中的同名方法。从private方法是前期绑定的这个原理上，也很好理解这个行为。\n* 在导出类中，尽量不要使用和基类private方法相同的方法名。\n* 构造函数自然不会有多态的特性；实际上构造函数应该归类于static方法，虽然它没有static关键字。\n* 在上一章介绍了对象的构造顺序；如果需要定一个某种显式的析构(例如release())，其调用顺序应当和构造顺序恰恰相反(就如同C++的析构函数一样)。\n* Java在构造函数中调用动态绑定的方法时，动态绑定是起作用的(和C++不同)，也就是说会调用导出类的方法；但要注意，这个时候导出类很可能还没有被构造，这可能会带来一些错误。\n* 作者认为C++处理构造函数内动态绑定函数调用的方式更为合理；所以在构造函数中应该尽量避免调用方法，或者只调用private或final方法。\n* 从JavaSE5开始，override方法的返回类型，可以是父类中被override方法的返回类型的导出类(有点绕口，但返回值不是函数signature的一部分)。\n* 在Java中使用强制类型转换(括号转换)时会进行类型检查(C++不会)，如果例如在向下转型时类型不符合，会抛出ClassCastException。\n\n## 9\n\n* 如果类中包含abstract方法，那么类必须也被声明为abstract的，否则会在编译时报错；但是声明为abstract的类，不是必须包含abstract方法，可能仅仅是想阻止该类型实例化。\n* interface自身的访问控制和class一样，可以用public修饰或者不加修饰(包访问权限)；interface的属性默认是static且final的；interface的方法默认是public的。\n* 在Java继承中，导出类override的方法的访问权限必须大于等于父类中相同方法的访问权限(override某个public方法时，覆盖实现的方法也必须是public的)。\n* 当extends和implements同时作用于一个类时，extends必须写在前面。\n* 接口是用来建立类与类直接的方法调用协议。\n* Java的抽象类只能单根继承；相对于抽象类而言，接口还提供的部分多重继承的特性，从而比抽象类更灵活。\n* 在定义基类时应该优先考虑接口，其次才是抽象类。\n* 与类的单根继承不同，接口可以extends多个接口。\n* 在多重继承的过程中(基类和接口)，如果遇到两个方法签名相同但是返回值不同，会发生编译错误。\n* 接口也很适合用来声明大量常量；在Java5推出enum之前，接口被用作enum的替代品来声明常量。\n* 接口可以声明在类内部，类内部的接口还可以是private的(除了public和包访问权限外)；接口也可能声明在接口内部，接口内部的接口默认是public的。\n\n## 10\n\n* 非静态内部类可以访问其外围类的*一切*元素，与C++不同(C++的内部类只有命名空间的作用)。\n* 如果想在\"非静态内部类的主人(外围类)\"以外的地方创建非静态内部类的实例，可以使用\"外围类实例.new\"这样的语法；例如`A a = new A();A.Inner inner = a.new Inner();`。(注意构造函数无需用`A.Inner()`,事实上这样用编译不过)\n* 可以在方法中或者方法的某个作用域中(大括号包裹的范围)定义类，那么这个类的可见性就限制在方法或作用域内部；这样的定义的类不能用访问控制关键字修饰。如果类被定义在静态方法中，那就是静态内部类；如果被定义在成员方法中，那就是非静态内部类，即内部类。\n* 匿名内部类可以继承基类或者实现接口，但是只能在继承类和实现接口之间二选一，并且不能继承多个接口。\n* 匿名内部类只具有默认构造函数，但不能定义自己的构造函数；可以使用实例静代码块(非静态代码块)来实现类似构造函数的效果。\n* 内部类不能具有static属性，也不能包含嵌套类，但是嵌套类可以有static属性和包含嵌套类。\n* 可以在接口中定义内部类，接口中的内部类默认是public和static的，即公共嵌套类；这是在接口中包含一些代码实现的方式。\n* 无论内部类被嵌套多少层，它都能访问所有外围类的所有成员。多层嵌套的内部类可以用`Father.A.B var = fatherinstance.new B()`这样的语法创建。\n* 内部类作为外围类的一部分，某种程度上给了外围类一种多重继承的能力，即用多个内部类继承多个抽象类。\n* 如果想让某个独立的类例如 A 类继承其他某个类的内部类例如 B.C ，那么 A 类的构造函数需要如下语法才能通过编译`class A extends B.C {  A(B b) { b.super() } }`。这个一个奇怪的语法。\n* 不存在继承外围类并override内部类的语法，例如有内部类A.B，C继承A并声明内部类C.B，那么A.B和C.B是两个命名空间中的两个不相关的类(除了名字相同)，不存在override关系。\n\n## 11\n\n* Arrays.asList()方法返回的List长度时不可变的，对这个List调用add()或remove()都会抛出异常。\n* HashSet是不保证顺序的，LinkedHashSet按照插入顺序保存，TreeSet按照比较结果升序保存；同样的HashMap是不保证顺序的，LinkedHashMap按照插入顺序保存，TreeMap按照比较结果升序保存。Hash*存取都是最快的，LinkedHash*取几乎和Hask*一样快。\n* 迭代器设计的初衷，是为了以统一的方式遍历所有容器，这样即使容易类型发生的改变，遍历相关的代码也无需修改。\n* List.listIterator()返回ListIterator，ListIterator是Iterator的子类型。ListIterator支持双向移动，而Iterator不行。\n* LinkedList实现的Queue接口（实际上是Deque接口，Deque extends from Queue)。\n* foreach语法之所以能作用于容器是因为Collection扩展了Iterable接口。foreach可以作用于任何实现了Iterable的类型和数组，但这不意味数组是Iterable或会被自动转型成Iterable。\n* **不要使用**Java1.0中提供的Vector、Hashtable、Stack这几个容器。\n\n## 12\n\n* 发现程序错误的最理想时机是编译时。\n* 所有标准异常类都包含以字符串为参数的构造函数，字符串代表了异常信息的描述。\n* 任何继承自 Throwable 的对象可以被作为异常抛出；异常信息通常经由异常类的类名体现，或者将更详细的异常信息保存在异常内部。\n* `Exception.printStackTrace()` 有带参数的版本，用于指定输出流。\n* `Throwable.fillInStackTrace()` 可以记录栈帧的当前状态。\n* `Throwable` 的 stackTace 中保存了一个数据，代表一个出错的调用栈，每个元素表示栈中的一帧。\n* 除了 RuntimeExcetion 及其子类，其他类型的异常都是由编译器强制约束需要被捕获的；RuntimeException 往往代表的是编程错误，比如错误的调用参数。\n* C++ 没有 finally 结构，C++ 依赖析构函数实现类似的效果；在 try 块中无论执行 return、break、continue 等任何语句，finall 代码块都会被执行。\n* Java 在设计时有缺陷，某些写法会造成异常丢失，例如在 finally 里面再次抛出异常或者执行 return 语句都会似的原本抛出的异常无法被开发者和外层代码发现（除非单步调试）。相比之下，C++ 禁止在一个异常还没处理完毕之前，抛出另一个异常。\n* 当函数的异常说明列表遇到 override 时，总体规则就是 override 方法的异常说明列表需要是基类异常说明列表的子集（通俗来说，就是在继承和 override 的过程中，异常说明列表只能越变越小）;但是构造函数是个特例，子类构造函数的异常说明列表需要时父类构造函数的异常说明列表的超集，同时在子类构造函数中不能捕获父类构造函数抛出的异常。\n* override 方法可以抛出父类方法异常列表中某个异常的子类。\n* 函数签名只包括函数名和参数列表，而不包含异常列表，所以不是只改变异常列表来重载方法。\n* 如果构造函数包含会抛出异常的代码，需要很仔细的处理，只是捕获异常可能会导致对象构造的不完整；尽量不要让构造函数包含会抛出异常的代码。\n* 作者并不喜欢 checked exception，因为强制开发者处理自己不了解的异常，可能会导致最后吞掉异常；提到了一种通用的处理方法，捕获 checked exception 然后用其创建 RuntimeException 再抛出，但这种方法也不应该滥用。\n\n13\n* 编译器会将连续的字符串 '+' 操作符优化为 StringBuilder，以防止反复创建字符串对象；不过当有循环调用时，也会反复创建 StringBuilder 对象，所以这时不要依赖编译器优化，自己创建 StringBuilder 来处理。\n* 当对象引用和字符串做 '+' 操作符时，会自动调用对象的的 `toString()` 方法。\n* 格式化输出\n    - Java 为 PrintStream 和 PrintWriter 类(`System.out`就是这种类型的对象)引入了 `format()` 和 `printf()` 方法来支持格式和输出，两个方法是等价的。\n    - Java 的格式化输出最终都是由 Formatter 类实现，可以通过输出流来创建一个 Formatter 对象，调用其 `format()` 方法向输出流进行格式化输出，这是完成格式化输出的另一个选择。\n    - 格式化输出的样式语法为 `%[{参数index}$][{flag}][{宽度}][.{精度}]{参数类型}`。例如`%2$-16.2f`，其中`-16` 表示宽度为16左对齐，默认为右对齐。\n    - `String.format()` 方法是一个静态方法，返回一个格式化字符串对象，当然也是通过 Formatter 类实现的。\n* 正则表达式\n    - 在 Java 中正则表达式的转意符为 `\\\\`，其与意为插入一个正则表达式的反斜杠，例如 `\\\\d` 表示正则匹配一个数字。\n    - `String.matches()` 可以判断是否正则匹配；`String.split()` 按正则切分；`String.replace()` 和 `String.replaceAll()` 可以按正则替换。\n    - `Pattern.compile()` 方法编译一个正则表达式，可以生成 Pattern 对象，对其调用 `Pattern.matcher()` 方法可以返回一个 Matcher 对象，表示正则匹配的结果.\n    - `Pattern.split()` 方法可以用于切分字符串。\n    - Matcher 提供了 `replaceFirst()` 和 `replaceAll()` 用于替换匹配部分。还有更强大的 `appendReplacement()` 和 `appendTail()` 用于渐进是式的替换。\n    - `Matcher.reset()` 可以重置其匹配的字符串。\n* Scanner\n    - Scanner 通过 File，InputStream，String 等任何实现了 Readable 接口的对象构建，用于方便的类型化读取（有点像 C 里面的 scanf() 函数）。它提供了 `nextLine()` 、 `nextInt()`、`nextDouble()` 等方法。\n    - 默认情况下 Scanner 根据空白字符分词，可以调用 `Scanner.useDelimiter()` 方法，传入一个正则表达式来指定分词方式。例如 `Scanner a.useDelimiter(\"\\\\s*,\\\\s*\")`。Scanner 提供了 `next()`、`hasNext`、`match()` 等方法来逐个读取正则匹配结果。\n    - StringTokenizer，是 Java5 之前的提供的类，功能和 Scanner 类似；它可以视为被废弃了。\n\n14\n* `Class.newInstance()` 成功执行的前提是类一定要有默认构造器。\n* 类加载分为三个阶段：加载，读取 .class 文件中的字节码，创建 Class 对象；链接，验证字节码，为静态属性分配存储空间；初始化，执行静态构造器和静态初始化代码块。\n* 类的初始化阶段被设计成尽可能 lazy，通过 \".class\" 获取对 Class 对象引用时并不会触发类的初始化阶段，甚至引用类所包含的编译期常量也不会触发初始化阶段；通过 `Class.forName()` 获取 Class 对象的引用总能触发初始化阶段。\n* Class 类支持泛型参数；Class<?> 和 Class 是等价的，但前者更好，因为它明确表示可以匹配任何类型。\n* `Class.cast()` 方法可以显示的执行强制转型操作，尽管需要使用这种方式的的情况比较少见。\n* `Class.isInstance()` 实现了和 instanceof 语句相同的功能；`Class.isAssignableFrom()` 提供了 instanceof 语意之外的另一种类型比较功能。\n* 运行时类型信息和反射这些工具，给开发者提供了破坏封装的方式，使他们可以调用一些原本被愿意被暴露的 api；使用反射再运行时修改 final 成员变量不会成功，虽然也不会抛出异常。\n* 尽量使用多态而不是 RTTI。 \n\n15\n* 基本类型不能作为 java 范型的类型参数(需要使用包装类型，如 Integer);但需要注意自动包装机制不能对数组起效果，例如 `int[]` 无法被自动包装成 `Integer[]`。\n* 如果可以使用泛型方法来替代泛型类，那么就选择泛型方法；构造函数也可以是泛型方法。\n* static 方法无法访问泛型类的类型参数，如果想要使 static 方法具有泛型能力，就必须使其成为泛型方法。\n* 定义泛型方法需要将泛型参数列表声明放在**返回值**前面。\n* 通常来说泛型方法依赖类型推断，也可以在'.'操作符和方法名之间插入泛型参数列表来显示制定类型，例如`A.<T,K>a()`。\n* 参数化的泛型类可以被向上转型成无参数的泛型类，编译器不会 warning，例如 `A = new A<T,K>()`；但是反向转型编译器会有 warning。\n* `Array.newInstance()` 可以借由类型来创建数组。\n* 了解技术的边界，是成为高级程序员的条件。\n* 接口可以支持泛型；可以创建带泛型参数的匿名内部类。\n* 因为类型擦除的存在，关于泛型参数的信息只能在静态类型检查时获得，在此之后泛型类型会被替换为泛型类型上界（使用 `<T extends ClassA>` 的语法指定泛型类的类型上界），泛型代码将无从得知泛型参数的具体类型是什么。\n* 补偿泛型类型信息缺失的方式：\n    - 将泛型参数的 `Class<T>` 作为参数传递到泛型代码中。\n    - 使用工厂类代替泛型参数类型的构造函数。\n    - 无法使用泛型参数创建泛型类型的数组，最终它们都会是 `Object[]` 类型的数组；使用 `List` 代替数组或者使用 `Array.newInstance()` 创建数组。\n* 不要让编译器报出不需要处理警告，而是用 `@SuppressWarnings` 去压制它们，否则无用的警告会稀释真正值得注意的警告。\n* 可以通过 `Type<T extends A & B & C>` 来给泛型参数指定多个上界，上界中只能有一个是 class 其他需要是 interface，其中 class 必须排在多个上界的最前面；可以在继承泛型类的时候添加上界，例如 `TypaB<T extends C> extends TypeA<T>`。\n* 数组可以向上转型而不会编译期报错，例如 `Base[] array = Derived[]`（但是 `array = new Base()` 会造成运行时异常）；泛型类则不能向上转型，`Generic<Base> generic = Generic<Derived>` 无法通过编译。\n* 可以通过通配符的方式完成泛型向上转型，例如 `Generic<? extends Base> generic = Generic<Derived>` 。\n* 用通配符作为泛型参数存在限制，编译器拒绝函数参数列表中涉及通配符的函数调用，但是通配符可以作为函数的返回值；即通配符作为泛型参数之后，泛型参数对象不能被传入，只能被传出。\n* 可以将泛型类的函数参数声明为 `Object` 而不是 `T`，参数传入就不会受通配符影响。\n* 和 \"extend\" 通配符相对的，`Type<? super A>` 通配符可以出现在函数参数列表中。`Type<? super A>` 可以被称为泛型参数下界，任何继承自下界类的类对象，都可以作为传入参数的合法值，下界类的父类对象作为参数传入，则会引发编译期报错。\n* 下界声明只能用在通配符泛型中，不能用在确切类型泛型，`Type<T super A>` 这种声明不能通过编译。\n* 上界通配符解决了向上转型时泛型参数类型传出问题，下界通配符解决了向上转型时泛型参数类型传入问题。\n* 无界通配符 `Type<?>` 看上去和非泛型类型（泛型参数等于 Object）差不多，但是无界通配符提供了更好的编译时检查，而非泛型类型则放弃了编译时检查：\n    - `Type<?>` 拒绝通配符类型作为参数传入，而 `Type` 则将所有传入参数转为 Object。\n    - `Type<?>` 在转型成泛型参数不同的参数化泛型时，编译器会报错，`Type` 则只会造成 warning。\n* 确切类型泛型没有传入传出的限制，但是通配符泛型类型可以接受范围更广的参数化泛型。\n","source":"_drafts/thinking-in-java.md","raw":"---\ntitle: thinking-in-java\ncatalog: true\nsubtitle:\nheader-img:\ntags:\n---\n\n## 2\n\n* Java中没有unsigned 数值类型(char是unsigned)。\n* char是16位的，值域为`\\u0000`-`\\uffff`。\n* Java中浮点数采用IEEE754格式，float的值域为`-2^127`-`2^127`，但只保证24个二进制位的精度(即对于整数而言float只能保证`2^24`以内的数字能精确表示)；double的值域为`-2^1023`-`2^1023`，但只保证53个二进制位的精度。\n* `java.lang`这个包会被自动import到源码。\n* javadoc中可以使用HTML标签，但不要使用标题标签。\n\n## 3\n\n* Java中指数计数法如：`float a = 1.27e16f`，其中`e`代表10的次方数。\n* 0x开头表示16进制数字，0开头表示8进制数字。\n* 位操作`&`与、`|`或、`^`异或、`～`非，其中`～`是一元操作符；`&=`、`|=`、`^=`都是合法的。\n* 位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为`2^5 = 32`位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。\n* 对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。\n* break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，`break <label>;`和`continue <label>`有助于跳出多层循环。例如：`label1: while () { while() { break label1;} }`。\n\n## 5\n\n* 当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。\n* 可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。\n* finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。\n* 类的属性的初始化的执行顺序取决于属性定义的顺序。\n* 实例初始化，其语法和`static { ... }`类似、但是去掉static关键字；这段代码执行于对象创建之后 & 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些公用的初始化逻辑。\n* Java中数组的长度是不可变的(C++难道不是么...)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。\n* 在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作*可变参数列表*来传递给方法。\n* 不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。\n\n## 6\n\n* 每个类--包括内部类、同一文件中的多个类--都会生成一个单独的.class文件。\n* Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。\n* 类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。\n* 如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。\n* 访问权限修饰词也可以用于修饰类。\n* 非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此...)。\n* 每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。\n\n## 7\n\n* 当对象需要被隐式转换成String时，**编译器**会调用其toString()方法。\n* 工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。\n* 当创建一个继承类的对象时，这个对象中包含了一个基类的对象。\n* 创建继承类时，想要正确的初始化基类，唯一的方法就是调用基类 的某个构造函数：\n    - 在不显式调用基类的构造函数的情况下，编译器(应该是编译器负责的)会自动调用基类的默认构造函数(不带参数的)。\n    - 编译器合成的默认构造函数也会调用基类的默认构造函数。\n    - 如果基类没有默认构造函数，则必须显式的调用基类的构造函数，否则编译器会报错。\n    - 显式的调用基类的构造函数(包括带参数的构造函数和默认构造函数)，必须发生在继承类构造函数的第一行，否则会编译报错。\n* 继承类对象的引用可以转型成基类对象的引用，这个被称为向上转型。\n* final关键字可以修饰数据、方法和类：\n    - final修饰属性时，如果属性是类对象，则表示这个引用不可改变，而所被引用的对象是可以改变的；Java没有提供C++的const关键字保证类对象不被改变的机制；注意数组也是类对象也符合类对象的规则。\n    - final修饰方法时，保证方法不会再继承类中被覆盖。private方法默认是final的，但其实继承类也看不到它，所以继承类依然可以定义一个与父类private方法同名的新方法。\n    - final修饰类时，保证类不会被继承。\n* 在某些(早期)的Java实现中，final修饰的方法也起到了C++中inline关键字的作用来优化执行效率，但这导致的代码膨胀反而有时会降低效率；更新的Java虚拟机会探测并消除这种inline，所以无需再把final视为inline的一种方式了。\n* 类加载和对象初始化顺序：基类加载 -> 基类静态初始化 -> 继承类加载 -> 继承类静态初始化 -> 将被分配的内存初始化为0 -> 基类对象的属性初始化 -> 基类对象构造函数 -> 继承类对象的属性初始化 -> 继承类对象构造函数。 \n\n## 8\n\n* 将方法调用(函数调用语句)和方法主体(函数所处的内存地址)关联起来的过程叫绑定，绑定包括前期绑定和动态绑定。前期绑定是在编译时发生的，而动态绑定是在运行时根据对象类型来进行的。\n* 不同语言实现动态绑定的方式略有不同。\n* Java语言中除了static方法和final方法(当然还有private方法，但上一章说过private方法默认是final方法)是采用前期绑定，其他方法都使用的动态绑定。所以final关键字除了防止override之外，还有关闭动态绑定的作用。\n* 一种错误是尝试override定义为private的方法。因为private方法是final的，所以override和多态是不会发生的，而实际上发生的是在导出类中多了一个和基类private方法同名的方法。所以通过基类引用调用这个private方法时，调用的是基类函数；通过导出类引用调用时，实际上是调用导出类中的同名方法。从private方法是前期绑定的这个原理上，也很好理解这个行为。\n* 在导出类中，尽量不要使用和基类private方法相同的方法名。\n* 构造函数自然不会有多态的特性；实际上构造函数应该归类于static方法，虽然它没有static关键字。\n* 在上一章介绍了对象的构造顺序；如果需要定一个某种显式的析构(例如release())，其调用顺序应当和构造顺序恰恰相反(就如同C++的析构函数一样)。\n* Java在构造函数中调用动态绑定的方法时，动态绑定是起作用的(和C++不同)，也就是说会调用导出类的方法；但要注意，这个时候导出类很可能还没有被构造，这可能会带来一些错误。\n* 作者认为C++处理构造函数内动态绑定函数调用的方式更为合理；所以在构造函数中应该尽量避免调用方法，或者只调用private或final方法。\n* 从JavaSE5开始，override方法的返回类型，可以是父类中被override方法的返回类型的导出类(有点绕口，但返回值不是函数signature的一部分)。\n* 在Java中使用强制类型转换(括号转换)时会进行类型检查(C++不会)，如果例如在向下转型时类型不符合，会抛出ClassCastException。\n\n## 9\n\n* 如果类中包含abstract方法，那么类必须也被声明为abstract的，否则会在编译时报错；但是声明为abstract的类，不是必须包含abstract方法，可能仅仅是想阻止该类型实例化。\n* interface自身的访问控制和class一样，可以用public修饰或者不加修饰(包访问权限)；interface的属性默认是static且final的；interface的方法默认是public的。\n* 在Java继承中，导出类override的方法的访问权限必须大于等于父类中相同方法的访问权限(override某个public方法时，覆盖实现的方法也必须是public的)。\n* 当extends和implements同时作用于一个类时，extends必须写在前面。\n* 接口是用来建立类与类直接的方法调用协议。\n* Java的抽象类只能单根继承；相对于抽象类而言，接口还提供的部分多重继承的特性，从而比抽象类更灵活。\n* 在定义基类时应该优先考虑接口，其次才是抽象类。\n* 与类的单根继承不同，接口可以extends多个接口。\n* 在多重继承的过程中(基类和接口)，如果遇到两个方法签名相同但是返回值不同，会发生编译错误。\n* 接口也很适合用来声明大量常量；在Java5推出enum之前，接口被用作enum的替代品来声明常量。\n* 接口可以声明在类内部，类内部的接口还可以是private的(除了public和包访问权限外)；接口也可能声明在接口内部，接口内部的接口默认是public的。\n\n## 10\n\n* 非静态内部类可以访问其外围类的*一切*元素，与C++不同(C++的内部类只有命名空间的作用)。\n* 如果想在\"非静态内部类的主人(外围类)\"以外的地方创建非静态内部类的实例，可以使用\"外围类实例.new\"这样的语法；例如`A a = new A();A.Inner inner = a.new Inner();`。(注意构造函数无需用`A.Inner()`,事实上这样用编译不过)\n* 可以在方法中或者方法的某个作用域中(大括号包裹的范围)定义类，那么这个类的可见性就限制在方法或作用域内部；这样的定义的类不能用访问控制关键字修饰。如果类被定义在静态方法中，那就是静态内部类；如果被定义在成员方法中，那就是非静态内部类，即内部类。\n* 匿名内部类可以继承基类或者实现接口，但是只能在继承类和实现接口之间二选一，并且不能继承多个接口。\n* 匿名内部类只具有默认构造函数，但不能定义自己的构造函数；可以使用实例静代码块(非静态代码块)来实现类似构造函数的效果。\n* 内部类不能具有static属性，也不能包含嵌套类，但是嵌套类可以有static属性和包含嵌套类。\n* 可以在接口中定义内部类，接口中的内部类默认是public和static的，即公共嵌套类；这是在接口中包含一些代码实现的方式。\n* 无论内部类被嵌套多少层，它都能访问所有外围类的所有成员。多层嵌套的内部类可以用`Father.A.B var = fatherinstance.new B()`这样的语法创建。\n* 内部类作为外围类的一部分，某种程度上给了外围类一种多重继承的能力，即用多个内部类继承多个抽象类。\n* 如果想让某个独立的类例如 A 类继承其他某个类的内部类例如 B.C ，那么 A 类的构造函数需要如下语法才能通过编译`class A extends B.C {  A(B b) { b.super() } }`。这个一个奇怪的语法。\n* 不存在继承外围类并override内部类的语法，例如有内部类A.B，C继承A并声明内部类C.B，那么A.B和C.B是两个命名空间中的两个不相关的类(除了名字相同)，不存在override关系。\n\n## 11\n\n* Arrays.asList()方法返回的List长度时不可变的，对这个List调用add()或remove()都会抛出异常。\n* HashSet是不保证顺序的，LinkedHashSet按照插入顺序保存，TreeSet按照比较结果升序保存；同样的HashMap是不保证顺序的，LinkedHashMap按照插入顺序保存，TreeMap按照比较结果升序保存。Hash*存取都是最快的，LinkedHash*取几乎和Hask*一样快。\n* 迭代器设计的初衷，是为了以统一的方式遍历所有容器，这样即使容易类型发生的改变，遍历相关的代码也无需修改。\n* List.listIterator()返回ListIterator，ListIterator是Iterator的子类型。ListIterator支持双向移动，而Iterator不行。\n* LinkedList实现的Queue接口（实际上是Deque接口，Deque extends from Queue)。\n* foreach语法之所以能作用于容器是因为Collection扩展了Iterable接口。foreach可以作用于任何实现了Iterable的类型和数组，但这不意味数组是Iterable或会被自动转型成Iterable。\n* **不要使用**Java1.0中提供的Vector、Hashtable、Stack这几个容器。\n\n## 12\n\n* 发现程序错误的最理想时机是编译时。\n* 所有标准异常类都包含以字符串为参数的构造函数，字符串代表了异常信息的描述。\n* 任何继承自 Throwable 的对象可以被作为异常抛出；异常信息通常经由异常类的类名体现，或者将更详细的异常信息保存在异常内部。\n* `Exception.printStackTrace()` 有带参数的版本，用于指定输出流。\n* `Throwable.fillInStackTrace()` 可以记录栈帧的当前状态。\n* `Throwable` 的 stackTace 中保存了一个数据，代表一个出错的调用栈，每个元素表示栈中的一帧。\n* 除了 RuntimeExcetion 及其子类，其他类型的异常都是由编译器强制约束需要被捕获的；RuntimeException 往往代表的是编程错误，比如错误的调用参数。\n* C++ 没有 finally 结构，C++ 依赖析构函数实现类似的效果；在 try 块中无论执行 return、break、continue 等任何语句，finall 代码块都会被执行。\n* Java 在设计时有缺陷，某些写法会造成异常丢失，例如在 finally 里面再次抛出异常或者执行 return 语句都会似的原本抛出的异常无法被开发者和外层代码发现（除非单步调试）。相比之下，C++ 禁止在一个异常还没处理完毕之前，抛出另一个异常。\n* 当函数的异常说明列表遇到 override 时，总体规则就是 override 方法的异常说明列表需要是基类异常说明列表的子集（通俗来说，就是在继承和 override 的过程中，异常说明列表只能越变越小）;但是构造函数是个特例，子类构造函数的异常说明列表需要时父类构造函数的异常说明列表的超集，同时在子类构造函数中不能捕获父类构造函数抛出的异常。\n* override 方法可以抛出父类方法异常列表中某个异常的子类。\n* 函数签名只包括函数名和参数列表，而不包含异常列表，所以不是只改变异常列表来重载方法。\n* 如果构造函数包含会抛出异常的代码，需要很仔细的处理，只是捕获异常可能会导致对象构造的不完整；尽量不要让构造函数包含会抛出异常的代码。\n* 作者并不喜欢 checked exception，因为强制开发者处理自己不了解的异常，可能会导致最后吞掉异常；提到了一种通用的处理方法，捕获 checked exception 然后用其创建 RuntimeException 再抛出，但这种方法也不应该滥用。\n\n13\n* 编译器会将连续的字符串 '+' 操作符优化为 StringBuilder，以防止反复创建字符串对象；不过当有循环调用时，也会反复创建 StringBuilder 对象，所以这时不要依赖编译器优化，自己创建 StringBuilder 来处理。\n* 当对象引用和字符串做 '+' 操作符时，会自动调用对象的的 `toString()` 方法。\n* 格式化输出\n    - Java 为 PrintStream 和 PrintWriter 类(`System.out`就是这种类型的对象)引入了 `format()` 和 `printf()` 方法来支持格式和输出，两个方法是等价的。\n    - Java 的格式化输出最终都是由 Formatter 类实现，可以通过输出流来创建一个 Formatter 对象，调用其 `format()` 方法向输出流进行格式化输出，这是完成格式化输出的另一个选择。\n    - 格式化输出的样式语法为 `%[{参数index}$][{flag}][{宽度}][.{精度}]{参数类型}`。例如`%2$-16.2f`，其中`-16` 表示宽度为16左对齐，默认为右对齐。\n    - `String.format()` 方法是一个静态方法，返回一个格式化字符串对象，当然也是通过 Formatter 类实现的。\n* 正则表达式\n    - 在 Java 中正则表达式的转意符为 `\\\\`，其与意为插入一个正则表达式的反斜杠，例如 `\\\\d` 表示正则匹配一个数字。\n    - `String.matches()` 可以判断是否正则匹配；`String.split()` 按正则切分；`String.replace()` 和 `String.replaceAll()` 可以按正则替换。\n    - `Pattern.compile()` 方法编译一个正则表达式，可以生成 Pattern 对象，对其调用 `Pattern.matcher()` 方法可以返回一个 Matcher 对象，表示正则匹配的结果.\n    - `Pattern.split()` 方法可以用于切分字符串。\n    - Matcher 提供了 `replaceFirst()` 和 `replaceAll()` 用于替换匹配部分。还有更强大的 `appendReplacement()` 和 `appendTail()` 用于渐进是式的替换。\n    - `Matcher.reset()` 可以重置其匹配的字符串。\n* Scanner\n    - Scanner 通过 File，InputStream，String 等任何实现了 Readable 接口的对象构建，用于方便的类型化读取（有点像 C 里面的 scanf() 函数）。它提供了 `nextLine()` 、 `nextInt()`、`nextDouble()` 等方法。\n    - 默认情况下 Scanner 根据空白字符分词，可以调用 `Scanner.useDelimiter()` 方法，传入一个正则表达式来指定分词方式。例如 `Scanner a.useDelimiter(\"\\\\s*,\\\\s*\")`。Scanner 提供了 `next()`、`hasNext`、`match()` 等方法来逐个读取正则匹配结果。\n    - StringTokenizer，是 Java5 之前的提供的类，功能和 Scanner 类似；它可以视为被废弃了。\n\n14\n* `Class.newInstance()` 成功执行的前提是类一定要有默认构造器。\n* 类加载分为三个阶段：加载，读取 .class 文件中的字节码，创建 Class 对象；链接，验证字节码，为静态属性分配存储空间；初始化，执行静态构造器和静态初始化代码块。\n* 类的初始化阶段被设计成尽可能 lazy，通过 \".class\" 获取对 Class 对象引用时并不会触发类的初始化阶段，甚至引用类所包含的编译期常量也不会触发初始化阶段；通过 `Class.forName()` 获取 Class 对象的引用总能触发初始化阶段。\n* Class 类支持泛型参数；Class<?> 和 Class 是等价的，但前者更好，因为它明确表示可以匹配任何类型。\n* `Class.cast()` 方法可以显示的执行强制转型操作，尽管需要使用这种方式的的情况比较少见。\n* `Class.isInstance()` 实现了和 instanceof 语句相同的功能；`Class.isAssignableFrom()` 提供了 instanceof 语意之外的另一种类型比较功能。\n* 运行时类型信息和反射这些工具，给开发者提供了破坏封装的方式，使他们可以调用一些原本被愿意被暴露的 api；使用反射再运行时修改 final 成员变量不会成功，虽然也不会抛出异常。\n* 尽量使用多态而不是 RTTI。 \n\n15\n* 基本类型不能作为 java 范型的类型参数(需要使用包装类型，如 Integer);但需要注意自动包装机制不能对数组起效果，例如 `int[]` 无法被自动包装成 `Integer[]`。\n* 如果可以使用泛型方法来替代泛型类，那么就选择泛型方法；构造函数也可以是泛型方法。\n* static 方法无法访问泛型类的类型参数，如果想要使 static 方法具有泛型能力，就必须使其成为泛型方法。\n* 定义泛型方法需要将泛型参数列表声明放在**返回值**前面。\n* 通常来说泛型方法依赖类型推断，也可以在'.'操作符和方法名之间插入泛型参数列表来显示制定类型，例如`A.<T,K>a()`。\n* 参数化的泛型类可以被向上转型成无参数的泛型类，编译器不会 warning，例如 `A = new A<T,K>()`；但是反向转型编译器会有 warning。\n* `Array.newInstance()` 可以借由类型来创建数组。\n* 了解技术的边界，是成为高级程序员的条件。\n* 接口可以支持泛型；可以创建带泛型参数的匿名内部类。\n* 因为类型擦除的存在，关于泛型参数的信息只能在静态类型检查时获得，在此之后泛型类型会被替换为泛型类型上界（使用 `<T extends ClassA>` 的语法指定泛型类的类型上界），泛型代码将无从得知泛型参数的具体类型是什么。\n* 补偿泛型类型信息缺失的方式：\n    - 将泛型参数的 `Class<T>` 作为参数传递到泛型代码中。\n    - 使用工厂类代替泛型参数类型的构造函数。\n    - 无法使用泛型参数创建泛型类型的数组，最终它们都会是 `Object[]` 类型的数组；使用 `List` 代替数组或者使用 `Array.newInstance()` 创建数组。\n* 不要让编译器报出不需要处理警告，而是用 `@SuppressWarnings` 去压制它们，否则无用的警告会稀释真正值得注意的警告。\n* 可以通过 `Type<T extends A & B & C>` 来给泛型参数指定多个上界，上界中只能有一个是 class 其他需要是 interface，其中 class 必须排在多个上界的最前面；可以在继承泛型类的时候添加上界，例如 `TypaB<T extends C> extends TypeA<T>`。\n* 数组可以向上转型而不会编译期报错，例如 `Base[] array = Derived[]`（但是 `array = new Base()` 会造成运行时异常）；泛型类则不能向上转型，`Generic<Base> generic = Generic<Derived>` 无法通过编译。\n* 可以通过通配符的方式完成泛型向上转型，例如 `Generic<? extends Base> generic = Generic<Derived>` 。\n* 用通配符作为泛型参数存在限制，编译器拒绝函数参数列表中涉及通配符的函数调用，但是通配符可以作为函数的返回值；即通配符作为泛型参数之后，泛型参数对象不能被传入，只能被传出。\n* 可以将泛型类的函数参数声明为 `Object` 而不是 `T`，参数传入就不会受通配符影响。\n* 和 \"extend\" 通配符相对的，`Type<? super A>` 通配符可以出现在函数参数列表中。`Type<? super A>` 可以被称为泛型参数下界，任何继承自下界类的类对象，都可以作为传入参数的合法值，下界类的父类对象作为参数传入，则会引发编译期报错。\n* 下界声明只能用在通配符泛型中，不能用在确切类型泛型，`Type<T super A>` 这种声明不能通过编译。\n* 上界通配符解决了向上转型时泛型参数类型传出问题，下界通配符解决了向上转型时泛型参数类型传入问题。\n* 无界通配符 `Type<?>` 看上去和非泛型类型（泛型参数等于 Object）差不多，但是无界通配符提供了更好的编译时检查，而非泛型类型则放弃了编译时检查：\n    - `Type<?>` 拒绝通配符类型作为参数传入，而 `Type` 则将所有传入参数转为 Object。\n    - `Type<?>` 在转型成泛型参数不同的参数化泛型时，编译器会报错，`Type` 则只会造成 warning。\n* 确切类型泛型没有传入传出的限制，但是通配符泛型类型可以接受范围更广的参数化泛型。\n","slug":"thinking-in-java","published":0,"date":"2019-06-26T00:29:17.000Z","updated":"2019-06-26T00:29:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4p9000w3mrfa5cu4t3i","content":"<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><ul>\n<li>Java中没有unsigned 数值类型(char是unsigned)。</li>\n<li>char是16位的，值域为<code>\\u0000</code>-<code>\\uffff</code>。</li>\n<li>Java中浮点数采用IEEE754格式，float的值域为<code>-2^127</code>-<code>2^127</code>，但只保证24个二进制位的精度(即对于整数而言float只能保证<code>2^24</code>以内的数字能精确表示)；double的值域为<code>-2^1023</code>-<code>2^1023</code>，但只保证53个二进制位的精度。</li>\n<li><code>java.lang</code>这个包会被自动import到源码。</li>\n<li>javadoc中可以使用HTML标签，但不要使用标题标签。</li>\n</ul>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><ul>\n<li>Java中指数计数法如：<code>float a = 1.27e16f</code>，其中<code>e</code>代表10的次方数。</li>\n<li>0x开头表示16进制数字，0开头表示8进制数字。</li>\n<li>位操作<code>&amp;</code>与、<code>|</code>或、<code>^</code>异或、<code>～</code>非，其中<code>～</code>是一元操作符；<code>&amp;=</code>、<code>|=</code>、<code>^=</code>都是合法的。</li>\n<li>位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为<code>2^5 = 32</code>位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。</li>\n<li>对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。</li>\n<li>break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，<code>break &lt;label&gt;;</code>和<code>continue &lt;label&gt;</code>有助于跳出多层循环。例如：<code>label1: while () &#123; while() &#123; break label1;&#125; &#125;</code>。</li>\n</ul>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><ul>\n<li>当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。</li>\n<li>可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。</li>\n<li>finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。</li>\n<li>类的属性的初始化的执行顺序取决于属性定义的顺序。</li>\n<li>实例初始化，其语法和<code>static &#123; ... &#125;</code>类似、但是去掉static关键字；这段代码执行于对象创建之后 &amp; 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些公用的初始化逻辑。</li>\n<li>Java中数组的长度是不可变的(C++难道不是么…)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。</li>\n<li>在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作<em>可变参数列表</em>来传递给方法。</li>\n<li>不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。</li>\n</ul>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><ul>\n<li>每个类–包括内部类、同一文件中的多个类–都会生成一个单独的.class文件。</li>\n<li>Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。</li>\n<li>类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。</li>\n<li>如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。</li>\n<li>访问权限修饰词也可以用于修饰类。</li>\n<li>非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此…)。</li>\n<li>每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。</li>\n</ul>\n<h2 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h2><ul>\n<li>当对象需要被隐式转换成String时，<strong>编译器</strong>会调用其toString()方法。</li>\n<li>工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。</li>\n<li>当创建一个继承类的对象时，这个对象中包含了一个基类的对象。</li>\n<li>创建继承类时，想要正确的初始化基类，唯一的方法就是调用基类 的某个构造函数：<ul>\n<li>在不显式调用基类的构造函数的情况下，编译器(应该是编译器负责的)会自动调用基类的默认构造函数(不带参数的)。</li>\n<li>编译器合成的默认构造函数也会调用基类的默认构造函数。</li>\n<li>如果基类没有默认构造函数，则必须显式的调用基类的构造函数，否则编译器会报错。</li>\n<li>显式的调用基类的构造函数(包括带参数的构造函数和默认构造函数)，必须发生在继承类构造函数的第一行，否则会编译报错。</li>\n</ul>\n</li>\n<li>继承类对象的引用可以转型成基类对象的引用，这个被称为向上转型。</li>\n<li>final关键字可以修饰数据、方法和类：<ul>\n<li>final修饰属性时，如果属性是类对象，则表示这个引用不可改变，而所被引用的对象是可以改变的；Java没有提供C++的const关键字保证类对象不被改变的机制；注意数组也是类对象也符合类对象的规则。</li>\n<li>final修饰方法时，保证方法不会再继承类中被覆盖。private方法默认是final的，但其实继承类也看不到它，所以继承类依然可以定义一个与父类private方法同名的新方法。</li>\n<li>final修饰类时，保证类不会被继承。</li>\n</ul>\n</li>\n<li>在某些(早期)的Java实现中，final修饰的方法也起到了C++中inline关键字的作用来优化执行效率，但这导致的代码膨胀反而有时会降低效率；更新的Java虚拟机会探测并消除这种inline，所以无需再把final视为inline的一种方式了。</li>\n<li>类加载和对象初始化顺序：基类加载 -&gt; 基类静态初始化 -&gt; 继承类加载 -&gt; 继承类静态初始化 -&gt; 将被分配的内存初始化为0 -&gt; 基类对象的属性初始化 -&gt; 基类对象构造函数 -&gt; 继承类对象的属性初始化 -&gt; 继承类对象构造函数。 </li>\n</ul>\n<h2 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8\"></a>8</h2><ul>\n<li>将方法调用(函数调用语句)和方法主体(函数所处的内存地址)关联起来的过程叫绑定，绑定包括前期绑定和动态绑定。前期绑定是在编译时发生的，而动态绑定是在运行时根据对象类型来进行的。</li>\n<li>不同语言实现动态绑定的方式略有不同。</li>\n<li>Java语言中除了static方法和final方法(当然还有private方法，但上一章说过private方法默认是final方法)是采用前期绑定，其他方法都使用的动态绑定。所以final关键字除了防止override之外，还有关闭动态绑定的作用。</li>\n<li>一种错误是尝试override定义为private的方法。因为private方法是final的，所以override和多态是不会发生的，而实际上发生的是在导出类中多了一个和基类private方法同名的方法。所以通过基类引用调用这个private方法时，调用的是基类函数；通过导出类引用调用时，实际上是调用导出类中的同名方法。从private方法是前期绑定的这个原理上，也很好理解这个行为。</li>\n<li>在导出类中，尽量不要使用和基类private方法相同的方法名。</li>\n<li>构造函数自然不会有多态的特性；实际上构造函数应该归类于static方法，虽然它没有static关键字。</li>\n<li>在上一章介绍了对象的构造顺序；如果需要定一个某种显式的析构(例如release())，其调用顺序应当和构造顺序恰恰相反(就如同C++的析构函数一样)。</li>\n<li>Java在构造函数中调用动态绑定的方法时，动态绑定是起作用的(和C++不同)，也就是说会调用导出类的方法；但要注意，这个时候导出类很可能还没有被构造，这可能会带来一些错误。</li>\n<li>作者认为C++处理构造函数内动态绑定函数调用的方式更为合理；所以在构造函数中应该尽量避免调用方法，或者只调用private或final方法。</li>\n<li>从JavaSE5开始，override方法的返回类型，可以是父类中被override方法的返回类型的导出类(有点绕口，但返回值不是函数signature的一部分)。</li>\n<li>在Java中使用强制类型转换(括号转换)时会进行类型检查(C++不会)，如果例如在向下转型时类型不符合，会抛出ClassCastException。</li>\n</ul>\n<h2 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h2><ul>\n<li>如果类中包含abstract方法，那么类必须也被声明为abstract的，否则会在编译时报错；但是声明为abstract的类，不是必须包含abstract方法，可能仅仅是想阻止该类型实例化。</li>\n<li>interface自身的访问控制和class一样，可以用public修饰或者不加修饰(包访问权限)；interface的属性默认是static且final的；interface的方法默认是public的。</li>\n<li>在Java继承中，导出类override的方法的访问权限必须大于等于父类中相同方法的访问权限(override某个public方法时，覆盖实现的方法也必须是public的)。</li>\n<li>当extends和implements同时作用于一个类时，extends必须写在前面。</li>\n<li>接口是用来建立类与类直接的方法调用协议。</li>\n<li>Java的抽象类只能单根继承；相对于抽象类而言，接口还提供的部分多重继承的特性，从而比抽象类更灵活。</li>\n<li>在定义基类时应该优先考虑接口，其次才是抽象类。</li>\n<li>与类的单根继承不同，接口可以extends多个接口。</li>\n<li>在多重继承的过程中(基类和接口)，如果遇到两个方法签名相同但是返回值不同，会发生编译错误。</li>\n<li>接口也很适合用来声明大量常量；在Java5推出enum之前，接口被用作enum的替代品来声明常量。</li>\n<li>接口可以声明在类内部，类内部的接口还可以是private的(除了public和包访问权限外)；接口也可能声明在接口内部，接口内部的接口默认是public的。</li>\n</ul>\n<h2 id=\"10\"><a href=\"#10\" class=\"headerlink\" title=\"10\"></a>10</h2><ul>\n<li>非静态内部类可以访问其外围类的<em>一切</em>元素，与C++不同(C++的内部类只有命名空间的作用)。</li>\n<li>如果想在”非静态内部类的主人(外围类)”以外的地方创建非静态内部类的实例，可以使用”外围类实例.new”这样的语法；例如<code>A a = new A();A.Inner inner = a.new Inner();</code>。(注意构造函数无需用<code>A.Inner()</code>,事实上这样用编译不过)</li>\n<li>可以在方法中或者方法的某个作用域中(大括号包裹的范围)定义类，那么这个类的可见性就限制在方法或作用域内部；这样的定义的类不能用访问控制关键字修饰。如果类被定义在静态方法中，那就是静态内部类；如果被定义在成员方法中，那就是非静态内部类，即内部类。</li>\n<li>匿名内部类可以继承基类或者实现接口，但是只能在继承类和实现接口之间二选一，并且不能继承多个接口。</li>\n<li>匿名内部类只具有默认构造函数，但不能定义自己的构造函数；可以使用实例静代码块(非静态代码块)来实现类似构造函数的效果。</li>\n<li>内部类不能具有static属性，也不能包含嵌套类，但是嵌套类可以有static属性和包含嵌套类。</li>\n<li>可以在接口中定义内部类，接口中的内部类默认是public和static的，即公共嵌套类；这是在接口中包含一些代码实现的方式。</li>\n<li>无论内部类被嵌套多少层，它都能访问所有外围类的所有成员。多层嵌套的内部类可以用<code>Father.A.B var = fatherinstance.new B()</code>这样的语法创建。</li>\n<li>内部类作为外围类的一部分，某种程度上给了外围类一种多重继承的能力，即用多个内部类继承多个抽象类。</li>\n<li>如果想让某个独立的类例如 A 类继承其他某个类的内部类例如 B.C ，那么 A 类的构造函数需要如下语法才能通过编译<code>class A extends B.C &#123;  A(B b) &#123; b.super() &#125; &#125;</code>。这个一个奇怪的语法。</li>\n<li>不存在继承外围类并override内部类的语法，例如有内部类A.B，C继承A并声明内部类C.B，那么A.B和C.B是两个命名空间中的两个不相关的类(除了名字相同)，不存在override关系。</li>\n</ul>\n<h2 id=\"11\"><a href=\"#11\" class=\"headerlink\" title=\"11\"></a>11</h2><ul>\n<li>Arrays.asList()方法返回的List长度时不可变的，对这个List调用add()或remove()都会抛出异常。</li>\n<li>HashSet是不保证顺序的，LinkedHashSet按照插入顺序保存，TreeSet按照比较结果升序保存；同样的HashMap是不保证顺序的，LinkedHashMap按照插入顺序保存，TreeMap按照比较结果升序保存。Hash<em>存取都是最快的，LinkedHash</em>取几乎和Hask*一样快。</li>\n<li>迭代器设计的初衷，是为了以统一的方式遍历所有容器，这样即使容易类型发生的改变，遍历相关的代码也无需修改。</li>\n<li>List.listIterator()返回ListIterator，ListIterator是Iterator的子类型。ListIterator支持双向移动，而Iterator不行。</li>\n<li>LinkedList实现的Queue接口（实际上是Deque接口，Deque extends from Queue)。</li>\n<li>foreach语法之所以能作用于容器是因为Collection扩展了Iterable接口。foreach可以作用于任何实现了Iterable的类型和数组，但这不意味数组是Iterable或会被自动转型成Iterable。</li>\n<li><strong>不要使用</strong>Java1.0中提供的Vector、Hashtable、Stack这几个容器。</li>\n</ul>\n<h2 id=\"12\"><a href=\"#12\" class=\"headerlink\" title=\"12\"></a>12</h2><ul>\n<li>发现程序错误的最理想时机是编译时。</li>\n<li>所有标准异常类都包含以字符串为参数的构造函数，字符串代表了异常信息的描述。</li>\n<li>任何继承自 Throwable 的对象可以被作为异常抛出；异常信息通常经由异常类的类名体现，或者将更详细的异常信息保存在异常内部。</li>\n<li><code>Exception.printStackTrace()</code> 有带参数的版本，用于指定输出流。</li>\n<li><code>Throwable.fillInStackTrace()</code> 可以记录栈帧的当前状态。</li>\n<li><code>Throwable</code> 的 stackTace 中保存了一个数据，代表一个出错的调用栈，每个元素表示栈中的一帧。</li>\n<li>除了 RuntimeExcetion 及其子类，其他类型的异常都是由编译器强制约束需要被捕获的；RuntimeException 往往代表的是编程错误，比如错误的调用参数。</li>\n<li>C++ 没有 finally 结构，C++ 依赖析构函数实现类似的效果；在 try 块中无论执行 return、break、continue 等任何语句，finall 代码块都会被执行。</li>\n<li>Java 在设计时有缺陷，某些写法会造成异常丢失，例如在 finally 里面再次抛出异常或者执行 return 语句都会似的原本抛出的异常无法被开发者和外层代码发现（除非单步调试）。相比之下，C++ 禁止在一个异常还没处理完毕之前，抛出另一个异常。</li>\n<li>当函数的异常说明列表遇到 override 时，总体规则就是 override 方法的异常说明列表需要是基类异常说明列表的子集（通俗来说，就是在继承和 override 的过程中，异常说明列表只能越变越小）;但是构造函数是个特例，子类构造函数的异常说明列表需要时父类构造函数的异常说明列表的超集，同时在子类构造函数中不能捕获父类构造函数抛出的异常。</li>\n<li>override 方法可以抛出父类方法异常列表中某个异常的子类。</li>\n<li>函数签名只包括函数名和参数列表，而不包含异常列表，所以不是只改变异常列表来重载方法。</li>\n<li>如果构造函数包含会抛出异常的代码，需要很仔细的处理，只是捕获异常可能会导致对象构造的不完整；尽量不要让构造函数包含会抛出异常的代码。</li>\n<li>作者并不喜欢 checked exception，因为强制开发者处理自己不了解的异常，可能会导致最后吞掉异常；提到了一种通用的处理方法，捕获 checked exception 然后用其创建 RuntimeException 再抛出，但这种方法也不应该滥用。</li>\n</ul>\n<p>13</p>\n<ul>\n<li>编译器会将连续的字符串 ‘+’ 操作符优化为 StringBuilder，以防止反复创建字符串对象；不过当有循环调用时，也会反复创建 StringBuilder 对象，所以这时不要依赖编译器优化，自己创建 StringBuilder 来处理。</li>\n<li>当对象引用和字符串做 ‘+’ 操作符时，会自动调用对象的的 <code>toString()</code> 方法。</li>\n<li>格式化输出<ul>\n<li>Java 为 PrintStream 和 PrintWriter 类(<code>System.out</code>就是这种类型的对象)引入了 <code>format()</code> 和 <code>printf()</code> 方法来支持格式和输出，两个方法是等价的。</li>\n<li>Java 的格式化输出最终都是由 Formatter 类实现，可以通过输出流来创建一个 Formatter 对象，调用其 <code>format()</code> 方法向输出流进行格式化输出，这是完成格式化输出的另一个选择。</li>\n<li>格式化输出的样式语法为 <code>%[&#123;参数index&#125;$][&#123;flag&#125;][&#123;宽度&#125;][.&#123;精度&#125;]&#123;参数类型&#125;</code>。例如<code>%2$-16.2f</code>，其中<code>-16</code> 表示宽度为16左对齐，默认为右对齐。</li>\n<li><code>String.format()</code> 方法是一个静态方法，返回一个格式化字符串对象，当然也是通过 Formatter 类实现的。</li>\n</ul>\n</li>\n<li>正则表达式<ul>\n<li>在 Java 中正则表达式的转意符为 <code>\\\\</code>，其与意为插入一个正则表达式的反斜杠，例如 <code>\\\\d</code> 表示正则匹配一个数字。</li>\n<li><code>String.matches()</code> 可以判断是否正则匹配；<code>String.split()</code> 按正则切分；<code>String.replace()</code> 和 <code>String.replaceAll()</code> 可以按正则替换。</li>\n<li><code>Pattern.compile()</code> 方法编译一个正则表达式，可以生成 Pattern 对象，对其调用 <code>Pattern.matcher()</code> 方法可以返回一个 Matcher 对象，表示正则匹配的结果.</li>\n<li><code>Pattern.split()</code> 方法可以用于切分字符串。</li>\n<li>Matcher 提供了 <code>replaceFirst()</code> 和 <code>replaceAll()</code> 用于替换匹配部分。还有更强大的 <code>appendReplacement()</code> 和 <code>appendTail()</code> 用于渐进是式的替换。</li>\n<li><code>Matcher.reset()</code> 可以重置其匹配的字符串。</li>\n</ul>\n</li>\n<li>Scanner<ul>\n<li>Scanner 通过 File，InputStream，String 等任何实现了 Readable 接口的对象构建，用于方便的类型化读取（有点像 C 里面的 scanf() 函数）。它提供了 <code>nextLine()</code> 、 <code>nextInt()</code>、<code>nextDouble()</code> 等方法。</li>\n<li>默认情况下 Scanner 根据空白字符分词，可以调用 <code>Scanner.useDelimiter()</code> 方法，传入一个正则表达式来指定分词方式。例如 <code>Scanner a.useDelimiter(&quot;\\\\s*,\\\\s*&quot;)</code>。Scanner 提供了 <code>next()</code>、<code>hasNext</code>、<code>match()</code> 等方法来逐个读取正则匹配结果。</li>\n<li>StringTokenizer，是 Java5 之前的提供的类，功能和 Scanner 类似；它可以视为被废弃了。</li>\n</ul>\n</li>\n</ul>\n<p>14</p>\n<ul>\n<li><code>Class.newInstance()</code> 成功执行的前提是类一定要有默认构造器。</li>\n<li>类加载分为三个阶段：加载，读取 .class 文件中的字节码，创建 Class 对象；链接，验证字节码，为静态属性分配存储空间；初始化，执行静态构造器和静态初始化代码块。</li>\n<li>类的初始化阶段被设计成尽可能 lazy，通过 “.class” 获取对 Class 对象引用时并不会触发类的初始化阶段，甚至引用类所包含的编译期常量也不会触发初始化阶段；通过 <code>Class.forName()</code> 获取 Class 对象的引用总能触发初始化阶段。</li>\n<li>Class 类支持泛型参数；Class&lt;?&gt; 和 Class 是等价的，但前者更好，因为它明确表示可以匹配任何类型。</li>\n<li><code>Class.cast()</code> 方法可以显示的执行强制转型操作，尽管需要使用这种方式的的情况比较少见。</li>\n<li><code>Class.isInstance()</code> 实现了和 instanceof 语句相同的功能；<code>Class.isAssignableFrom()</code> 提供了 instanceof 语意之外的另一种类型比较功能。</li>\n<li>运行时类型信息和反射这些工具，给开发者提供了破坏封装的方式，使他们可以调用一些原本被愿意被暴露的 api；使用反射再运行时修改 final 成员变量不会成功，虽然也不会抛出异常。</li>\n<li>尽量使用多态而不是 RTTI。 </li>\n</ul>\n<p>15</p>\n<ul>\n<li>基本类型不能作为 java 范型的类型参数(需要使用包装类型，如 Integer);但需要注意自动包装机制不能对数组起效果，例如 <code>int[]</code> 无法被自动包装成 <code>Integer[]</code>。</li>\n<li>如果可以使用泛型方法来替代泛型类，那么就选择泛型方法；构造函数也可以是泛型方法。</li>\n<li>static 方法无法访问泛型类的类型参数，如果想要使 static 方法具有泛型能力，就必须使其成为泛型方法。</li>\n<li>定义泛型方法需要将泛型参数列表声明放在<strong>返回值</strong>前面。</li>\n<li>通常来说泛型方法依赖类型推断，也可以在’.’操作符和方法名之间插入泛型参数列表来显示制定类型，例如<code>A.&lt;T,K&gt;a()</code>。</li>\n<li>参数化的泛型类可以被向上转型成无参数的泛型类，编译器不会 warning，例如 <code>A = new A&lt;T,K&gt;()</code>；但是反向转型编译器会有 warning。</li>\n<li><code>Array.newInstance()</code> 可以借由类型来创建数组。</li>\n<li>了解技术的边界，是成为高级程序员的条件。</li>\n<li>接口可以支持泛型；可以创建带泛型参数的匿名内部类。</li>\n<li>因为类型擦除的存在，关于泛型参数的信息只能在静态类型检查时获得，在此之后泛型类型会被替换为泛型类型上界（使用 <code>&lt;T extends ClassA&gt;</code> 的语法指定泛型类的类型上界），泛型代码将无从得知泛型参数的具体类型是什么。</li>\n<li>补偿泛型类型信息缺失的方式：<ul>\n<li>将泛型参数的 <code>Class&lt;T&gt;</code> 作为参数传递到泛型代码中。</li>\n<li>使用工厂类代替泛型参数类型的构造函数。</li>\n<li>无法使用泛型参数创建泛型类型的数组，最终它们都会是 <code>Object[]</code> 类型的数组；使用 <code>List</code> 代替数组或者使用 <code>Array.newInstance()</code> 创建数组。</li>\n</ul>\n</li>\n<li>不要让编译器报出不需要处理警告，而是用 <code>@SuppressWarnings</code> 去压制它们，否则无用的警告会稀释真正值得注意的警告。</li>\n<li>可以通过 <code>Type&lt;T extends A &amp; B &amp; C&gt;</code> 来给泛型参数指定多个上界，上界中只能有一个是 class 其他需要是 interface，其中 class 必须排在多个上界的最前面；可以在继承泛型类的时候添加上界，例如 <code>TypaB&lt;T extends C&gt; extends TypeA&lt;T&gt;</code>。</li>\n<li>数组可以向上转型而不会编译期报错，例如 <code>Base[] array = Derived[]</code>（但是 <code>array = new Base()</code> 会造成运行时异常）；泛型类则不能向上转型，<code>Generic&lt;Base&gt; generic = Generic&lt;Derived&gt;</code> 无法通过编译。</li>\n<li>可以通过通配符的方式完成泛型向上转型，例如 <code>Generic&lt;? extends Base&gt; generic = Generic&lt;Derived&gt;</code> 。</li>\n<li>用通配符作为泛型参数存在限制，编译器拒绝函数参数列表中涉及通配符的函数调用，但是通配符可以作为函数的返回值；即通配符作为泛型参数之后，泛型参数对象不能被传入，只能被传出。</li>\n<li>可以将泛型类的函数参数声明为 <code>Object</code> 而不是 <code>T</code>，参数传入就不会受通配符影响。</li>\n<li>和 “extend” 通配符相对的，<code>Type&lt;? super A&gt;</code> 通配符可以出现在函数参数列表中。<code>Type&lt;? super A&gt;</code> 可以被称为泛型参数下界，任何继承自下界类的类对象，都可以作为传入参数的合法值，下界类的父类对象作为参数传入，则会引发编译期报错。</li>\n<li>下界声明只能用在通配符泛型中，不能用在确切类型泛型，<code>Type&lt;T super A&gt;</code> 这种声明不能通过编译。</li>\n<li>上界通配符解决了向上转型时泛型参数类型传出问题，下界通配符解决了向上转型时泛型参数类型传入问题。</li>\n<li>无界通配符 <code>Type&lt;?&gt;</code> 看上去和非泛型类型（泛型参数等于 Object）差不多，但是无界通配符提供了更好的编译时检查，而非泛型类型则放弃了编译时检查：<ul>\n<li><code>Type&lt;?&gt;</code> 拒绝通配符类型作为参数传入，而 <code>Type</code> 则将所有传入参数转为 Object。</li>\n<li><code>Type&lt;?&gt;</code> 在转型成泛型参数不同的参数化泛型时，编译器会报错，<code>Type</code> 则只会造成 warning。</li>\n</ul>\n</li>\n<li>确切类型泛型没有传入传出的限制，但是通配符泛型类型可以接受范围更广的参数化泛型。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><ul>\n<li>Java中没有unsigned 数值类型(char是unsigned)。</li>\n<li>char是16位的，值域为<code>\\u0000</code>-<code>\\uffff</code>。</li>\n<li>Java中浮点数采用IEEE754格式，float的值域为<code>-2^127</code>-<code>2^127</code>，但只保证24个二进制位的精度(即对于整数而言float只能保证<code>2^24</code>以内的数字能精确表示)；double的值域为<code>-2^1023</code>-<code>2^1023</code>，但只保证53个二进制位的精度。</li>\n<li><code>java.lang</code>这个包会被自动import到源码。</li>\n<li>javadoc中可以使用HTML标签，但不要使用标题标签。</li>\n</ul>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><ul>\n<li>Java中指数计数法如：<code>float a = 1.27e16f</code>，其中<code>e</code>代表10的次方数。</li>\n<li>0x开头表示16进制数字，0开头表示8进制数字。</li>\n<li>位操作<code>&amp;</code>与、<code>|</code>或、<code>^</code>异或、<code>～</code>非，其中<code>～</code>是一元操作符；<code>&amp;=</code>、<code>|=</code>、<code>^=</code>都是合法的。</li>\n<li>位移操作符只对整数类型有效，char、short、byte会被转成int再做位移操作，long型则直接做位移操作。对于int型，位移操作符右侧值只有后5位有效，因为<code>2^5 = 32</code>位移不会超过32位；对于long型，位移操作符右侧值只有后6位有效。</li>\n<li>对char/short/byte使用算数操作符或者位操作符，都会使其提升为int。</li>\n<li>break／continue使用label。可以在迭代语句(必须紧贴迭代语句)之前声明label，<code>break &lt;label&gt;;</code>和<code>continue &lt;label&gt;</code>有助于跳出多层循环。例如：<code>label1: while () &#123; while() &#123; break label1;&#125; &#125;</code>。</li>\n</ul>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><ul>\n<li>当基本类型自动提升机制和重载相互作用时，基本会提升为最相近基本类型；char型是个例外，他会被直接提升为int型。</li>\n<li>可以在构造函数中通过this()调用其他构造函数，但是这种调用只能使用一次并且处于构造函数的最开始处；通过this()调用构造函数的语法只在构造函数中成立，在其他函数中编译器不会试图去这样解释this。</li>\n<li>finalize()一般不被鼓励使用，一种用法是在对象销毁时检查是否已经释放资源(诸如文件、链接等)，检验失败时打印警告log(抛出异常?)。</li>\n<li>类的属性的初始化的执行顺序取决于属性定义的顺序。</li>\n<li>实例初始化，其语法和<code>static &#123; ... &#125;</code>类似、但是去掉static关键字；这段代码执行于对象创建之后 &amp; 任意一个构造函数之前。在有多个构造函数的时候，可以执行一些公用的初始化逻辑。</li>\n<li>Java中数组的长度是不可变的(C++难道不是么…)，容器用多了不要忘记这一点；数组成员默认会被初始化为0。</li>\n<li>在可变参数列表(长度可变)没有特定的语法支持之前，可以通过传递数组来实现；在JavaSE5中，提供了可变参数列表的语法支持。但是当你获得了可变参数，实际还是获得了一个数组；编译器同时支持把数组当作<em>可变参数列表</em>来传递给方法。</li>\n<li>不同类型的可变参数列表和重载结合时，会变得很晦涩，所以尽量只在一个重载上使用可变参数。</li>\n</ul>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><ul>\n<li>每个类–包括内部类、同一文件中的多个类–都会生成一个单独的.class文件。</li>\n<li>Java编译器会以CLASSPATH为根目录，以包名为路径去寻找所需要的.class文件。</li>\n<li>类成员访问权限修饰词包括public、protected、private和包访问权限(无修饰词)。被包访问权修饰的类成员，在同一包内可见，包外不可见；protected修饰词也提供了包访问权限，同时提供了继承访问权限。</li>\n<li>如果不使用package定义类所属的包名，那么类将被置于其文件所在目录的默认包中。</li>\n<li>访问权限修饰词也可以用于修饰类。</li>\n<li>非内部类只能用public或者包访问权限修饰(不能是private或protected的)；包访问权限修饰的类的所有方法不能在包外被访问(大概如此…)。</li>\n<li>每个文件中只能包含一个public类；public类必须与文件名相同；如果文件中没有public类那么文件可以随意命名。</li>\n</ul>\n<h2 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h2><ul>\n<li>当对象需要被隐式转换成String时，<strong>编译器</strong>会调用其toString()方法。</li>\n<li>工程中可以有多个类包含main方法，需要在执行时指定调用哪个类的main方法；可以显式调用其他类的main方法；即便类具有包访问权限，其他包中的类还是可以调用它的main方法。</li>\n<li>当创建一个继承类的对象时，这个对象中包含了一个基类的对象。</li>\n<li>创建继承类时，想要正确的初始化基类，唯一的方法就是调用基类 的某个构造函数：<ul>\n<li>在不显式调用基类的构造函数的情况下，编译器(应该是编译器负责的)会自动调用基类的默认构造函数(不带参数的)。</li>\n<li>编译器合成的默认构造函数也会调用基类的默认构造函数。</li>\n<li>如果基类没有默认构造函数，则必须显式的调用基类的构造函数，否则编译器会报错。</li>\n<li>显式的调用基类的构造函数(包括带参数的构造函数和默认构造函数)，必须发生在继承类构造函数的第一行，否则会编译报错。</li>\n</ul>\n</li>\n<li>继承类对象的引用可以转型成基类对象的引用，这个被称为向上转型。</li>\n<li>final关键字可以修饰数据、方法和类：<ul>\n<li>final修饰属性时，如果属性是类对象，则表示这个引用不可改变，而所被引用的对象是可以改变的；Java没有提供C++的const关键字保证类对象不被改变的机制；注意数组也是类对象也符合类对象的规则。</li>\n<li>final修饰方法时，保证方法不会再继承类中被覆盖。private方法默认是final的，但其实继承类也看不到它，所以继承类依然可以定义一个与父类private方法同名的新方法。</li>\n<li>final修饰类时，保证类不会被继承。</li>\n</ul>\n</li>\n<li>在某些(早期)的Java实现中，final修饰的方法也起到了C++中inline关键字的作用来优化执行效率，但这导致的代码膨胀反而有时会降低效率；更新的Java虚拟机会探测并消除这种inline，所以无需再把final视为inline的一种方式了。</li>\n<li>类加载和对象初始化顺序：基类加载 -&gt; 基类静态初始化 -&gt; 继承类加载 -&gt; 继承类静态初始化 -&gt; 将被分配的内存初始化为0 -&gt; 基类对象的属性初始化 -&gt; 基类对象构造函数 -&gt; 继承类对象的属性初始化 -&gt; 继承类对象构造函数。 </li>\n</ul>\n<h2 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8\"></a>8</h2><ul>\n<li>将方法调用(函数调用语句)和方法主体(函数所处的内存地址)关联起来的过程叫绑定，绑定包括前期绑定和动态绑定。前期绑定是在编译时发生的，而动态绑定是在运行时根据对象类型来进行的。</li>\n<li>不同语言实现动态绑定的方式略有不同。</li>\n<li>Java语言中除了static方法和final方法(当然还有private方法，但上一章说过private方法默认是final方法)是采用前期绑定，其他方法都使用的动态绑定。所以final关键字除了防止override之外，还有关闭动态绑定的作用。</li>\n<li>一种错误是尝试override定义为private的方法。因为private方法是final的，所以override和多态是不会发生的，而实际上发生的是在导出类中多了一个和基类private方法同名的方法。所以通过基类引用调用这个private方法时，调用的是基类函数；通过导出类引用调用时，实际上是调用导出类中的同名方法。从private方法是前期绑定的这个原理上，也很好理解这个行为。</li>\n<li>在导出类中，尽量不要使用和基类private方法相同的方法名。</li>\n<li>构造函数自然不会有多态的特性；实际上构造函数应该归类于static方法，虽然它没有static关键字。</li>\n<li>在上一章介绍了对象的构造顺序；如果需要定一个某种显式的析构(例如release())，其调用顺序应当和构造顺序恰恰相反(就如同C++的析构函数一样)。</li>\n<li>Java在构造函数中调用动态绑定的方法时，动态绑定是起作用的(和C++不同)，也就是说会调用导出类的方法；但要注意，这个时候导出类很可能还没有被构造，这可能会带来一些错误。</li>\n<li>作者认为C++处理构造函数内动态绑定函数调用的方式更为合理；所以在构造函数中应该尽量避免调用方法，或者只调用private或final方法。</li>\n<li>从JavaSE5开始，override方法的返回类型，可以是父类中被override方法的返回类型的导出类(有点绕口，但返回值不是函数signature的一部分)。</li>\n<li>在Java中使用强制类型转换(括号转换)时会进行类型检查(C++不会)，如果例如在向下转型时类型不符合，会抛出ClassCastException。</li>\n</ul>\n<h2 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h2><ul>\n<li>如果类中包含abstract方法，那么类必须也被声明为abstract的，否则会在编译时报错；但是声明为abstract的类，不是必须包含abstract方法，可能仅仅是想阻止该类型实例化。</li>\n<li>interface自身的访问控制和class一样，可以用public修饰或者不加修饰(包访问权限)；interface的属性默认是static且final的；interface的方法默认是public的。</li>\n<li>在Java继承中，导出类override的方法的访问权限必须大于等于父类中相同方法的访问权限(override某个public方法时，覆盖实现的方法也必须是public的)。</li>\n<li>当extends和implements同时作用于一个类时，extends必须写在前面。</li>\n<li>接口是用来建立类与类直接的方法调用协议。</li>\n<li>Java的抽象类只能单根继承；相对于抽象类而言，接口还提供的部分多重继承的特性，从而比抽象类更灵活。</li>\n<li>在定义基类时应该优先考虑接口，其次才是抽象类。</li>\n<li>与类的单根继承不同，接口可以extends多个接口。</li>\n<li>在多重继承的过程中(基类和接口)，如果遇到两个方法签名相同但是返回值不同，会发生编译错误。</li>\n<li>接口也很适合用来声明大量常量；在Java5推出enum之前，接口被用作enum的替代品来声明常量。</li>\n<li>接口可以声明在类内部，类内部的接口还可以是private的(除了public和包访问权限外)；接口也可能声明在接口内部，接口内部的接口默认是public的。</li>\n</ul>\n<h2 id=\"10\"><a href=\"#10\" class=\"headerlink\" title=\"10\"></a>10</h2><ul>\n<li>非静态内部类可以访问其外围类的<em>一切</em>元素，与C++不同(C++的内部类只有命名空间的作用)。</li>\n<li>如果想在”非静态内部类的主人(外围类)”以外的地方创建非静态内部类的实例，可以使用”外围类实例.new”这样的语法；例如<code>A a = new A();A.Inner inner = a.new Inner();</code>。(注意构造函数无需用<code>A.Inner()</code>,事实上这样用编译不过)</li>\n<li>可以在方法中或者方法的某个作用域中(大括号包裹的范围)定义类，那么这个类的可见性就限制在方法或作用域内部；这样的定义的类不能用访问控制关键字修饰。如果类被定义在静态方法中，那就是静态内部类；如果被定义在成员方法中，那就是非静态内部类，即内部类。</li>\n<li>匿名内部类可以继承基类或者实现接口，但是只能在继承类和实现接口之间二选一，并且不能继承多个接口。</li>\n<li>匿名内部类只具有默认构造函数，但不能定义自己的构造函数；可以使用实例静代码块(非静态代码块)来实现类似构造函数的效果。</li>\n<li>内部类不能具有static属性，也不能包含嵌套类，但是嵌套类可以有static属性和包含嵌套类。</li>\n<li>可以在接口中定义内部类，接口中的内部类默认是public和static的，即公共嵌套类；这是在接口中包含一些代码实现的方式。</li>\n<li>无论内部类被嵌套多少层，它都能访问所有外围类的所有成员。多层嵌套的内部类可以用<code>Father.A.B var = fatherinstance.new B()</code>这样的语法创建。</li>\n<li>内部类作为外围类的一部分，某种程度上给了外围类一种多重继承的能力，即用多个内部类继承多个抽象类。</li>\n<li>如果想让某个独立的类例如 A 类继承其他某个类的内部类例如 B.C ，那么 A 类的构造函数需要如下语法才能通过编译<code>class A extends B.C &#123;  A(B b) &#123; b.super() &#125; &#125;</code>。这个一个奇怪的语法。</li>\n<li>不存在继承外围类并override内部类的语法，例如有内部类A.B，C继承A并声明内部类C.B，那么A.B和C.B是两个命名空间中的两个不相关的类(除了名字相同)，不存在override关系。</li>\n</ul>\n<h2 id=\"11\"><a href=\"#11\" class=\"headerlink\" title=\"11\"></a>11</h2><ul>\n<li>Arrays.asList()方法返回的List长度时不可变的，对这个List调用add()或remove()都会抛出异常。</li>\n<li>HashSet是不保证顺序的，LinkedHashSet按照插入顺序保存，TreeSet按照比较结果升序保存；同样的HashMap是不保证顺序的，LinkedHashMap按照插入顺序保存，TreeMap按照比较结果升序保存。Hash<em>存取都是最快的，LinkedHash</em>取几乎和Hask*一样快。</li>\n<li>迭代器设计的初衷，是为了以统一的方式遍历所有容器，这样即使容易类型发生的改变，遍历相关的代码也无需修改。</li>\n<li>List.listIterator()返回ListIterator，ListIterator是Iterator的子类型。ListIterator支持双向移动，而Iterator不行。</li>\n<li>LinkedList实现的Queue接口（实际上是Deque接口，Deque extends from Queue)。</li>\n<li>foreach语法之所以能作用于容器是因为Collection扩展了Iterable接口。foreach可以作用于任何实现了Iterable的类型和数组，但这不意味数组是Iterable或会被自动转型成Iterable。</li>\n<li><strong>不要使用</strong>Java1.0中提供的Vector、Hashtable、Stack这几个容器。</li>\n</ul>\n<h2 id=\"12\"><a href=\"#12\" class=\"headerlink\" title=\"12\"></a>12</h2><ul>\n<li>发现程序错误的最理想时机是编译时。</li>\n<li>所有标准异常类都包含以字符串为参数的构造函数，字符串代表了异常信息的描述。</li>\n<li>任何继承自 Throwable 的对象可以被作为异常抛出；异常信息通常经由异常类的类名体现，或者将更详细的异常信息保存在异常内部。</li>\n<li><code>Exception.printStackTrace()</code> 有带参数的版本，用于指定输出流。</li>\n<li><code>Throwable.fillInStackTrace()</code> 可以记录栈帧的当前状态。</li>\n<li><code>Throwable</code> 的 stackTace 中保存了一个数据，代表一个出错的调用栈，每个元素表示栈中的一帧。</li>\n<li>除了 RuntimeExcetion 及其子类，其他类型的异常都是由编译器强制约束需要被捕获的；RuntimeException 往往代表的是编程错误，比如错误的调用参数。</li>\n<li>C++ 没有 finally 结构，C++ 依赖析构函数实现类似的效果；在 try 块中无论执行 return、break、continue 等任何语句，finall 代码块都会被执行。</li>\n<li>Java 在设计时有缺陷，某些写法会造成异常丢失，例如在 finally 里面再次抛出异常或者执行 return 语句都会似的原本抛出的异常无法被开发者和外层代码发现（除非单步调试）。相比之下，C++ 禁止在一个异常还没处理完毕之前，抛出另一个异常。</li>\n<li>当函数的异常说明列表遇到 override 时，总体规则就是 override 方法的异常说明列表需要是基类异常说明列表的子集（通俗来说，就是在继承和 override 的过程中，异常说明列表只能越变越小）;但是构造函数是个特例，子类构造函数的异常说明列表需要时父类构造函数的异常说明列表的超集，同时在子类构造函数中不能捕获父类构造函数抛出的异常。</li>\n<li>override 方法可以抛出父类方法异常列表中某个异常的子类。</li>\n<li>函数签名只包括函数名和参数列表，而不包含异常列表，所以不是只改变异常列表来重载方法。</li>\n<li>如果构造函数包含会抛出异常的代码，需要很仔细的处理，只是捕获异常可能会导致对象构造的不完整；尽量不要让构造函数包含会抛出异常的代码。</li>\n<li>作者并不喜欢 checked exception，因为强制开发者处理自己不了解的异常，可能会导致最后吞掉异常；提到了一种通用的处理方法，捕获 checked exception 然后用其创建 RuntimeException 再抛出，但这种方法也不应该滥用。</li>\n</ul>\n<p>13</p>\n<ul>\n<li>编译器会将连续的字符串 ‘+’ 操作符优化为 StringBuilder，以防止反复创建字符串对象；不过当有循环调用时，也会反复创建 StringBuilder 对象，所以这时不要依赖编译器优化，自己创建 StringBuilder 来处理。</li>\n<li>当对象引用和字符串做 ‘+’ 操作符时，会自动调用对象的的 <code>toString()</code> 方法。</li>\n<li>格式化输出<ul>\n<li>Java 为 PrintStream 和 PrintWriter 类(<code>System.out</code>就是这种类型的对象)引入了 <code>format()</code> 和 <code>printf()</code> 方法来支持格式和输出，两个方法是等价的。</li>\n<li>Java 的格式化输出最终都是由 Formatter 类实现，可以通过输出流来创建一个 Formatter 对象，调用其 <code>format()</code> 方法向输出流进行格式化输出，这是完成格式化输出的另一个选择。</li>\n<li>格式化输出的样式语法为 <code>%[&#123;参数index&#125;$][&#123;flag&#125;][&#123;宽度&#125;][.&#123;精度&#125;]&#123;参数类型&#125;</code>。例如<code>%2$-16.2f</code>，其中<code>-16</code> 表示宽度为16左对齐，默认为右对齐。</li>\n<li><code>String.format()</code> 方法是一个静态方法，返回一个格式化字符串对象，当然也是通过 Formatter 类实现的。</li>\n</ul>\n</li>\n<li>正则表达式<ul>\n<li>在 Java 中正则表达式的转意符为 <code>\\\\</code>，其与意为插入一个正则表达式的反斜杠，例如 <code>\\\\d</code> 表示正则匹配一个数字。</li>\n<li><code>String.matches()</code> 可以判断是否正则匹配；<code>String.split()</code> 按正则切分；<code>String.replace()</code> 和 <code>String.replaceAll()</code> 可以按正则替换。</li>\n<li><code>Pattern.compile()</code> 方法编译一个正则表达式，可以生成 Pattern 对象，对其调用 <code>Pattern.matcher()</code> 方法可以返回一个 Matcher 对象，表示正则匹配的结果.</li>\n<li><code>Pattern.split()</code> 方法可以用于切分字符串。</li>\n<li>Matcher 提供了 <code>replaceFirst()</code> 和 <code>replaceAll()</code> 用于替换匹配部分。还有更强大的 <code>appendReplacement()</code> 和 <code>appendTail()</code> 用于渐进是式的替换。</li>\n<li><code>Matcher.reset()</code> 可以重置其匹配的字符串。</li>\n</ul>\n</li>\n<li>Scanner<ul>\n<li>Scanner 通过 File，InputStream，String 等任何实现了 Readable 接口的对象构建，用于方便的类型化读取（有点像 C 里面的 scanf() 函数）。它提供了 <code>nextLine()</code> 、 <code>nextInt()</code>、<code>nextDouble()</code> 等方法。</li>\n<li>默认情况下 Scanner 根据空白字符分词，可以调用 <code>Scanner.useDelimiter()</code> 方法，传入一个正则表达式来指定分词方式。例如 <code>Scanner a.useDelimiter(&quot;\\\\s*,\\\\s*&quot;)</code>。Scanner 提供了 <code>next()</code>、<code>hasNext</code>、<code>match()</code> 等方法来逐个读取正则匹配结果。</li>\n<li>StringTokenizer，是 Java5 之前的提供的类，功能和 Scanner 类似；它可以视为被废弃了。</li>\n</ul>\n</li>\n</ul>\n<p>14</p>\n<ul>\n<li><code>Class.newInstance()</code> 成功执行的前提是类一定要有默认构造器。</li>\n<li>类加载分为三个阶段：加载，读取 .class 文件中的字节码，创建 Class 对象；链接，验证字节码，为静态属性分配存储空间；初始化，执行静态构造器和静态初始化代码块。</li>\n<li>类的初始化阶段被设计成尽可能 lazy，通过 “.class” 获取对 Class 对象引用时并不会触发类的初始化阶段，甚至引用类所包含的编译期常量也不会触发初始化阶段；通过 <code>Class.forName()</code> 获取 Class 对象的引用总能触发初始化阶段。</li>\n<li>Class 类支持泛型参数；Class&lt;?&gt; 和 Class 是等价的，但前者更好，因为它明确表示可以匹配任何类型。</li>\n<li><code>Class.cast()</code> 方法可以显示的执行强制转型操作，尽管需要使用这种方式的的情况比较少见。</li>\n<li><code>Class.isInstance()</code> 实现了和 instanceof 语句相同的功能；<code>Class.isAssignableFrom()</code> 提供了 instanceof 语意之外的另一种类型比较功能。</li>\n<li>运行时类型信息和反射这些工具，给开发者提供了破坏封装的方式，使他们可以调用一些原本被愿意被暴露的 api；使用反射再运行时修改 final 成员变量不会成功，虽然也不会抛出异常。</li>\n<li>尽量使用多态而不是 RTTI。 </li>\n</ul>\n<p>15</p>\n<ul>\n<li>基本类型不能作为 java 范型的类型参数(需要使用包装类型，如 Integer);但需要注意自动包装机制不能对数组起效果，例如 <code>int[]</code> 无法被自动包装成 <code>Integer[]</code>。</li>\n<li>如果可以使用泛型方法来替代泛型类，那么就选择泛型方法；构造函数也可以是泛型方法。</li>\n<li>static 方法无法访问泛型类的类型参数，如果想要使 static 方法具有泛型能力，就必须使其成为泛型方法。</li>\n<li>定义泛型方法需要将泛型参数列表声明放在<strong>返回值</strong>前面。</li>\n<li>通常来说泛型方法依赖类型推断，也可以在’.’操作符和方法名之间插入泛型参数列表来显示制定类型，例如<code>A.&lt;T,K&gt;a()</code>。</li>\n<li>参数化的泛型类可以被向上转型成无参数的泛型类，编译器不会 warning，例如 <code>A = new A&lt;T,K&gt;()</code>；但是反向转型编译器会有 warning。</li>\n<li><code>Array.newInstance()</code> 可以借由类型来创建数组。</li>\n<li>了解技术的边界，是成为高级程序员的条件。</li>\n<li>接口可以支持泛型；可以创建带泛型参数的匿名内部类。</li>\n<li>因为类型擦除的存在，关于泛型参数的信息只能在静态类型检查时获得，在此之后泛型类型会被替换为泛型类型上界（使用 <code>&lt;T extends ClassA&gt;</code> 的语法指定泛型类的类型上界），泛型代码将无从得知泛型参数的具体类型是什么。</li>\n<li>补偿泛型类型信息缺失的方式：<ul>\n<li>将泛型参数的 <code>Class&lt;T&gt;</code> 作为参数传递到泛型代码中。</li>\n<li>使用工厂类代替泛型参数类型的构造函数。</li>\n<li>无法使用泛型参数创建泛型类型的数组，最终它们都会是 <code>Object[]</code> 类型的数组；使用 <code>List</code> 代替数组或者使用 <code>Array.newInstance()</code> 创建数组。</li>\n</ul>\n</li>\n<li>不要让编译器报出不需要处理警告，而是用 <code>@SuppressWarnings</code> 去压制它们，否则无用的警告会稀释真正值得注意的警告。</li>\n<li>可以通过 <code>Type&lt;T extends A &amp; B &amp; C&gt;</code> 来给泛型参数指定多个上界，上界中只能有一个是 class 其他需要是 interface，其中 class 必须排在多个上界的最前面；可以在继承泛型类的时候添加上界，例如 <code>TypaB&lt;T extends C&gt; extends TypeA&lt;T&gt;</code>。</li>\n<li>数组可以向上转型而不会编译期报错，例如 <code>Base[] array = Derived[]</code>（但是 <code>array = new Base()</code> 会造成运行时异常）；泛型类则不能向上转型，<code>Generic&lt;Base&gt; generic = Generic&lt;Derived&gt;</code> 无法通过编译。</li>\n<li>可以通过通配符的方式完成泛型向上转型，例如 <code>Generic&lt;? extends Base&gt; generic = Generic&lt;Derived&gt;</code> 。</li>\n<li>用通配符作为泛型参数存在限制，编译器拒绝函数参数列表中涉及通配符的函数调用，但是通配符可以作为函数的返回值；即通配符作为泛型参数之后，泛型参数对象不能被传入，只能被传出。</li>\n<li>可以将泛型类的函数参数声明为 <code>Object</code> 而不是 <code>T</code>，参数传入就不会受通配符影响。</li>\n<li>和 “extend” 通配符相对的，<code>Type&lt;? super A&gt;</code> 通配符可以出现在函数参数列表中。<code>Type&lt;? super A&gt;</code> 可以被称为泛型参数下界，任何继承自下界类的类对象，都可以作为传入参数的合法值，下界类的父类对象作为参数传入，则会引发编译期报错。</li>\n<li>下界声明只能用在通配符泛型中，不能用在确切类型泛型，<code>Type&lt;T super A&gt;</code> 这种声明不能通过编译。</li>\n<li>上界通配符解决了向上转型时泛型参数类型传出问题，下界通配符解决了向上转型时泛型参数类型传入问题。</li>\n<li>无界通配符 <code>Type&lt;?&gt;</code> 看上去和非泛型类型（泛型参数等于 Object）差不多，但是无界通配符提供了更好的编译时检查，而非泛型类型则放弃了编译时检查：<ul>\n<li><code>Type&lt;?&gt;</code> 拒绝通配符类型作为参数传入，而 <code>Type</code> 则将所有传入参数转为 Object。</li>\n<li><code>Type&lt;?&gt;</code> 在转型成泛型参数不同的参数化泛型时，编译器会报错，<code>Type</code> 则只会造成 warning。</li>\n</ul>\n</li>\n<li>确切类型泛型没有传入传出的限制，但是通配符泛型类型可以接受范围更广的参数化泛型。</li>\n</ul>\n"},{"title":"Android 编译流程概览与编译入口源码分析","catalog":true,"subtitle":"Android 编译源码学习笔记 0x01","header-img":"/img/header_img/platform-source-header.jpg","_content":"\n## Why ?\n目标：使 Android 编译过程由黑盒变为白盒。  \n好处： \n\n* 理解 android plugin 接口含义和能力，更好的编写编译脚本。  \n* 熟悉 android gradle 任务树，方便在编写 gradle 插件时 hook android 编译任务。 \n* 看懂编译中间产物、以及熟练的调试编译源码，以便在开发时定位编译时发生的问题。 \n* 了解 android 编译 toolChain 和 编译输出，是进一步学习 Android Runtime 的基础。 \n\n## 行文\n版本：源码基于 android plugin 3.0.0，gradle 4.1。   \n主流程：   \n首先，在本篇概览中会概述 Android 的编译流程，浏览 android plugin 的入口源码。   \n而后，分别详述编译流程中的各个阶段 ：针对该编译阶段所涉及的 plugin api、project 模型、编译任务、toolChain、输入以及输出进行纵向分析，可能会浏览该阶段编译任务以及 toolChain 的源码。   \n最后，会分析 application 工程和 library 工程在编译时的区别。   \n\n副流程：   \nAndroid 编译中涉及到了很多 Optional 的话题，这些话题会渗透到编译流程的各个阶段。将这些话题从主流程中分离出来，以切面的形式归纳为副流程分别单独学习，也许是更好的方式。   \n\n副流程也许会包括 (排在越后面，会被包括的可能性越小)：\n\n* Java8 support。\n* Kotlin。\n* AppBundle\n* 单元测试与集成测试。\n* Lint。\n* Ndk。\n* Instant Run。\n* DataBinding。\n* Wear & TV support。\n* IDE。\n\n\n## 结构\n\ngradle 编译脚本 &  -> plugin api -> project 模型 -> 编译任务树 & Transtrom 流 -> toolChain -> 中间产物文件流 -> 编译输出\n\n结构基础：gradle api、 gradle、android sdk。\n\n这一篇会包含 plugin api -> project 模型 -> 编译任务树 & Transtrom 流 三个部分；之后在各个编译流程流程中会涉及到 编译任务树 & Transtrom 流  -> toolChain -> 中间产物文件流。   \n\n## android plugin api 概览 \n\nplugin api 是 android 编译系统暴露给开发者的配置接口，以基于 gradle & groovy 的 DSL (Domain-specific language) 组织而成。plugin api 可以大致被划分为 plugin、extension、dsl model 三个部分：\n\n* plugin 是 android 编译系统的入口，开发者通过 apply plugin 来调用编译系统，进而完成暴露 plugin api，构建 project 模型，生成编译任务等一系列流程。\n* extension 是承载 dsl model 的对象，它通过 delegate 的方式挂载到扩 gradle project 上，方便开发者通过对其成员赋值，从而完成编译配置过程。 \n* dsl model 的接口繁多，是 plugin api 的主体，代表了 android 编译过程的各种配置参数。\n\n### plugins\n\n![Android-Gradle-Plugins](https://i.loli.net/2019/03/07/5c80c1f57f944.jpg)\n\n`BasePlugin` 有多个继承类型，各个继承类型对应了不同类型的 android plugin，以支持不同的 android 编译类型。\n\n* `AppPlugin` (com.android.application)，构建 app 工程。\n* `LibraryPlugin` (com.android.library)，构建 library 工程。\n* `FeaturePlugin` (com.android.feature)，构建 app-bundle。\n* `InstantAppPlugin` (com.android.instantapp)，执行 intant-run。\n* `TestPlugin` （com.android.test)，用单独工程执行 instrumented-test。\n\nandroid plugin 绝大部分配置过程代码都包含在 `BasePlugin` 中，`BasePlugin` 的各个子类仅仅创建并返回了类型不同的 `BaseExtension`、`VariantFactory`、`TaskManager` 实现类对象。基于这些不同的实现对象，使各种编译类型在 plugin api、project 模型和编译任务等方面略有不同。\n\n### extensions\n\n\n\n\n\n\n## android 的 project 模型概览\n\n## android 的编译任务树概览\n\n## 在读源码之前\n\n### 源码工程 -- :gradle 和 :gradle-core\n\n:gradle 包含了 android plugin 链接到 gradle project 的 anchor 类，即一些 plugin 和 extension 类，这里就是 android plugin 的入口。    \n:gradle-core 是 android plugin 的实现工程，里面包含了 project 模型的管理类、 构建任务树的管理类、任务的实现类等。 这些类被 :gralde 工程中的 plugin 调用，处理 开发者编译脚本向 extension 中提交的信息、建立 project 模型、创建 android task，并经过各类 android task 链接到 android 构建的 toolchain。    \n\n### 源码阅读的起点 -- `BasePlugin.apply()`\n\n`BasePlugin` 是所有 android plugin 的基类，`BasePlugin.apply()` 方法可以视为 android plugin 的程序入口。这个方法涵盖了 android plugin 配置阶段的全部过程， 以 `BasePlugin.apply()` 为起点可以了解 android plugin 工程模型的创建过程和任务树的创建过程。\n\n## 源码分析\n\n### `BasePlugin::apply()`\n\n* 进行一系列的 validate 检查。\n* 读取 gradle.properties 文件中所有与 android plugin 有关的配置，并根据这些配置初始化一些编译参数。\n* 调用`configureProject()`、`configureExtension()`、`createTasks()` 三个方法；这三个方法就是 android plugin 配置阶段的主体操作。\n\n```\n protected void apply(@NonNull Project project) {\n        ...\n\n        //AndroidBasePlugin 会被所有 plugin 类型 apply，它不做任何事情，只是方便判断是否有某种 android 的 plugin 类被 applay 过了。\n        project.getPluginManager().apply(AndroidBasePlugin.class);\n        \n        // 检查 builder.jar 的版本号是否和 android plugin 的版本号一致，否则抛异常。\n        // 如果使用了 'com.android.tools.build:gradle-experimental' 中的  gradle-experimental 插件，\n        // 并且其版本和 'com.android.tools.build:gradle' 的版本不一致，\n        // 那么就会出现 builder.jar 的版本号是否和 android plugin 的版本号不一致的情况。\n        // TODO: what's gradle-experimental\n        checkPluginVersion();\n\n        this.project = project;\n\n        // ProjectOptions 是一个 Immutable 模型对象，它包含了很多类型为 Option<String> 对象。\n        // ProjectOptions 实际上是一个 key-value 形式的配置表，包含了 gradle.properties 文件中所有与 android plugin 有关的配置。\n        // 各类配置被定义在 :gradle-core > com.android.build.gradle.options 包下面的枚举类中。\n        // 这些配置大多以 'android.' 开头，详见附表部分。\n        this.projectOptions = new ProjectOptions(project);\n\n        // 由  {@GradleProperties 'android.threadPoolSize'} 配置来设置 ExecutorSingleton 的线程池尺寸。\n        ExecutionConfigurationUtil.setThreadPoolSize(projectOptions);\n\n        //在 window 平台上，gradle 工程 根目录的绝对路径上不能有非ASCII字符，否则就抛出异常，原因参见 http://b.android.com/95744；可以配置{@GradleProperties 'android.overridePathCheck'} = true 屏蔽这个检查。\n        checkPathForErrors();\n\n        //gradle 工程中，不能存在两个同名的子工程，否则就抛出异常。\n        checkModulesForErrors();\n        \n        // PluginInitializer 用于验证两件事情：\n        // 在一次构建中，不同子工程使用的 android plugin 版本一致。\n        // 在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。\n        PluginInitializer.initialize(project, projectOptions);\n\n        // ProfilerInitializer 通过向 gradle 注册监听，记录*当前子工程*所有 gradle task 的执行时间。\n        // 当构建结束之后，将所记录的时间输出到 'project.getRootProject()/build/android-profile/profile-'YYYY-MM-dd-HH-mm-ss-SSS'.rawproto' 文件中。\n        // TODO: 这个文件的作用是什么？猜测是给 IDE 用的。\n        ProfilerInitializer.init(project, projectOptions);\n\n        ...\n\n        // 涵盖 BasePlugin 主体操作的三个 private 方法。 \n        configureProject()\n        configureExtension()\n        createTasks()\n    }\n```\n\n#### `PluginInitializer`\n\n`PluginInitializer` 这个类比较有意思，它的作用是验证 android plugin 在各个子工程之间一致性。具体来说包含如下两方面验证：\n* 在一次构建中，不同子工程使用的 android plugin 版本一致。\n* 在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。\n那么问题来了，无论是不同的子工程使用了不同的 android plugin 版本，还是 android plugin 的 class 文件被不同的 classloader 加载，都会在 jvm 中形成两套相互独立的 class，要如何检测这种情况呢。\n`PluginInitializer` 有两个静态变量分别负责上述两种检查，分别是 `projectToPluginVersionMap` 和 `loadedPluginClass`，这两个变量是通过 `JvmWideVariable` 获得的。`JvmWideVariable` 提供了一种直接在 jvm 创建对象的方式，并通过字符串 key 来获取对象引用。所以 `PluginInitializer` 的 `projectToPluginVersionMap` 和 `loadedPluginClass` 并不是和 class 绑定的静态对象，而是通过字符串 key 直接维护在 jvm 的堆中。只要不同版本的 android plugin 使用相同的 key 从 jvm 中创建和获取对象，那么即使是相互独立的 class 也能取得同一个对象，从而经由不同版本 android plugin 相互协作实现 `PluginInitializer` 所需验证的情况。\n可以看见源码中对于 key 常量有如下注释：\n\n>IMPORTANT: This variable's group, name, and type must not be changed across\nplugin versions.\n\n另外，什么情况下会发生 android plugin 被不同的 classloader 加载呢？源码的异常信息中给了如下解释，如果有兴趣可以看[issue链接](https://d.android.com/r/tools/buildscript-classpath-check.html)\n\n> Due to a limitation of Gradle’s new variant-aware dependency management, loading the Android Gradle plugin in different class loaders leads to a build error.   \n> This can occur when the buildscript classpaths that contain the Android Gradle plugin in sub-projects, or included projects in the case of composite builds, are set differently.   \n> To resolve this issue, add the Android Gradle plugin to only the buildscript classpath of the top-level build.gradle file.   \n> In the case of composite builds, also make sure the build script classpaths that contain the Android Gradle plugin are identical across the main and included projects.   \n> If you are using a version of Gradle that has fixed the issue, you can disable this check by setting android.enableBuildScriptClasspathCheck=false in the gradle.properties file.   \n> To learn more about this issue, go to https://d.android.com/r/tools/buildscript-classpath-check.html.   \n\n\n```\npublic final class PluginInitializer {\n\n    // Map<gradle project 对象 , android plugin 版本的> , 所用版本的 android plugin 共用一个对象，用于判断是否存在多个版本。\n    // IMPORTANT: This variable's group, name, and type must not be changed across plugin versions.\n    @NonNull\n    private static final ConcurrentMap<Object, String> projectToPluginVersionMap =\n            Verify.verifyNotNull(\n                    new JvmWideVariable<>(\n                                    \n                                    \"PLUGIN_VERSION_CHECK\",\n                                    \"PROJECT_TO_PLUGIN_VERSION\",\n                                    new TypeToken<ConcurrentMap<Object, String>>() {},\n                                    ConcurrentHashMap::new)\n                            .get());\n\n    // AndroidBasePlugin.class 的引用，对于同一个 android plugin 版本的多次加载而言，共用一个对象，用于判断同一个版本是否被多个 classloader 加载。\n    @NonNull\n    private static final AtomicReference<Class<?>> loadedPluginClass =\n            Verify.verifyNotNull(\n                    new JvmWideVariable<>(\n                                    PluginInitializer.class.getName(),\n                                    \"loadedPluginClass\",\n                                    Version.ANDROID_GRADLE_PLUGIN_VERSION,\n                                    new TypeToken<AtomicReference<Class<?>>>() {},\n                                    () -> new AtomicReference<>(null))\n                            .get());\n\n    public static void initialize(\n        \n        // BuildSessionImpl 提供了一整次 gradle 构建结束的监听 (例如一次命令行输入全部执行完成)。\n        // 这里注册监听，当一整次构建结束之后，重置 projectToPluginVersionMap 和 loadedPluginClass。\n        // 由于 gradle 有进程重用机制，多次构建可能发生在同一个进程；只需要保证在一整次构建中，版本一致性，所以构建完成后重置状态。\n        BuildSessionImpl.getSingleton().initialize(project.getGradle());\n        BuildSessionImpl.getSingleton()\n                .executeOnceWhenBuildFinished(\n                        PluginInitializer.class.getName(),\n                        \"resetPluginCheckVariables\",\n                        () -> {\n                            projectToPluginVersionMap.clear();\n                            loadedPluginClass.set(null);\n                        });\n\n        // 向 projectToPluginVersionMap 中写入当前工程对象和现在所执行的 android plugin 版本，如果 Map 中有两个不一样的 android plugin 版本，那么就抛出异常。\n        synchronized (projectToPluginVersionMap) {\n            verifySamePluginVersion(\n                    projectToPluginVersionMap, project, Version.ANDROID_GRADLE_PLUGIN_VERSION);\n        }\n\n        // 向 loadedPluginClass 写入现在所执行的 android plugin 的 AndroidBasePlugin.class 对象，如果 loadedPluginClass 保存了和写入的 AndroidBasePlugin.class 对象不同的值，则抛出异常。\n        // 配置 {@GradleProperties 'android.enableBuildScriptClasspathCheck'} = false 来屏蔽这个检查。\n        verifyPluginLoadedOnce(\n                loadedPluginClass,\n                AndroidBasePlugin.class,\n                projectOptions.get(BooleanOption.ENABLE_BUILDSCRIPT_CLASSPATH_CHECK));\n    }\n\n```\n\n### `BasePlugin::apply() > configureProject()`\n\n`configureProject()` 做了一些零散的不易归类初始化任务，这些任务中需要进一步分析的也不多。\n\n```\nprivate void configureProject() {\n\n    // ExtraModelInfo 存储一些不易归类的 extra 信息 ：\n    // * 存储构建过程中的检测到的 waring 和 error 信息，并输出这些信息, 根据这次构建是由 ide 触发的还是开发者触发的，信息可能以 'MACHINE_PARSABLE' 或 'HUMAN_READABLE' 两种格式输出。\n    // TODO: 在后续源码分析中，补充在 ExtraModelInfo 其他信息的作用\n    extraModelInfo = new ExtraModelInfo(projectOptions, project.getLogger());\n\n    // 检查当前 gradle 版本不低于 当前运行的 android plugin 所要求的最低版本，否则抛出异常。\n    // 配置 {@GradleProperties 'android.overrideVersionCheck'} = true，可以仅输出 waring 信息不抛出异常。\n    checkGradleVersion();\n    \n    // SdkHandler 是 android sdk 信息的封装类，在构造方法中会寻找 andorid sdk 的路径。\n    sdkHandler = new SdkHandler(project, getLogger());\n\n    // 当 {@GradleProperties 'android.builder.sdkDownload'} = true、并且当前构建不是由 IDE 触发、并且当前构建的 gradle 建参数不包含 '--offline' 这个三个条件成立时：\n    // SdkHandler 会在使用 android sdk 中工具时自动下载，这样即使不安装 android sdk 也能完成 android 工程构建。\n    //  SdkLibData 时下载信息的抽象，包括 Downloader 对象和 SettingsController 的实现。\n    // SettingsController 是注入下载配置的接口，默认实现中包括了指定使用 https、从{@GradleProperties 'android.sdk.channel'} 中获取下载channel、从 System.getProperties() 获取网络代理信息等。\n    if (!project.getGradle().getStartParameter().isOffline() \n                && projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)\n                && !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) {\n            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());\n            sdkHandler.setSdkLibData(sdkLibData);\n    }  \n\n    // AndroidBuilder 是构建 toolchain 的接口类。\n    androidBuilder = new AndroidBuilder(\n                project == project.getRootProject() ? project.getName() : project.getPath(),\n                creator,\n                new GradleProcessExecutor(project),\n                new GradleJavaProcessExecutor(project),\n                extraModelInfo,\n                getLogger(),\n                isVerbose());\n\n    // @DataBinding 初始化 DataBindingBuilder。\n    [+] {...}\n\n    // apply 了 JavaBasePlugin 插件和 JacocoPlugin 插件\n    project.getPlugins().apply(JavaBasePlugin.class);\n    project.getPlugins().apply(JacocoPlugin.class);\n\n    // 替换 {@Task assemble} 的描述，{@Task assemble} 在 apply JavaBasePlugin.class 之后创建。\n    project.getTasks().getByName(\"assemble\")\n        .setDescription(\"Assembles all variants of all applications and secondary packages.\");\n\n    project.getGradle().addBuildListener(\n        buildFinished(BuildResult buildResult) -> {\n            // 构建结束后一些 release 工作。\n            ExecutorSingleton.shutdown();\n            sdkHandler.unload();\n\n            // 清理 PreDexCache 中的缓存，并将其写在 '{@File gradleProjectRoot}/build/intermediates/dex-cache/cache.xml' 文件\n            // TOOD : 分析 Dex 过程时在回来看这里。\n            PreDexCache.getCache().clear(\n                FileUtils.join(\n                    project.getRootProject().getBuildDir(),\n                    FD_INTERMEDIATES,\n                    \"dex-cache\",\n                    \"cache.xml\"),\n                getLogger());\n                Main.clearInternTables();\n        }\n    )\n\n    // 任务树生成后进行检查：如果任务树中存在 DexTransform 类型的任务，\n    // PreDexCache 从 '{@File gradleProjectRoot}/build/intermediates/dex-cache/cache.xml' 文件加载缓存。\n    // TOOD : 分析 Dex 过程时在回来看这里。\n    project.getGradle().getTaskGraph().addTaskExecutionGraphListener(\n        (taskGraph) -> {\n            for (Task task : taskGraph.getAllTasks()) {\n                if (task instanceof TransformTask) {\n                    Transform transform = ((TransformTask) task).getTransform();\n                    if (transform instanceof DexTransform) {\n                        PreDexCache.getCache().load(\n                            FileUtils.join(\n                                project.getRootProject().getBuildDir(),\n                                FD_INTERMEDIATES,\n                                dex-cache\",\n                                \"cache.xml\"));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n```\n\n#### `SdkHandler` 寻找 android sdk 路径\n\n```\npublic class SdkHandler {\n\n    public SdkHandler(@NonNull Project project,\n                      @NonNull ILogger logger) {\n        this.logger = logger;\n        findLocation(project);\n    }\n\n    private void findLocation(@NonNull Project project) {\n        \n        //@Test \n        [+] {...}\n\n        //读取 '{@File gradleProjectRoot}/local.properties'\n        File rootDir = project.getRootDir();\n        File localProperties = new File(rootDir, FN_LOCAL_PROPERTIES);\n        Properties properties = new Properties();\n        [+] {...}\n\n        // 按照如下优先级寻找 android sdk 路径：\n        // local.properties 的 'sdk.dir' 属性 > local.properties 的 'android.dir' 属性 > \n        // ANDROID_HOME 环境变量 > android.home 环境变量。\n        Pair<File, Boolean> sdkLocation = findSdkLocation(properties, rootDir);\n        sdkFolder = sdkLocation.getFirst();\n        \n        // isRegularSdk 的作用见下面 getSdkLoader() 方法前\n        isRegularSdk = sdkLocation.getSecond();\n\n        //按照如下优先级寻找 ndk路径\n        // local.properties 的 'ndk.dir' 属性 > ANDROID_NDK_HOME 环境变量\n        // > '{@File sdkFolder}/ndk-bundle'\n        ndkFolder = NdkHandler.findNdkDirectory(properties, rootDir);\n\n        // @Ndk 从 local.properties 中读出 'cmake.dir'，并赋值给 cmakePathInLocalProp 属性(File 类型)。\n        [+] {...}\n    }\n\n\n    // 仅当 android sdk 路径是由 local.properties 的 'android.dir' 属性定义时，isRegularSdk 为 false。\n    // 这时认为当前构建使用 \"Platform-based\" 的 android sdk，其文件布局与开发使用的 android sdk 不同，\n    // 所以在解析 android sdk 文件布局时使用 PlatformLoader 而非 DefaultSdkLoader。\n    // 在依赖 android 源码中的 android sdk 而非发布版的 android sdk 会出现这种情况。\n    public synchronized SdkLoader getSdkLoader() {\n        if (sdkLoader == null) {\n            if (isRegularSdk) {\n                sdkLoader = DefaultSdkLoader.getLoader(sdkFolder);\n            } else {\n                sdkLoader = PlatformLoader.getLoader(sdkFolder);\n            }\n        }\n        return sdkLoader;\n    }\n}\n```\n\n### `BasePlugin::apply() > configureExtension()`\n\n* 创建了 extension 对象并将其注册到 gradle project 中，extension 对象包含 android plugin 和用户构建脚本之间的所有 api 对象，这些 api 对象定义的 android plugin api 并承载了构建脚本中的开发者配置。\n* 初始化 project 模型和任务树有关的管理类：TaskManager、VariantManager、VariantFactory，这3个管理类可以说是配置阶段的核心；这些管理类通过注册 api 对象监听事件，收集开发者构建脚本中的配置信息。\n* 创建 FileCache、GlobalScope 等一些上下文对象。\n\n完成 `configureExtension()` 执行后 android plugin 就已经做好执行构建脚本，获取配置信息的准备了。\n\n```\nprivate void configureExtension() {\n\n    // 创建了承载 BuildType、ProductFlavor、SigningConfig 的3个容器。\n    // 这3个容器作为创建 extension 的参数，通过 extension 链接到编译脚步，收集开发者配置。\n    final NamedDomainObjectContainer<BuildType> buildTypeContainer =\n            project.container(BuildType.class,\n                    new BuildTypeFactory(instantiator, project, extraModelInfo));\n    final NamedDomainObjectContainer<ProductFlavor> productFlavorContainer =\n            project.container(ProductFlavor.class,\n                    new ProductFlavorFactory(\n                            instantiator, project, project.getLogger(), extraModelInfo));\n    final NamedDomainObjectContainer<SigningConfig> signingConfigContainer =\n            project.container(SigningConfig.class, new SigningConfigFactory(instantiator));\n\n    // TODO：BaseVariantOutput \n    final NamedDomainObjectContainer<BaseVariantOutput> buildOutputs =\n            project.container(BaseVariantOutput.class);\n    project.getExtensions().add(\"buildOutputs\", buildOutputs);\n\n    // 创建 extension 对象，可以看到之前创建的4个容器最终由 extension 对象持有。\n    // 创建 extension 的过程会完成以下工作：\n    // * 完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；\n    // * 通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；\n    // *为 android plugin api 对象添加默认配置。\n    extension =\n            createExtension(\n                    project,\n                    projectOptions,\n                    instantiator,\n                    androidBuilder,\n                    sdkHandler,\n                    buildTypeContainer,\n                    productFlavorContainer,\n                    signingConfigContainer,\n                    buildOutputs,\n                    extraModelInfo);\n\n    // @Ndk 创建 NdkHandler。\n    [+] {...}\n\n    // 创建 FileCache 和 GlobalScope 对象，FileCache 被 GlobalScope 对象持有。\n    \n    // 当 '{@GradleProperties android.enableBuildCache}' = true 时创建 FileCache。\n    // FileCache 默认缓存路径是 '{@File androidHomeDir}/build-cache'，可以通过 '{@GradleProperties android.buildCacheDir}' 自定义缓存路径。\n    // {@File androidHomeDir} 是选取规则在见后面设置 debug.keystore 的代码分析。\n    // FileCache 的实际作用留到它被使用时再分析。\n    @Nullable\n    FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);\n\n    // GlobalScope 对象是当前 android 工程的上下文对象，它只负责持有对象，方便获取。\n    // GlobalScope 对象 之后分别被 TaskManager、VariantManager、VariantFactory 3个对象持有。\n    GlobalScope globalScope =\n            new GlobalScope(\n                    project,\n                    projectOptions,\n                    androidBuilder,\n                    extension,\n                    sdkHandler,\n                    ndkHandler,\n                    registry,\n                    buildCache);\n\n    // 创建 TaskManager、VariantManager、VariantFactory 3个管理类。\n    variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);\n    taskManager =\n            createTaskManager(\n                    globalScope,\n                    project,\n                    projectOptions,\n                    androidBuilder,\n                    dataBindingBuilder,\n                    extension,\n                    sdkHandler,\n                    ndkHandler,\n                    registry,\n                    threadRecorder);\n    variantManager =\n            new VariantManager(\n                    globalScope,\n                    project,\n                    projectOptions,\n                    androidBuilder,\n                    extension,\n                    variantFactory,\n                    taskManager,\n                    threadRecorder);\n\n\n    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 Add 事件监听。\n    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);\n    buildTypeContainer.whenObjectAdded(\n            buildType -> {\n                SigningConfig signingConfig =\n                        signingConfigContainer.findByName(BuilderConstants.DEBUG);\n                buildType.init(signingConfig);\n                variantManager.addBuildType(buildType);\n            });\n    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);\n\n    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 remove 事件监听。\n    // 禁止开发者对这三个配置做 remove 操作，如果发生就抛出异常。\n    signingConfigContainer.whenObjectRemoved(\n            new UnsupportedAction(\"Removing signingConfigs is not supported.\"));\n    buildTypeContainer.whenObjectRemoved(\n            new UnsupportedAction(\"Removing build types is not supported.\"));\n    productFlavorContainer.whenObjectRemoved(\n            new UnsupportedAction(\"Removing product flavors is not supported.\"));\n\n    // 向 BuildType、ProductFlavor、SigningConfig 3个容器创建 default 成员。\n    // 大多数 VariantFactory 的实现，在这里创建了 'debug' SigningConfig、'debug' BuildType、'release' BuildType。\n    variantFactory.createDefaultComponents(\n            buildTypeContainer, productFlavorContainer, signingConfigContainer);\n}\n```\n\n#### `BuildType`、`ProductFlavor`、`SigningConfig` 容器内容构造\n\n这3个 NamedDomainObjectContainer<T> 类型的容器，在构造时传入 NamedDomainObjectFactory<T> 提供容器内容对象的构造方法。`BuildType` 和 `ProductFlavor` 构造方法都直接调用了构造函数，只有 `SigningConfig` 做了特殊处理。\n\n```\npublic class SigningConfigFactory implements NamedDomainObjectFactory<SigningConfig> {\n\n    ...\n\n    @NonNull\n    public SigningConfig create(@NonNull String name) {\n        SigningConfig signingConfig = instantiator.newInstance(SigningConfig.class, name);\n\n        // 如果 SigningConfig 对象的名字是 'debug'，那么用 android 环境的 debug keystore 来初始化这个对象。\n        // debug keystore 存放的位置在 '{@File androidHomeDir}/debug.keystore'；\n        // debug keystore 配置：store pw -> 'android'，key alias -> 'AndroidDebugKey'，key pw -> 'android'。\n        // {@File androidHomeDir} 为 '{@File homeDir}/.android' ，{@File homeDir} 按以下优先级寻找, ，没找到就会抛异常：\n        // ANDROID_SDK_HOME 环境变量或系统属性 > TEST_TMPDIR 环境变量 > user.home 系统属性 > HOME 环境变量 \n        if (BuilderConstants.DEBUG.equals(name)) {\n            try {\n                signingConfig.initWith(\n                        DefaultSigningConfig.debugSigningConfig(\n                                new File(KeystoreHelper.defaultDebugKeystoreLocation())));\n            } catch (AndroidLocation.AndroidLocationException e) {\n                throw new BuildException(\"Failed to get default debug keystore location.\", e);\n            }\n        }\n        return signingConfig;\n    }\n\n    ...\n}\n```\n\n### `BuildType`、`ProductFlavor`、`SigningConfig` Add 操作监听\n\n总体来说，VariantManager 监听了 `BuildType`、`ProductFlavor`、`SigningConfig` 对象的创建操作，并将被创建的对象分别保存在 map 容器中。\n\n```\nprivate void configureExtension() {\n    ...\n\n    // VariantManager.addSigningConfig() 仅仅将 SigningConfig 对象加入了 VariantManager 的 map 容器持有。\n    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);\n\n    // 这里看起来好像用 'debug' SigningConfig 初始化了所有 BuildType 对象。\n    // 实际上 BuildType.init(SigningConfig) 中有判断，只有 BuildType 的名字也是 'debug' 时才会用调用 BuildType.setSigningConfig(SigningConfig)。\n    buildTypeContainer.whenObjectAdded(\n            buildType -> {\n                SigningConfig signingConfig =\n                        signingConfigContainer.findByName(BuilderConstants.DEBUG);\n                buildType.init(signingConfig);\n                variantManager.addBuildType(buildType);\n            });\n    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);\n\n    ...\n}\n\n```\n\n```\npublic class VariantManager implements VariantModel {\n    ...\n\n    // BuildType 对象的加入引发 SourceSet 和 BuildTypeData 对象的创建。\n    public void addBuildType(@NonNull CoreBuildType buildType) {\n        String name = buildType.getName();\n\n        // 检查 BuildType 名字的合法性，名字不能以 'androidTest' 或 'test' 开头；名字不能为 'lint'。\n        checkName(name, \"BuildType\");\n\n        // BuildType 名字不能和任何 ProductFlavor 相同。\n        if (productFlavors.containsKey(name)) {\n            throw new RuntimeException(\"BuildType names cannot collide with ProductFlavor names\");\n        }\n\n        // 创建和 BuildType 同名的 SourceSet。\n        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(name);\n\n        // @Test，创建名为 '{$BuildTypeName}AndroidTest' 和 '{$BuildTypeName}UnitTest' 的 SourceSet。\n        [+] {...}\n\n        // 创建 BuildTypeData，其持有 BuildType 对象和 3个刚刚创建 SourceSet。\n        BuildTypeData buildTypeData =\n                new BuildTypeData(\n                        buildType, project, mainSourceSet, androidTestSourceSet, unitTestSourceSet);\n        buildTypes.put(name, buildTypeData);\n    }\n\n\n    public void addProductFlavor(@NonNull CoreProductFlavor productFlavor) {\n        String name = productFlavor.getName();\n\n        // 检查 BuildType 名字的合法性，名字不能以 'androidTest' 或 'test' 开头；名字不能为 'lint'。\n        checkName(name, \"ProductFlavor\");\n\n        // ProductFlavor 名字不能和任何 BuildType 相同。\n        if (buildTypes.containsKey(name)) {\n            throw new RuntimeException(\"ProductFlavor names cannot collide with BuildType names\");\n        }\n\n        // 创建和 ProductFlavor 同名的 SourceSet。\n        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(\n                productFlavor.getName());\n\n        // @Test，创建名为 '{$BuildTypeName}AndroidTest' 和 '{$BuildTypeName}UnitTest' 的 SourceSet。\n        [+] {...}\n\n        // 创建 ProductFlavorData，其持有 ProductFlavor 对象和 3个刚刚创建 SourceSet。\n        ProductFlavorData<CoreProductFlavor> productFlavorData =\n                new ProductFlavorData<>(\n                        productFlavor,\n                        mainSourceSet,\n                        androidTestSourceSet,\n                        unitTestSourceSet,\n                        project);\n        productFlavors.put(productFlavor.getName(), productFlavorData);\n    }\n\n    ...\n}\n\n```\n\n#### `BuildTypeData`、`ProductFlavorData` 的创建\n\nBuildTypeData、ProductFlavorData 的基类均为 VariantDimensionData，在导出类中没有特殊操作，仅仅额外持有了 BuildType 和 ProductFlavor 对象，生成任务树之后会额外持有 {@Task assemble{$BuildType}} 和 {@Task assemble{$ProductFlavor}} 的引用。\n\n```\npublic class VariantDimensionData {\n    ...\n\n    private final DefaultAndroidSourceSet sourceSet;\n    private final DefaultAndroidSourceSet androidTestSourceSet;\n    private final DefaultAndroidSourceSet unitTestSourceSet;\n\n    public VariantDimensionData(\n            @NonNull DefaultAndroidSourceSet sourceSet,\n            @Nullable DefaultAndroidSourceSet androidTestSourceSet,\n            @Nullable DefaultAndroidSourceSet unitTestSourceSet,\n            @NonNull Project project) {\n        this.sourceSet = sourceSet;\n        this.androidTestSourceSet = androidTestSourceSet;\n        this.unitTestSourceSet = unitTestSourceSet;\n\n        final ConfigurationContainer configurations = project.getConfigurations();\n\n        // @Test \n        // 让名为 '{$VariantDimensionName}AndroidTestImplementation' 和 '{$VariantDimensionName}UnitTestImplementation' 的 Configuration 继承 '{$VariantDimensionName}Implementation'\n        // 让名为 '{$VariantDimensionName}AndroidTestRuntimeOnly' 和 '{$VariantDimensionName}UnitTestRuntimeOnly' 的 Configuration 继承 '{$VariantDimensionName}RuntimeOnly'\n        if (androidTestSourceSet != null) {\n            makeTestExtendMain(sourceSet, androidTestSourceSet, configurations);\n        }\n        if (unitTestSourceSet != null) {\n            makeTestExtendMain(sourceSet, unitTestSourceSet, configurations);\n        }\n\n    }\n\n    ...\n}\n```\n\n#### `BasePlugin::configureExtension() > createExtension()`\n\n`createExtension()` 是个抽象函数，不过实际上 BasePlugin 的各个实现类只是构造了不同的 BaseExtension 类的实现，没有在这个方法中做别的事情。\n各个 BaseExtension 类的实现区别也很小，所以这里只会提到 BaseExtension 和 TestedExtension。\n\nBaseExtension\n    -> TestExtension\n    -> TestedExtension\n        -> AppExtension\n        -> LibraryExtension\n            -> FeatureExtension\n    -> InstantAppExtension \n\n在 BaseExtension 的构造函数中：\n* 完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；\n* 通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；\n* 为 android plugin api 对象添加少许默认配置。\n\n*创建 Configuration 的过程使用伪代码展现*\n\n```\npublic abstract class BaseExtension implements AndroidConfig {\n    ...\n\n    BaseExtension(\n            @NonNull final Project project,\n            @NonNull final ProjectOptions projectOptions,\n            @NonNull Instantiator instantiator,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypes,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavors,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigs,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull ExtraModelInfo extraModelInfo,\n            final boolean publishPackage) {\n        \n        // @Simplify 保存构造函数传入的参数。\n        [+] {...}\n\n        logger = Logging.getLogger(this.getClass());\n\n        // 创建 DefaultConfig 对象，DefaultConfig 对象是一个名为 'main' 的特殊的 ProductFlavor，DefaultConfig 和 ProductFlavor 有共同的父类。\n        defaultConfig =\n                instantiator.newInstance(\n                        DefaultConfig.class,\n                        BuilderConstants.MAIN,\n                        project,\n                        instantiator,\n                        project.getLogger(),\n                        extraModelInfo);\n\n        // @Simplify 创建各种 Options 类型对象，都用于描述 android plugin api 并承载编译脚本配置。\n        [+] {...}\n\n        // 创建 SourceSet 容器，容器中的使用 DefaultAndroidSourceSet 类构造。\n        sourceSetsContainer =\n                project.container(\n                        AndroidSourceSet.class,\n                        new AndroidSourceSetFactory(instantiator, project, publishPackage));\n\n        \n        // 监听 SourceSet 容器的 Add 操作。\n        // 当有新的 SoucreSet 加入容器之后，初始化 SourceSet 的默认布局，建与之相对应的 Configuration，设置被创建的 Configuration 之间的 extendsFrom 关系。\n        // 这是段较长的 labor 代码，改为用伪代码分析\n        sourceSetsContainer.whenObjectAdded() {\n            // @Pseudocode\n            sourceSet -> {\n                ConfigurationContainer configurations = project.getConfigurations();\n\n                String sourceSetName = sourceSet.getName();\n\n                // 创建名为 '{SouceSetName}Api'、'{SouceSetName}Implementation'、\n                // '{SouceSetName}RuntimeOnly'、'{SouceSetName}CompileOnly' 的 SourceSet。\n                // 创建名为 '{SouceSetName}Compile'、'{SouceSetName}Provided' 的 SourceSet。\n                // 在 App 工程中创建 '{SouceSetName}Apk'；在 Lib 工程中创建 '{SouceSetName}Publish'。\n                // 对于名为 'main' 的 sourceSet 而言，创建 Configuration 的命名规则特殊处理，不加前缀。\n                Configuration compile = createConfiguration(configurations, sourceSetName + 'Compile');\n                if ({in AppExtension}) {\n                    Configuration apk = createConfiguration(configurations, sourceSetName + 'Apk');\n                } else {\n                    Configuration apk = createConfiguration(configurations, sourceSetName + 'Publish');\n                }\n                Configuration provided = createConfiguration(configurations, sourceSetName + 'Provided');\n                Configuration api = createConfiguration(configurations, sourceSetName + 'Api');\n                Configuration implementation = createConfiguration(configurations, sourceSetName + 'Implementation');\n                Configuration runtimeOnly = createConfiguration(configurations, sourceSetName + 'RuntimeOnly');\n                Configuration compileOnly = createConfiguration(configurations, sourceSetName + 'CompileOnly');\n\n                // compile、apk、provided 3个 Configuration 属于 Depercated 设定。\n                // 当这3个 Configuration 有任何 dependency 增加时输出 warning。\n                compile.getAllDependencies().whenObjectAdded(\n                    new DeprecatedConfigurationAction());\n                apk.getAllDependencies().whenObjectAdded(\n                    new DeprecatedConfigurationAction());\n                provided.getAllDependencies().whenObjectAdded(\n                    new DeprecatedConfigurationAction());\n\n                // 设置 extendsFrom 关系。\n                api.extendsFrom(compile);\n                implementation.extendsFrom(api);\n                runtimeOnly.extendsFrom(apk);\n                compileOnly.extendsFrom(provided);\n\n                // @Wear 创建名为 '{SouceSetName}WearApp' 的 Configuration。\n                [+] {...}\n\n                // '{SouceSetName}AnnotationProcessor' 的 Configuration。\n                // 用于做 apt。\n                createConfiguration(configurations, sourceSetName + 'AnnotationProcessor');\n\n                // 设置 sourceSet 的默认布局：\n                // java -> 'src/{SouceSetName}/java'\n                // javaResources -> 'src/{SouceSetName}/resources'\n                // res -> 'src/{SouceSetName}/res'\n                // assets -> 'src/{SouceSetName}/assets'\n                // manifest -> 'src/{SouceSetName}/AndroidManifest.xml'\n                // aidl -> 'src/{SouceSetName}/aidl'\n                // renderscript -> 'src/{SouceSetName}/rs'\n                // jni -> 'src/{SouceSetName}/jni'\n                // jniLibs -> 'src/{SouceSetName}/jniLibs'\n                // shaders -> 'src/{SouceSetName}/shaders'\n                sourceSet.setRoot(String.format(\"src/%s\", sourceSet.getName()));\n            }\n        }\n\n        // @Test 创建名为 'androidTestUtil' 的 Configuration\n        [+] {...}\n        \n        // 创建名为 'main' 的 SourceSet。\n        sourceSetsContainer.create(defaultConfig.getName());\n\n        // 设置一些默认的编译脚本配置。\n        // 设置默认的 buildTools Revision，如果开发者没有在编译脚本中指定，就使用默认版本。不同版本的 android plugin 定一个默认 buildTools 版本不同。\n        buildToolsRevision = AndroidBuilder.DEFAULT_BUILD_TOOLS_REVISION;\n        // 这个函数会对 DefaultConfig 对象做一些有关矢量图的配置。 \n        setDefaultConfigValues();\n    }\n\n    ...\n}\n```\n\n在 TestedExtension 的构造函数中创建了名为 'androidTest' 和 'test' 的 SourceSet，与 'main' SourceSet 对应是默认存在基础 SourceSet。\n\n```\n// TestedExtension 是 AppExtension、LibraryExtension、FeatureExtension 的父类。\npublic abstract class TestedExtension extends BaseExtension implements TestedAndroidConfig {\n\n    ...\n    public TestedExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull Instantiator instantiator,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypes,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavors,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigs,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull ExtraModelInfo extraModelInfo,\n            boolean isDependency) {\n        super(\n                project,\n                projectOptions,\n                instantiator,\n                androidBuilder,\n                sdkHandler,\n                buildTypes,\n                productFlavors,\n                signingConfigs,\n                buildOutputs,\n                extraModelInfo,\n                isDependency);\n        // 创建名为 'androidTest' 和 'test' 的 SourceSet。\n        getSourceSets().create(ANDROID_TEST.getPrefix());\n        getSourceSets().create(UNIT_TEST.getPrefix());\n    }\n\n    ...\n}\n```\n\n#### 构造 `TaskManager`、`VariantManager`、`VariantFactory`\n\nTaskManager 通过 `createTaskManager()` 方法创建，VariantFactory 通过 `createVariantFactory` 方法创建。这两个方法均为抽象方法，在各种 plugin 的实现中，仅仅是调用了各种 TaskManager 和 VariantFactory 实现的构造函数，并无额外的代码。\n\nVariantManager 的构造函数中针对 DebugConfig 对象(DebugConfig 对象在 BaseExtension 构造时被创建)做了一些处理。\n\n\n```\npublic class VariantManager implements VariantModel {\n    ...\n\n    public VariantManager(\n            @NonNull GlobalScope globalScope,\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull AndroidConfig extension,\n            @NonNull VariantFactory variantFactory,\n            @NonNull TaskManager taskManager,\n            @NonNull Recorder recorder) {\n        ...\n\n        DefaultAndroidSourceSet mainSourceSet =\n                (DefaultAndroidSourceSet) extension.getSourceSets().getByName(extension.getDefaultConfig().getName());\n\n        DefaultAndroidSourceSet androidTestSourceSet = null;\n        DefaultAndroidSourceSet unitTestSourceSet = null;\n        if (variantFactory.hasTestScope()) {\n            androidTestSourceSet =\n                    (DefaultAndroidSourceSet) extension.getSourceSets()\n                            .getByName(ANDROID_TEST.getPrefix());\n            unitTestSourceSet =\n                    (DefaultAndroidSourceSet) extension.getSourceSets()\n                            .getByName(UNIT_TEST.getPrefix());\n        }\n\n        // 使用 DebugConfig 对象，'main'、'androidTest'、'test' 3个 SourceSet，\n        // 创建了 defaultConfigData 对象。\n        // 'main'、'androidTest'、'test' 3个 SourceSet 都是在 extension 中直接创建的，而不是由 BuildType 或 ProductFlavor 触发生成的。\n        // 正如 DebugConfig 对象是一个特殊的 ProductFlavor，defaultConfigData 引用也持有了一个特殊的 ProductFlavorData。\n\n        this.defaultConfigData =\n                new ProductFlavorData<>(\n                        extension.getDefaultConfig(),\n                        mainSourceSet,\n                        androidTestSourceSet,\n                        unitTestSourceSet,\n                        project);\n    }\n\n    ...\n}\n\n```\n\n### BasePlugin::apply() > createTasks()\n\n运行到这里时，创建管理类、监听链建立、设置默认配置布局这些工作都完成了，终于要创建 gradle task 了。\n\n```\nprivate void createTasks() {\n    taskManager.createTasksBeforeEvaluate(\n        new TaskContainerAdaptor(project.getTasks())));\n\n    project.afterEvaluate(\n        project ->\n            () -> createAndroidTasks(false);\n```\n\n`createTasks()` 将创建 gradle task 的工作分为两部分，一部分在 evaluate 开始之前，用于创建不构建脚本配置影响的任务；另一部分在 evaluate 结束之后，这部分创建那些的任务取决于构建脚本配置。\n\n#### `TaskManager::createTasksBeforeEvaluate()`\n\nTaskManager 的绝大部分实没有扩展 `createTasksBeforeEvaluate()` (只有 InstantAppTaskManager 创建了多创建了一个 gradle task)，所以对于各类 android plugin 在这里创建的任务都是相同的。\n\n在这个方法中创建了一些 Anchor 任务（没有实际内容，仅作为上游节点使用），和一些独立任务例如和 Lint 和 单元测试相关的任务。\n\n*下面代码使用伪代码展现*\n\n```\npublic abstract class TaskManager {\n    public void createTasksBeforeEvaluate(@NonNull TaskFactory tasks) {\n\n        create \"uninstallAll\" task as anchor task. \n            it \"Uninstall all applications.\"\n\n        create \"deviceCheck\" task as anchor task.\n            it \"Runs all device checks using Device Providers and Test Servers.\"\n\n        create \"connectedCheck\" task as anchor task.\n            it \"Runs all device checks on currently connected devices.\"\n\n        create \"preBuild\" task as anchor task.\n            it \"Lead all build tasks.\"\n\n        create \"extractProguardFiles\" task as ExtractProguardFiles.class type.\n            let \"extractProguardFiles\" dependsOn \"preBuild\"\n\n        create \"sourceSets\" task as SourceSetsTask.class type.\n            it \"Prints out all the source sets defined in this project.\"\n\n        create \"assembleAndroidTest\" task as anchor task.\n            it \"Assembles all the Test applications.\"\n\n        create \"compileLint\" task as LintCompile.class type.\n\n        create \"lint\" task as LintGlobalTask.class type.\n            it \"Runs lint on all variants.\"\n            let \"check\" task (which from java plugin) dependsOn \"lint\" task.\n\n        create \"lintChecks\" configuration.\n            it \"Configuration to apply external lint check jar\"\n            GlobalScope will hold \"lintChecks\" configuration\n\n        if ({@Field buildCache} is not null) {\n            create \"cleanBuildCache\" task as CleanBuildCache.class type.\n                it \"Deletes the build cache directory.\"\n        }\n\n        create \"resolveConfigAttr\" task as ConfigAttrTask.class type.\n            set resolveConfigAttr.resolvable = true\n\n        create \"consumeConfigAttr\" task as ConfigAttrTask.class type.\n            set consumeConfigAttr.consumable true.\n    }\n}\n```\n\n#### `BasePlugin::createAndroidTasks()`\n\n`BasePlugin::createAndroidTasks()` 是创建 BuildVariant 和 Android 编译 task 的主流程，其中包含了一些检查和准备工作，创建 task 的代码主要包含在 `VariantManager::createAndroidTasks` 中。\n\n在这里主要做完成完成了：\n* 加载 Android Sdk 信息和添加 Android Sdk 提供的 Maven Repo\n* 创建 lint 相关的全局 task\n* 基于编译脚本输入创建 VariantData 对象\n* 基于 VariantData 信息创建编译 task\n* 完成 Variant 对象的创建。\n\n```\nfinal void createAndroidTasks(boolean force) {\n\n    // @Simplify\n    // 确保 buildToolsVersion 和 compileSdkVersion 被设置了。\n    // 确保 JavaPlugin.class 没有被 apply 过。\n    [+]{...}\n\n    // 初始化 Android SDK Target 信息。 \n    ensureTargetSetup();\n\n    if (hasCreatedTasks) {\n        return;\n    }\n    hasCreatedTasks = true;\n    // 禁止再修改 Extension 对象，编译脚本配置到此截止。\n    extension.disableWrite();\n\n    // 创建 PrepareLintJar.class 类型的 \"prepareLintJar\" 任务。\n    taskManager.configureCustomLintChecks(new TaskContainerAdaptor(project.getTasks()));\n\n    // 将 Android SDK 包含的 Repositories 加入的 Maven Repo 中，并将这些 Repositories 调整到 Maven Repo 列表的最前面。\n    sdkHandler.addLocalRepositories(project);\n\n    // @DataBinding，如果使用了 DataBinding，则向已有 configuration 添加一些依赖。\n    [+]{...}\n\n    // 创建 VariantData 对象和编译 Task。\n    variantManager.createAndroidTasks();\n\n    // 依照 VariantData 对象，创建 Variant 对象。\n    ApiObjectFactory apiObjectFactory =\n            new ApiObjectFactory(\n                    androidBuilder,\n                    extension,\n                    variantFactory,\n                    instantiator,\n                    project.getObjects());\n    for (VariantScope variantScope : variantManager.getVariantScopes()) {\n        BaseVariantData variantData = variantScope.getVariantData();\n        apiObjectFactory.create(variantData);\n    }\n\n    // 在 Variant 对象创建完成之后，创建全局 \"lint\" Task。\n    taskManager.configureGlobalLintTask(variantManager.getVariantScopes());\n\n    // @IDE\n    [+]{...}\n}\n\n...\n\nprivate void ensureTargetSetup() {    \n    TargetInfo targetInfo = androidBuilder.getTargetInfo();\n    if (targetInfo == null) {\n        if (extension.getCompileOptions() == null) {\n            throw new GradleException(\"Calling getBootClasspath before compileSdkVersion\");\n        }\n\n        // 获取 Android SDK Target 信息，并将其设置到 androidBuiler 中。\n        sdkHandler.initTarget(\n                extension.getCompileSdkVersion(),\n                extension.getBuildToolsRevision(),\n                extension.getLibraryRequests(),\n                androidBuilder,\n                SdkHandler.useCachedSdk(projectOptions));\n        // 确保 Android SDK 中没有安装了 platform tools，如果没有就下载它。\n        sdkHandler.ensurePlatformToolsIsInstalled(extraModelInfo);\n    }\n}\n```\n\n`SdkHandler::initTarget()` 中通过 SdkLoader 对象加载 Android Sdk 中的各种工具路径。\nSdkLoader 的不同实现对应不同的 Android Sdk 文件布局，通常使用 `DefaultSdkLoader` 。\n\n```\nclass SdkHandler {\n    ...\n\n     public void initTarget(\n                @NonNull String targetHash,\n                @NonNull Revision buildToolRevision,\n                @NonNull Collection<LibraryRequest> usedLibraries,\n                @NonNull AndroidBuilder androidBuilder,\n                boolean useCachedVersion) {\n            //检查targetHash和buildToolRevision不为空，否则抛异常。\n            ...\n\n            // 通过getSdkLoader()创建SdkLoader对象\n            // 如果useCachedVersion && sSdkLoader，那么重用旧的SdkLoader。\n            synchronized (LOCK_FOR_SDK_HANDLER) {\n                if (useCachedVersion && sSdkLoader == null) {\n                } else {\n                    sSdkLoader = getSdkLoader();\n                }\n                sdkLoader = sSdkLoader;\n            }\n\n            // 通过SdkLoader -> AndroidSdkHandler获得SdkInfo.\n            // SdkInfo包含annotations.jar和adb执行文件的位置。\n            // annotations.jar位置：${sdkLocation}/tools/support/annotations.jar\n            // adb文件位置：${sdkLocation}/platform-tools/adb\n            SdkInfo sdkInfo = sdkLoader.getSdkInfo(logger);\n\n            // 通过SdkLoader -> AndroidSdkHandler获得TargetInfo\n            // TargetInfo包括IAndroidTarget(包装target信息),BuildToolInfo(包装build-tools信息)。\n            TargetInfo targetInfo = sdkLoader.getTargetInfo(\n                    targetHash,\n                    buildToolRevision,\n                    logger,\n                    sdkLibData);\n\n            androidBuilder.setSdkInfo(sdkInfo);\n            androidBuilder.setTargetInfo(targetInfo);\n            androidBuilder.setLibraryRequests(usedLibraries);\n\n            // Check if platform-tools are installed. We check here because realistically, all projects\n            // should have platform-tools in order to build.\n            ProgressIndicator progress = new ConsoleProgressIndicator();\n            AndroidSdkHandler sdk = AndroidSdkHandler.getInstance(getSdkFolder());\n            LocalPackage platformToolsPackage =\n                    sdk.getLatestLocalPackageForPrefix(SdkConstants.FD_PLATFORM_TOOLS, true, progress);\n            if (platformToolsPackage == null) {\n                //如果sdkLibData.useSdkDownload()就尝试下载；否则什么都不做。\n                sdkLoader.installSdkTool(sdkLibData, SdkConstants.FD_PLATFORM_TOOLS);\n            }\n        }\n\n    ...\n}\n```\n\n// `configureCustomLintChecks` 和 `configureGlobalLintTask` 这两个方法都跟 Lint 任务创建相关，一个在创建 Variant 对象之前调用，一个在其后调用。\n\n```\nclass TaskMananger {\n    ...\n\n    // \"prepareLintJar\" 任务，这个任务会将 {@File lint.jar} 拷贝到 {@File build/intermediates/lint/lint.jar}。\n    public void configureCustomLintChecks(@NonNull TaskFactory tasks) {\n        File lintJar = FileUtils.join(globalScope.getIntermediatesDir(), \"lint\", FN_LINT_JAR);\n\n        AndroidTask<PrepareLintJar> copyLintTask =\n        getAndroidTasks()\n                .create(tasks, new PrepareLintJar.ConfigAction(globalScope, lintJar));\n        globalScope.addTaskOutput(LINT_JAR, lintJar, copyLintTask.getName());\n    }\n\n    ...\n\n    public void configureGlobalLintTask(@NonNull final Collection<VariantScope> variants) {\n\n        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());\n\n        // 筛选 'non testing' && 'non feature' 的 BuildVariant。\n        List<VariantScope> filteredVariants =\n                variants.stream().filter(TaskManager::isLintVariant).collect(Collectors.toList());\n        if (filteredVariants.isEmpty()) {\n            return;\n        }\n\n        // 创建全局的 'lint' 任务。\n        androidTasks.configure(\n                tasks, new LintGlobalTask.GlobalConfigAction(globalScope, filteredVariants));\n\n        // 将 'lint.jar' 文件加入每个 BuildVariant 的输出文件集中。\n        FileCollection lintJarCollection = globalScope.getOutput(LINT_JAR);\n        File lintJar = lintJarCollection.getSingleFile();\n        for (VariantScope scope : variants) {\n            scope.addTaskOutput(LINT_JAR, lintJar, PrepareLintJar.NAME);\n        }\n    }\n\n    ...\n}\n```\n\n在 `VariantManager::createAndroidTasks()` 中：\n* `populateVariantDataList()` 创建 VariantData 对象。\n* `TaskManager::createTopLevelTestTasks` 创建一些和单元测试有关的顶层 task。\n* `createTasksForVariantData()` 创建编译相关的所有 task。\n* `TaskManager::createReportTasks` 创建输出信息的工具 task。\n\n```\nclass VariantManager {\n    ...\n\n    public void createAndroidTasks() {\n        // 这是一个抽象方法，只有在 LibraryVariantFactory 中有实现。\n        // LibraryVariantFactory 的实现中，确保 BuildType 和 ProductFlavor 没有配置\n        // applicationId 或 applicationIdSuffix。\n        variantFactory.validateModel(this);\n\n        // 这又是一个抽象方法，在 BaseVariantFactory 的实现中检查，\n        // 如果使用了 'android-apt' 插件，则提示开发者使用更新的 'annotationProcessor' 配置。\n        variantFactory.preVariantWork(project);\n\n        // 创建 VariantData 对象。\n        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());\n        if (variantScopes.isEmpty()) {\n            populateVariantDataList();\n        }\n\n        //@Test, 创建一些和单元测试有关的顶层 task。\n        taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty());\n\n        // 创建基于 BuildVariant 的编译 task。\n        for (final VariantScope variantScope : variantScopes) {\n            createTasksForVariantData(tasks, variantScope)\n        }\n\n        // 创建一些输出信息的 task。\n        taskManager.createReportTasks(tasks, variantScopes);\n    }\n\n    ...\n\n    public void createReportTasks(TaskFactory tasks, final List<VariantScope> variantScopes) {\n    \n        create \"androidDependencies\" as DependencyReportTask type.\n\n        create \"signingReport\" as SigningReportTask type.\n    }\n\n    ...\n}\n```\n\n#### 创建 VariantData 对象\n\n`VariantManager::populateVariantDataList()` 依赖开发者编译脚本的配置，生成全部 VariantData 对象，进一步完成 project 模型的搭建。\n\n```\nclass VariantManager {\n    ...\n\n    public void populateVariantDataList() {\n        List<String> flavorDimensionList = extension.getFlavorDimensionList();\n\n        if (productFlavors.isEmpty()) {\n            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。\n            configureDependencies();\n            // 如果没有配置任何 ProductFlavor，使用空参数直接构造 VariantData 对象。\n            createVariantDataForProductFlavors(Collections.emptyList());\n        } else {\n            // 如果配置了 ProductFlavor，检查配置合法性，并根据配置构造 VariantData 对象。\n            // 确保每个 ProductFlavor 都有 Dimension\n            if (flavorDimensionList == null || flavorDimensionList.isEmpty()) {\n                // @Simplify 从 Android Gradle 3.0 之后，所有的 ProductFlavor 都需要有 Dimension\n                // 参见：https://d.android.com/r/tools/flavorDimensions-missing-error-message.html\n                [+]{...}\n            } else if (flavorDimensionList.size() == 1) {\n                // @Simplify 如果仅有一个 Dimension，将每个没有配置 Dimension 的 ProductFlavor 设为这个唯一的 Dimension。\n                [+]{...}\n            }\n\n            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。\n            configureDependencies();\n\n            // 下面这两个调用生成了 flavorComboList，\n            // 这个列表中的每个元素代表了一种 ProductFlavor 的组合方式\n            // (按照 Dimension 从高到低的方式)\n            Iterable<CoreProductFlavor> flavorDsl =\n                    Iterables.transform(\n                            productFlavors.values(),\n                            ProductFlavorData::getProductFlavor);\n            List<ProductFlavorCombo<CoreProductFlavor>> flavorComboList =\n                    ProductFlavorCombo.createCombinations(\n                            flavorDimensionList,\n                            flavorDsl);\n            // 以每一种 ProductFlavor 组合为输入，构造 VariantData 对象。\n            for (ProductFlavorCombo<CoreProductFlavor>  flavorCombo : flavorComboList) {\n                createVariantDataForProductFlavors(\n                        (List<ProductFlavor>) (List) flavorCombo.getFlavorList());\n            }\n        }\n    }\n\n    ...\n\n    private void createVariantDataForProductFlavors(\n            @NonNull List<ProductFlavor> productFlavorList) {\n\n        // getVariantConfigurationTypes() 是一个抽象方法，通常情况下只会返回长度为1的列表。\n        // 例如 ApplicationVariantFactory 会返回 VariantType.DEFAULT;\n        // LibraryVariantFactory 会返回 VariantType.LIBRARY;\n        // 这里实际上就是将 VariantType 加入构造 VariantData 的参数。\n        for (VariantType variantType : variantFactory.getVariantConfigurationTypes()) {\n            createVariantDataForProductFlavorsAndVariantType(productFlavorList, variantType);\n        }\n    }\n\n    private void createVariantDataForProductFlavorsAndVariantType(\n            @NonNull List<ProductFlavor> productFlavorList, @NonNull VariantType variantType) {\n\n        // @Test, 在工程支持单元测试的情况下，获取单元测试的目标 BuildTypeData\n        // 默认情况下单元测试的目标 BuildType 是 'debug'\n        BuildTypeData testBuildTypeData = null;\n        [+]{...}\n\n        BaseVariantData variantForAndroidTest = null;\n\n        CoreProductFlavor defaultConfig = defaultConfigData.getProductFlavor();\n\n        Action<com.android.build.api.variant.VariantFilter> variantFilterAction =\n                extension.getVariantFilter();\n\n        // @IDE\n        [+]{...}\n\n        for (BuildTypeData buildTypeData : buildTypes.values()) {\n            boolean ignore = false;\n\n            // 检查编译脚本中的 VariantFilter 配置，\n            // 以确认当前的 BuildType & ProductFlavor 组合是否要被忽略。\n            if (variantFilterAction != null) {\n                variantFilter.reset(\n                        defaultConfig,\n                        buildTypeData.getBuildType(),\n                        variantType,\n                        productFlavorList);\n\n                variantFilterAction.execute(variantFilter);\n                ignore = variantFilter.isIgnore();\n            }\n\n            if (!ignore) {\n                // 通过 BuildType & ProductFlavor 组合 创建 VariantData 对象。 \n                BaseVariantData variantData =\n                        createVariantDataForVariantType(\n                                buildTypeData.getBuildType(),\n                                productFlavorList,\n                                variantType,\n                                false);\n                // 将 VariantScope 对象保存在 variantScopes 中。\n                // VariantScope 对象和 VariantData 对象是一一对应、相互持有的关系。\n                addVariant(variantData);\n\n                // @Simplify\n                [+]{...}\n                \n                if (variantFactory.hasTestScope()) {\n                    if (buildTypeData == testBuildTypeData) {\n                        variantForAndroidTest = variantData;\n                    }\n\n                    // @Test, 创建单元测试的 VariantData 对象。\n                    [+]{...}\n                }\n            }\n        }\n\n        if (variantForAndroidTest != null) {\n            //@Test, 创建单 AndroidTest 的 VariantData 对象。\n            [+]{...}\n        }\n    }\n\n    ...\n\n    // 通过 BuildType & ProductFlavor 组合 创建 VariantData 对象。 \n    private BaseVariantData createVariantDataForVariantType(\n            @NonNull com.android.builder.model.BuildType buildType,\n            @NonNull List<? extends ProductFlavor> productFlavorList,\n            @NonNull VariantType variantType,\n            boolean componentPluginUsed) {\n        BuildTypeData buildTypeData = buildTypes.get(buildType.getName());\n        final DefaultAndroidSourceSet sourceSet = defaultConfigData.getSourceSet();\n\n        // 以 DefaultConfig 和 buildType 为基础创建 VariantConfiguration 对象，\n        // 这个对象代表了 BuildType & ProductFlavor 组合的配置，并且会将脚本中的的配置进行合并，确定最终的配置。\n        GradleVariantConfiguration variantConfig =\n            GradleVariantConfiguration.getBuilderForExtension(extension)\n                .create(\n                    globalScope.getProjectOptions(),\n                    defaultConfigData.getProductFlavor(),\n                    sourceSet,\n                    getParser(sourceSet.getManifestFile()),\n                    buildTypeData.getBuildType(),\n                    buildTypeData.getSourceSet(),\n                    variantType,\n                    signingOverride);\n\n        // @Simplify\n        [+]{...}\n\n        // 依次将 ProductFlavor 对象加入 VariantConfiguration 对象，每次加入操作都会进行配置合并，保存在 'mergedFlavor' 中。\n        // 合并时大部分属性会进行覆盖，高维 ProductFlavor > 低维 ProductFlavor > DefaultConfig。\n        // 但是 applicationIdSuffix 和 versionNameSuffix 两个配置会将各个维度与 DefaultConfig 拼接到一起。\n        // 此外 JavaCompileOptions、NdkOptions 等 Options 会进行覆盖合并，BuildType > 高维 ProductFlavor > 低维 ProductFlavor > DefaultConfig。\n        for (ProductFlavor productFlavor : productFlavorList) {\n            ProductFlavorData<CoreProductFlavor> data = productFlavors.get(\n                    productFlavor.getName());\n\n            String dimensionName = productFlavor.getDimension();\n            if (dimensionName == null) {\n                dimensionName = \"\";\n            }\n\n            variantConfig.addProductFlavor(\n                    data.getProductFlavor(),\n                    data.getSourceSet(),\n                    dimensionName);\n        }\n\n        // 创建 BuildType & ProductFlavor 拼接而成的 SourceSet。\n        // 名字分别为 '{BuildVaraintName}{ProductFlavorList}' 和 '{ProductFlavorList}'。\n        NamedDomainObjectContainer<AndroidSourceSet> sourceSetsContainer = extension.getSourceSets();\n        createCompoundSourceSets(productFlavorList, variantConfig, sourceSetsContainer, null);\n\n        // 下面的5个 step 收集了 Variant 的所有相关的 SourceSet，分别是：\n        // variant-specific, build type, multi-flavor, flavor1, flavor2, ..., defaultConfig.\n        // 后面会使用这些 SourceSets 创建 VariantDependencies 对象。\n        final List<DefaultAndroidSourceSet> variantSourceSets =\n                Lists.newArrayListWithExpectedSize(productFlavorList.size() + 4);\n\n        // 1. add the variant-specific if applicable.\n        if (!productFlavorList.isEmpty()) {\n            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getVariantSourceProvider());\n        }\n\n        // 2. the build type.\n        variantSourceSets.add(buildTypeData.getSourceSet());\n\n        // 3. the multi-flavor combination\n        if (productFlavorList.size() > 1) {\n            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getMultiFlavorSourceProvider());\n        }\n\n        // 4. the flavors.\n        for (ProductFlavor productFlavor : productFlavorList) {\n            variantSourceSets.add(productFlavors.get(productFlavor.getName()).getSourceSet());\n        }\n\n        // 5. The defaultConfig\n        variantSourceSets.add(defaultConfigData.getSourceSet());\n\n        // 创建 BaseVariantData 对象。\n        BaseVariantData variantData =\n                variantFactory.createVariantData(variantConfig, taskManager, recorder);\n\n        // 创建 VariantDependencies 对象并由 BaseVariantData 对象持有。\n        // 构造 VariantDependencies 对象的过程中，创建了几个新的 Configuration：\n        // '{VariantName}CompileClasspath'，'{VariantName}RuntimeClasspath' 等。\n        // 由于每个 SourceSet 都会对应一个 Configuration，\n        // 所以以通过 variantSourceSets 参数可以获取所有与 Variant 的所有相关的 Configuration。\n        // 这里新创建的 Configuration 会视情况依赖 与 Variant 的所有相关的 Configuration。\n        VariantDependencies.Builder builder =\n            VariantDependencies.builder(\n                        project, androidBuilder.getErrorReporter(), variantConfig)\n                .setConsumeType(\n                        getConsumeType(variantData.getVariantConfiguration().getType()))\n                .setPublishType(\n                        getPublishingType(variantData.getVariantConfiguration().getType()))\n                .setFlavorSelection(getFlavorSelection(variantConfig))\n                .addSourceSets(variantSourceSets)\n                .setBaseSplit(\n                        variantType == VariantType.FEATURE && extension.getBaseFeature());\n        final VariantDependencies variantDep = builder.build();\n        variantData.setVariantDependency(variantDep);\n\n        // 如果需要兼容 4.x 的 MultiDex，\n        // 那么添加依赖 'com.android.support:multidex:1.0.2'。\n        if (variantConfig.isLegacyMultiDexMode()) {\n            project.getDependencies().add(\n                    variantDep.getCompileClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);\n            project.getDependencies().add(\n                    variantDep.getRuntimeClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);\n        }\n\n        // @RenderScript\n        [+]{...}\n\n        return variantData;\n    }\n\n    ...\n\n    private void createCompoundSourceSets(\n            @NonNull List<? extends ProductFlavor> productFlavorList,\n            @NonNull GradleVariantConfiguration variantConfig,\n            @NonNull NamedDomainObjectContainer<AndroidSourceSet> sourceSetsContainer,\n            @Nullable BaseVariantData testedVariantData) {\n        if (!productFlavorList.isEmpty()) {\n            // 创建名为 '{BuildVaraintName}{ProductFlavorList}' 的 SourceSet。\n            DefaultAndroidSourceSet variantSourceSet =\n                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(\n                            computeSourceSetName(\n                                    variantConfig.getFullName(),\n                                    variantConfig.getType()));\n            variantConfig.setVariantSourceProvider(variantSourceSet);\n\n            if (testedVariantData != null) {\n                // @Test,配置 Configuration 的依赖关系。\n                [+]{...}\n            }\n        }\n\n        if (productFlavorList.size() > 1) {\n            // 创建名为 '{ProductFlavorList}' 的 SourceSet。\n            DefaultAndroidSourceSet multiFlavorSourceSet =\n                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(\n                            computeSourceSetName(\n                                    variantConfig.getFlavorName(),\n                                    variantConfig.getType()));\n            variantConfig.setMultiFlavorSourceProvider(multiFlavorSourceSet);\n\n            if (testedVariantData != null) {\n                // @Test,配置 Configuration 的依赖关系。\n                [+]{...}\n            }\n        }\n    }\n\n    ...\n}\n\n```\n\n#### `VariantMananger::configureDependencies()`\n\n在这个方法，通过注册 Gradle Transform 接口，解压缩并转移了所依赖 AAR 中的文件，使这些文件能够参与后续的编译过程。\n\n```\nclass VariantMananger {\n    ...\n\n    public void configureDependencies() {\n        final DependencyHandler dependencies = project.getDependencies();\n\n        // register transforms.\n        final String explodedAarType = ArtifactType.EXPLODED_AAR.getType();\n        dependencies.registerTransform(\n                reg -> {\n                    reg.getFrom().attribute(ARTIFACT_FORMAT, AndroidArtifacts.TYPE_AAR);\n                    reg.getTo().attribute(ARTIFACT_FORMAT, explodedAarType);\n                    reg.artifactTransform(ExtractAarTransform.class);\n                });\n\n        for (ArtifactType transformTarget : AarTransform.getTransformTargets()) {\n            dependencies.registerTransform(\n                    reg -> {\n                        reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);\n                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget.getType());\n                        reg.artifactTransform(\n                                AarTransform.class, config -> config.params(transformTarget));\n                    });\n        }\n\n        dependencies.registerTransform(\n                reg -> {\n                    reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);\n                    reg.getTo()\n                            .attribute(\n                                    ARTIFACT_FORMAT,\n                                    ArtifactType.SYMBOL_LIST_WITH_PACKAGE_NAME.getType());\n                    reg.artifactTransform(LibrarySymbolTableTransform.class);\n                });\n\n        for (String transformTarget : JarTransform.getTransformTargets()) {\n            dependencies.registerTransform(\n                    reg -> {\n                        reg.getFrom().attribute(ARTIFACT_FORMAT, \"jar\");\n                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget);\n                        reg.artifactTransform(JarTransform.class);\n                    });\n        }\n\n        AttributesSchema schema = dependencies.getAttributesSchema();\n\n        // custom strategy for AndroidTypeAttr\n        AttributeMatchingStrategy<AndroidTypeAttr> androidTypeAttrStrategy =\n                schema.attribute(AndroidTypeAttr.ATTRIBUTE);\n        androidTypeAttrStrategy.getCompatibilityRules().add(AndroidTypeAttrCompatRule.class);\n        androidTypeAttrStrategy.getDisambiguationRules().add(AndroidTypeAttrDisambRule.class);\n\n        // custom strategy for build-type and product-flavor.\n        setBuildTypeStrategy(schema);\n\n        setupFlavorStrategy(schema);\n    }\n\n    ...\n}\n```\n\n#### `VariantMananger::createTasksForVariantData()`\n\n*下面代码使用伪代码展现*\n\n```\nclass VariantMananger {\n    ...\n\n    public void createTasksForVariantData(\n            final TaskFactory tasks, final VariantScope variantScope) {\n        \n        create \"assemble{BuildTypeName}\" task as anchor task. \n            it \"Assembles all assemble{BuildTypeName} builds.\"\n            let \"assemble\" dependsOn \"assemble{BuildTypeName}\".\n\n        // 创建更多基于 Variant 的 assemble task. \n        createAssembleTaskForVariantData(tasks, variantData);\n\n        if (variantType.isForTesting()) {\n            // @Test，创建基于 Variant 的单元测试 task.\n            [+]{...}\n        } else {\n            // 创建基于 Variant 的编译 task.\n            taskManager.createTasksForVariantScope(tasks, variantScope);\n        }\n    }\n\n    ...\n\n    // 创建基于 Variant 的 assemble task. \n    private void createAssembleTaskForVariantData(\n            TaskFactory tasks, final BaseVariantData variantData) {\n        final VariantScope variantScope = variantData.getScope();\n        if (variantData.getType().isForTesting()) {\n\n            create \"assemble{VariantName}\" task as anchor task. \n                set variantScope assemble task with it.\n\n        } else {\n            if (productFlavors.isEmpty()) {\n                set variantScope assemble task with \"assemble{BuildTypeName}\".\n            } else {\n                \n                create \"assemble{VariantName}\" task as anchor task. \n                    set variantScope assemble task with it.\n                    let \"assemble{BuildTypeName}\" dependsOn \"assemble{VariantName}\".\n\n                for each flavor\n                    create \"assemble{ProductFlavor}\" as anchor task.\n                        set ProductFlavorData assemble task with it.\n                        let  \"assemble{ProductFlavor}\" dependsOn \"assemble{VariantName}\".\n\n                if (variantConfig.getProductFlavors().size() > 1) {\n\n                    create \"assmble{ProductFlavorList}\" as anchor task.\n                        it \"Assembles all builds for flavor combination: {ProductFlavorList}\".\n                        let \"assmble{ProductFlavorList}\" dependsOn \"assemble{VariantName}\".\n                    \n                    let \"assemble\" dependsOn \"assmble{ProductFlavorList}\".\n                }\n            }\n        }\n    }\n\n    ...\n}\n```\n\n#### `TaskMananger::createTasksForVariantScope()`\n\n`TaskMananger::createTasksForVariantScope()` 是一个抽象方法，创建基于 Variant 的编译 task，这些编译 task 就是 android 编译 toolchain 的调用者。\n这个方法在各个 TaskMananger 子类中实现不同，这里就选 ApplicationTaskManager 的实现来看。\n\n*下面代码使用伪代码展现*\n\n```\nclass ApplicationTaskManager extends TaskManager {\n    ...\n\n    public void createTasksForVariantScope(\n            @NonNull final TaskFactory tasks, @NonNull final VariantScope variantScope) {\n        BaseVariantData variantData = variantScope.getVariantData();\n        assert variantData instanceof ApplicationVariantData;\n\n        // in createAnchorTasks()\n        create \"pre{VariantName}Build\" task as AppPreBuildTask task. \n            set VariantScope prebuild task with it.\n            let \"pre{VariantName}Build\" dependsOn \"preBuild\".\n        if enable code skrink\n            let \"pre{VariantName}Build\" dependsOn \"extractProguardFiles\".\n\n        create \"generate{VariantName}Sources\" as anchor task. \n            let \"generate{VariantName}Sources\" dependsOn \"prepareLintJar\"\n\n        create \"generate{VariantName}Resources\" as anchor task. \n\n        create \"generate{VariantName}Assets\" as anchor task. \n\n        // @Test，创建单元测试覆盖率报告 task。\n        [+]{...}\n\n        create \"compile{VariantName}Sources\" as anchor task. \n            let \"assemble{VariantName}\" dependsOn \"compile{VariantName}Sources\".\n\n        // in createCheckManifestTask()\n        create \"check{VariantName}Manifest\" as CheckManifest type task. \n            let \"check{VariantName}Manifest\" dependsOn \"pre{VariantName}Build\".\n\n        // @Wear\n        handleMicroApp(tasks, variantScope);\n\n        // 创建基于依赖的 transform stream\n        createDependencyStreams(tasks, variantScope);\n\n        // in createApplicationIdWriterTask()\n        create \"write{VariantName}ApplicationId\" as ApplicationIdWriterTask type task. \n            add \"build/intermediates/applicationId/{ProductFlavorName}/{BuildTypeName}\" to VariantScope outputs.\n\n        // in createMergeApkManifestsTask()\n        create \"create{VariantName}CompatibleScreenManifests\" as CompatibleScreensManifest type task.\n\n        create \"process{VariantName}Manifest\" as MergeManifests type task.\n            let \"process{VariantName}Manifest\" dependsOn \"check{VariantName}Manifest\".\n\n        // in createGenerateResValuesTask()\n        create \"generate{VariantName}ResValues\" as GenerateResValues type task.\n            let \"generate{VariantName}Resources\" dependsOn \"generate{VariantName}ResValues\".\n\n        // in createRenderscriptTask()\n        create \"compile{VariantName}Renderscript\" as RenderscriptCompile type task.\n        if is testing\n            let \"compile{VariantName}Renderscript\" dependsOn \"process{VariantName}Manifest\".\n        else\n            let \"compile{VariantName}Renderscript\" dependsOn \"pre{VariantName}Build\".\n\n        let \"generate{VariantName}Resources\" dependsOn \"compile{VariantName}Renderscript\".\n\n        if not RenderscriptNdkModeEnabled\n            let \"generate{VariantName}Sources\" dependsOn \"compile{VariantName}Renderscript\".\n\n        // in createMergeResourcesTask()\n        create \"merge{VariantName}Resources\" as MergeResources type task.\n            let \"merge{VariantName}Resources\" dependsOn \"generate{VariantName}Resources\".\n\n        // in createMergeAssetsTask()\n        create \"merge{VariantName}Assets\" as MergeSourceSetFolders type task.\n            let \"merge{VariantName}Assets\" dependsOn \"generate{VariantName}Assets\".\n\n        // in createBuildConfigTask()\n        create \"generate{VariantName}BuildConfig\" as GenerateBuildConfig type task.\n            let \"generate{VariantName}Sources\" dependsOn \"generate{VariantName}BuildConfig\".\n            if is testing\n                let \"generate{VariantName}BuildConfig\" dependsOn \"process{VariantName}Manifest\".\n            else \n                let \"generate{VariantName}BuildConfig\" dependsOn \"check{VariantName}Manifest\".\n\n        // in createApkProcessResTask()\n        create \"process{VariantName}Resources\" as ProcessAndroidResources type task.\n            let \"generate{VariantName}Sources\" dependsOn \"process{VariantName}Resources\".\n\n        create \"process{VariantName}JavaRes\" as Sync type task.\n            let \"process{VariantName}JavaRes\" dependsOn \"pre{VariantName}Build\".\n\n        // in createAidlTask()\n        create \"compile{VariantName}Aidl\" as AidlCompile type task.\n            let \"generate{VariantName}Sources\" dependsOn \"compile{VariantName}Aidl\".\n            let \"compile{VariantName}Aidl\" dependsOn \"pre{VariantName}Build\".\n\n        // in createShaderTask()\n        create \"merge{VariantName}Shaders\" as MergeSourceSetFolders type task.\n        create \"compile{VariantName}Shaders\" as ShaderCompile type task.\n            let \"compile{VariantName}Shaders\" dependsOn \"merge{VariantName}Shaders\".\n            let \"generate{VariantName}Assets\" dependsOn \"compile{VariantName}Shaders\".\n\n        // @NDK, ndk 编译任务\n        [+]{...}\n\n        // in createMergeJniLibFoldersTasks()\n        create \"merge{VariantName}JniLibFolders\" as MergeSourceSetFolders type task.\n            let \"merge{VariantName}JniLibFolders\" dependsOn \"generate{VariantName}Assets\".\n\n        create \"mergedJniFolder\" stream\n            type ExtendedContentType.NATIVE_LIBS\n            scope Scope.PROJECT\n            from {@File 'intermediates/jniLibs/{VariantConfigurationDir}'}\n            let stream depend on \"merge{VariantName}JniLibFolders\" task\n\n        // @NDK, 创建当前工程 ndk 编译产出的 so 文件以及 obj 文件 的 stream\n        [+]{...}\n\n        // @RenderScript, 创建当前工程 rs 编译产物的 stream\n        [+]{...}\n\n        create \"transformNativeLibsWithMergeJniLibsFor{VariantName}\" task\n            with \"mergeJniLibs\" transform as MergeJavaResourcesTransform type.\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES. \n\n\n        // @DataBinding\n        createDataBindingTasksIfNecessary(tasks, variantScope);\n\n        // 创建 java 编译 task。\n        addCompileTask();\n\n        // @Ndk\n        createStripNativeLibraryTask(tasks, variantScope);\n\n        // @Multi\n        createSplitTasks(tasks, variantScope);\n\n        // @InstantRun\n        [+]{...}\n\n        // 创建打包 task。\n        createPackagingTask(tasks, variantScope, buildInfoWriterTask);\n\n        // in createLintTasks()\n        create \"lint{VariantName}\" as LintPerVariantTask type.\n    }\n\n    ...\n}\n```\n\n`TaskMananger::createDependencyStreams` 为 external 依赖（maven 或者 local jar 文件）和工程依赖创建 Android Transform stream 对象，使来自依赖的文件（主要是 class 文件）参与到 Android Transform 过程中。\n\n```\nclass TaskMananger {\n    ...\n\n    protected void createDependencyStreams(\n            @NonNull TaskFactory tasks,\n            @NonNull final VariantScope variantScope) {\n        \n        // @Test, 基于测试覆盖率需求，修改 Configuration\n        handleJacocoDependencies(variantScope);\n\n        TransformManager transformManager = variantScope.getTransformManager();\n\n        create \"ext-libs-classes\" stream\n            type DefaultContentType.CLASSES\n            scope Scope.EXTERNAL_LIBRARIES\n            from ArtifactType.CLASSES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  \n\n        create \"ext-libs-res-plus-native\" stream\n            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS\n            scope Scope.EXTERNAL_LIBRARIES\n            from ArtifactType.JAVA_RES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  \n\n        // and the android AAR also have a specific jni folder\n        create \"ext-libs-native\" stream\n            type ExtendedContentType.NATIVE_LIBS\n            scope Scope.EXTERNAL_LIBRARIES\n            from ArtifactType.JNI files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH\n\n        // data binding related artifacts for external libs\n        // @DataBinding, 创建 dataBinding 需要的 steams\n        if (extension.getDataBinding().isEnabled()) {\n            {...}\n        }\n\n        // for the sub modules, new intermediary classes artifact has its own stream\n        create \"sub-projects-classes\" stream\n            type DefaultContentType.CLASSES\n            scope Scope.SUB_PROJECTS\n            from ArtifactType.CLASSES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH\n\n        // same for the resources which can be java-res or jni\n        create \"sub-projects-res-plus-native\" stream\n            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS\n            scope Scope.SUB_PROJECTS\n            from ArtifactType.JAVA_RES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH\n\n        // and the android library sub-modules also have a specific jni folder\n        create \"sub-projects-native\" stream\n            type ExtendedContentType.NATIVE_LIBS\n            scope Scope.SUB_PROJECTS\n            from ArtifactType.JNI files in ArtifactScope.MODULE on RUNTIME_CLASSPATH\n\n        // provided only scopes.\n        create \"provided-classes\" stream\n            type DefaultContentType.CLASSES\n            scope Scope.PROVIDED_ONLY\n            from ArtifactType.JNI files in ArtifactScope.MODULE on (COMPILE_CLASSPATH minus RUNTIME_CLASSPATH)\n        \n        // @Test,  创建 test 需要的 steams\n        if (variantScope.getTestedVariantData() != null) {\n            {...}\n        }\n    }\n\n    ...\n}\n```\n\ncompile 任务创建流程: \n\n```\nclass ApplicationTaskManager extends TaskManager {\n    ...\n\n    private void addCompileTask(@NonNull TaskFactory tasks, @NonNull VariantScope variantScope) {\n        \n        // @DataBinding\n        createDataBindingMergeArtifactsTaskIfNecessary(tasks, variantScope);\n\n        // in createJavacTask()\n        create \"javaPreCompile{VariantName}\" as JavaPreCompileTask type.\n            let \"javaPreCompile{VariantName}\" dependsOn \"pre{VariantName}Build\"\n\n        create \"compile{VariantName}JavaWithJavac\" as AndroidJavaCompile type.\n            let \"compile{VariantName}JavaWithJavac\" dependsOn \"generate{VariantName}Sources\"\n\n        // Create the classes artifact for uses by external test modules.\n        create \"bundleAppClasses{VariantName}\" as Jar type.\n\n\n        // @Java8，一些基于 java8 配置的 validation 工作。\n        [+]{...}\n\n        // in addJavacClassesStream(variantScope)\n        create \"javac-output\" stream\n            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES\n            scope Scope.PROJECT\n            from JAVAC output on variantScope\n\n        create \"pre-javac-generated-bytecode\" stream\n            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES\n            scope Scope.PROJECT\n            from PreJavacGeneratedBytecode\n\n        create \"post-javac-generated-bytecode\" stream\n            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES\n            scope Scope.PROJECT\n            from PostJavacGeneratedBytecode\n        \n\n        // in setJavaCompilerTask()\n        let \"compile{VariantName}Sources\" dependsOn \"compile{VariantName}JavaWithJavac\".\n\n        // 创建生成 dex 相关的 task。\n        createPostCompilationTasks(tasks, variantScope);\n    }\n\n    ...\n}\n```\n\n```\nclass TaskMananger {\n    ...\n\n    public void createPostCompilationTasks(\n            @NonNull TaskFactory tasks,\n            @NonNull final VariantScope variantScope) {\n\n        checkNotNull(variantScope.getJavacTask());\n\n        final BaseVariantData variantData = variantScope.getVariantData();\n        final GradleVariantConfiguration config = variantData.getVariantConfiguration();\n\n        TransformManager transformManager = variantScope.getTransformManager();\n        // ---- Code Coverage first -----\n        \n        // @Test，创建测试覆盖率相关的 transform\n        if (isTestCoverageEnabled) {\n            createJacocoTransform(tasks, variantScope);\n        }\n\n        // in maybeCreateDesugarTask(tasks, variantScope, config.getMinSdkVersion(), transformManager)\n\n        // 如果 java8 支持使用 desuger\n        if (variantScope.getJava8LangSupportType() == Java8LangSupport.DESUGAR) {\n            create \"transformClassWithStackFramesFixerFor{VariantName}\" task \n                with \"stackFramesFixer\" transform as FixStackFramesTransform type.\n                on Scope.EXTERNAL_LIBRARIES\n\n            create \"transformClassWithDesugarFor{VariantName}\" task as TransformTask\n                with \"desugar\" transform as DesugarTransform type.\n                on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n\n            // 如果 minSdk.getFeatureLevel() 小于 19\n            if (minSdk.getFeatureLevel()\n                    < DesugarProcessBuilder.MIN_SUPPORTED_API_TRY_WITH_RESOURCES) {\n                create \"extractTryWithResourcesSupportJar{VariantName}\" as ExtractTryWithResourcesSupportJar type.\n                    let {@File 'intermediates/processing-tools/runtime-deps/{VariantConfigurationDir}/desugar_try_with_resources.jar'} depend on \"extractTryWithResourcesSupportJar{VariantName}\".\n\n                create 'runtime-deps-try-with-resources' stream\n                    type DefaultContentType.CLASSES\n                    scope Scope.EXTERNAL_LIBRARIES\n                    from {@File 'intermediates/processing-tools/runtime-deps/{VariantConfigurationDir}/desugar_try_with_resources.jar'}\n            }\n        }\n\n        AndroidConfig extension = variantScope.getGlobalScope().getExtension();\n\n        // in createMergeJavaResTransform(tasks, variantScope)\n        create 'transformResourcesWithMergeJavaResFor{VariantName}' task\n            with 'mergeJavaRes' transform as MergeJavaResourcesTransform type\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES \n        \n\n        // 处理开发者自行注册的 transform\n        // ----- External Transforms -----\n        // apply all the external transforms.\n        List<Transform> customTransforms = extension.getTransforms();\n        List<List<Object>> customTransformsDependencies = extension.getTransformsDependencies();\n\n        for (int i = 0, count = customTransforms.size(); i < count; i++) {\n            Transform transform = customTransforms.get(i);\n\n            List<Object> deps = customTransformsDependencies.get(i);\n            transformManager\n                    .addTransform(tasks, variantScope, transform)\n                    .ifPresent(t -> {\n                        if (!deps.isEmpty()) {\n                            t.dependsOn(tasks, deps);\n                        }\n\n                        // if the task is a no-op then we make assemble task depend on it.\n                        if (transform.getScopes().isEmpty()) {\n                            variantScope.getAssembleTask().dependsOn(tasks, t);\n                        }\n                    });\n        }\n\n        // @IDE \n        // ----- Android studio profiling transforms\n        [+]{...}\n\n        // 创建包大小压缩的 transform\n        // ----- Minify next -----\n        // in maybeCreateJavaCodeShrinkerTransform(tasks, variantScope)\n        create 'transformClassAndResourcesWithProguardFor{VariantName}' task\n            with 'proguard' as ProGuardTransform type\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n\n        create 'transformClassWithAndroidGradleClassShrinkerFor{VariantName}' task\n            with 'androidGradleClassShrinker' as BuiltInShrinkerTransform type\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n\n        create 'check{VariantName}ProguardFiles' as CheckProguardFiles type\n            let 'transformClassAndResourcesWithProguardFor{VariantName}' or 'transformClassWithAndroidGradleClassShrinkerFor{VariantName}' depend on 'check{VariantName}ProguardFiles'\n        \n        // in  maybeCreateResourcesShrinkerTransform(tasks, variantScope)\n        create 'transformClassWithShrinkResFor{VariantName}' task\n            with shrinkRes transform as ShrinkResourcesTransform type\n            on empty scope\n\n\n        // @InstantRun\n        // ----- 10x support\n        [+] {...}\n        \n        // ----- Multi-Dex support\n\n        DexingType dexingType = variantScope.getDexingType();\n\n        // Upgrade from legacy multi-dex to native multi-dex if possible when using with a device\n        if (dexingType == DexingType.LEGACY_MULTIDEX) {\n            if (variantScope.getVariantConfiguration().isMultiDexEnabled()\n                    && variantScope\n                                    .getVariantConfiguration()\n                                    .getMinSdkVersionWithTargetDeviceApi()\n                                    .getFeatureLevel()\n                            >= 21) {\n                dexingType = DexingType.NATIVE_MULTIDEX;\n            }\n        }\n\n        Optional<AndroidTask<TransformTask>> multiDexClassListTask;\n\n        if (dexingType == DexingType.LEGACY_MULTIDEX) {\n            boolean proguardInPipeline = variantScope.getCodeShrinker() == CodeShrinker.PROGUARD;\n\n            // If ProGuard will be used, we'll end up with a \"fat\" jar anyway. If we're using the\n            // new dexing pipeline, we'll use the new MainDexListTransform below, so there's no need\n            // for merging all classes into a single jar.\n            if (!proguardInPipeline && !usingIncrementalDexing(variantScope)) {\n                // Create a transform to jar the inputs into a single jar. Merge the classes only,\n                // no need to package the resources since they are not used during the computation.\n                 create 'transformClassWithJarMergingFor{VariantName}' task\n                    with jarMerging transform as JarMergingTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n            }\n\n            // ---------\n            // create the transform that's going to take the code and the proguard keep list\n            // from above and compute the main class list.\n            Transform multiDexTransform;\n            if (usingIncrementalDexing(variantScope)) {\n                create 'transformClassWithMultidexlistFor{VariantName}' task\n                    with multidexlist transform as MainDexListTransform type\n                    on empty scope\n                    set multiDexTransform with it\n            } else {\n                create 'transformClassWithMultidexlistFor{VariantName}' task\n                    with multidexlist transform as MultiDexTransform type\n                    on empty scope\n                    set multiDexTransform with it\n            }\n            multiDexClassListTask =\n                    transformManager.addTransform(tasks, variantScope, multiDexTransform);\n            multiDexClassListTask.ifPresent(variantScope::addColdSwapBuildTask);\n        } else {\n            multiDexClassListTask = Optional.empty();\n        }\n\n        if (usingIncrementalDexing(variantScope)) {\n            // in createNewDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)\n            create 'transformClassWithDexBuilderFor{VariantName}' task\n                    with dexBuilder transform as DexArchiveBuilderTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n\n            if (dexingType != DexingType.LEGACY_MULTIDEX\n                && variantScope.getCodeShrinker() == null\n                && extension.getTransforms().isEmpty()) {\n                \n                create 'transformDexArchiveWithExternalLibsDexMergerFor{VariantName}' task\n                    with externalLibsDexMerger transform as ExternalLibsMergerTransform type\n                    on Scope.EXTERNAL_LIBRARIES\n            }\n\n            create 'transformDexArchiveWithDexMergerFor{VariantName}' task\n                    with dexMerger transform as DexMergerTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n            let 'transformDexWithDexMergerFor{VariantName}' depend on 'transformClassWithMultidexlistFor{VariantName}'\n\n        } else {\n            // in createDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)\n\n            if (preDexEnabled) {\n                create 'transformClassWithPreDexFor{VariantName}' task\n                    with preDex transform as PreDexTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n            }\n\n            if (!preDexEnabled || dexingType != DexingType.NATIVE_MULTIDEX) {\n                // run if non native multidex or no pre-dexing\n                create 'transformClassWithDexFor{VariantName}' task\n                    with dex transform as DexTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n\n                let 'transformClassWithDexFor{VariantName}' depend on 'transformClassWithMultidexlistFor{VariantName}'\n            }\n\n        }\n\n        // @InstantRun\n        [+]{...}\n    }\n\n    ...\n}\n```\n\npackage 任务创建流程\n\n```\nclass TaskManager {\n    ...\n\n    public void createPackagingTask(\n            @NonNull TaskFactory tasks,\n            @NonNull VariantScope variantScope,\n            @Nullable AndroidTask<BuildInfoWriterTask> fullBuildInfoGeneratorTask) {\n        ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();\n\n        boolean signedApk = variantData.isSigned();\n\n        create \"package{VariantName}\" as PackageApplication type.\n\n        // @InstantRun\n        [+]{...}\n\n        let \"package{VariantName}\" dependsOn \"merge{VariantName}Assets\".\n        let \"package{VariantName}\" dependsOn \"process{VariantName}Resources\".\n\n        // @InstantRun\n        [+]{...}\n\n        create \"validateSigning{VariantName}\" as ValidateSigningTask type.\n            let \"package{VariantName}\" dependsOn \"validateSigning{VariantName}\".\n\n        let \"package{VariantName}\" dependsOn \"compile{VariantName}JavaWithJavac\".\n        let \"assemble{VariantName}\" dependsOn package{VariantName}\".\n\n        // @InstantRun\n        [+]{...}\n\n        // @Multi\n        [+]{...}\n\n        if (signedApk) {\n            create \"install{VariantName}\" as InstallVariantTask type.\n                let \"install{VariantName}\" dependsOn \"assemble{VariantName}\".\n        }\n\n        // in maybeCreateLintVitalTask()\n        create \"lintVital{VariantName}\" as LintPerVariantTask type.\n            let \"lintVital{VariantName}\" dependsOn \"compile{VariantName}JavaWithJavac\".\n        let \"assemble{VariantName}\" dependsOn \"lintVital{VariantName}\".\n\n        // 如果任务树中包含 \"lint\"，就不再执行 \"lintVital{VariantName}\".\n        project.getGradle().getTaskGraph().whenReady(\n            taskGraph -> {\n                if (taskGraph.hasTask(getTaskPath(LINT))) {\n                    project.getTasks()\n                            .getByName(lintReleaseCheck.getName())\n                            .setEnabled(false);\n                }});\n\n        create \"uninstall{VariantName}\" as UninstallTask type.\n            let \"uninstallAll\" dependsOn \"uninstall{VariantName}\".\n    }\n\n    ...\n}\n```\n\n#### `ApiObjectFactory.create()`\n\n基于 BaseVariantData 对象创建 BaseVariantImpl 对象, 并将 BaseVariantImpl 对象加入 extension 的容器中，到这里 project 模型的搭建完成。\n\n```\npublic BaseVariantImpl create(BaseVariantData variantData) {\n    if (variantData.getType().isForTesting()) {\n        // Testing variants are handled together with their \"owners\".\n        createVariantOutput(variantData, null);\n        return null;\n}\n\n    BaseVariantImpl variantApi =\n        variantFactory.createVariantApi(\n            instantiator,\n            objectFactory,\n            androidBuilder,\n            variantData,\n            readOnlyObjectProvider);\n\n    if (variantApi == null) {\n        return null;\n    }\n\n    // @Test\n    if (variantFactory.hasTestScope()) {\n        // 创建 TestVariantImpl 对象和 UnitTestVariantImpl 对象\n        [+]{...}\n    }\n\n    // in createVariantOutput(variantData, variantApi)\n    // 创建 VariantOutputFactory 对象\n    variantData.variantOutputFactory =\n        new VariantOutputFactory(\n            (variantData.getType() == LIBRARY)\n                    ? LibraryVariantOutputImpl.class\n                    : ApkVariantOutputImpl.class,\n            instantiator,\n            extension,\n            variantApi,\n            variantData);\n\n    // 修改 apk 输出的的 versionCode 和 versionName\n    variantData\n            .getOutputScope()\n            .getApkDatas()\n            .forEach(\n                apkData -> {\n                    apkData.setVersionCode(\n                        variantData.getVariantConfiguration().getVersionCode());\n                    apkData.setVersionName(\n                        variantData.getVariantConfiguration().getVersionName());\n                    variantData.variantOutputFactory.create(apkData);\n                });\n\n    // 将 BaseVariantImpl 对象置入 extension 的 variantList 容器中\n    // Only add the variant API object to the domain object set once it's been fully\n    // initialized.\n    extension.addVariant(variantApi);\n\n    return variantApi;\n}\n```\n\n\n### Android Transform 体系\n\n## 附表\n\n### android plugin 支持的 gradle properties\n\n","source":"_drafts/android-plugin-overview.md","raw":"---\ntitle: Android 编译流程概览与编译入口源码分析\ncatalog: true\nsubtitle: Android 编译源码学习笔记 0x01\nheader-img: /img/header_img/platform-source-header.jpg\ntags:\n  - Android\ncategories:\n  - 源码分析\n---\n\n## Why ?\n目标：使 Android 编译过程由黑盒变为白盒。  \n好处： \n\n* 理解 android plugin 接口含义和能力，更好的编写编译脚本。  \n* 熟悉 android gradle 任务树，方便在编写 gradle 插件时 hook android 编译任务。 \n* 看懂编译中间产物、以及熟练的调试编译源码，以便在开发时定位编译时发生的问题。 \n* 了解 android 编译 toolChain 和 编译输出，是进一步学习 Android Runtime 的基础。 \n\n## 行文\n版本：源码基于 android plugin 3.0.0，gradle 4.1。   \n主流程：   \n首先，在本篇概览中会概述 Android 的编译流程，浏览 android plugin 的入口源码。   \n而后，分别详述编译流程中的各个阶段 ：针对该编译阶段所涉及的 plugin api、project 模型、编译任务、toolChain、输入以及输出进行纵向分析，可能会浏览该阶段编译任务以及 toolChain 的源码。   \n最后，会分析 application 工程和 library 工程在编译时的区别。   \n\n副流程：   \nAndroid 编译中涉及到了很多 Optional 的话题，这些话题会渗透到编译流程的各个阶段。将这些话题从主流程中分离出来，以切面的形式归纳为副流程分别单独学习，也许是更好的方式。   \n\n副流程也许会包括 (排在越后面，会被包括的可能性越小)：\n\n* Java8 support。\n* Kotlin。\n* AppBundle\n* 单元测试与集成测试。\n* Lint。\n* Ndk。\n* Instant Run。\n* DataBinding。\n* Wear & TV support。\n* IDE。\n\n\n## 结构\n\ngradle 编译脚本 &  -> plugin api -> project 模型 -> 编译任务树 & Transtrom 流 -> toolChain -> 中间产物文件流 -> 编译输出\n\n结构基础：gradle api、 gradle、android sdk。\n\n这一篇会包含 plugin api -> project 模型 -> 编译任务树 & Transtrom 流 三个部分；之后在各个编译流程流程中会涉及到 编译任务树 & Transtrom 流  -> toolChain -> 中间产物文件流。   \n\n## android plugin api 概览 \n\nplugin api 是 android 编译系统暴露给开发者的配置接口，以基于 gradle & groovy 的 DSL (Domain-specific language) 组织而成。plugin api 可以大致被划分为 plugin、extension、dsl model 三个部分：\n\n* plugin 是 android 编译系统的入口，开发者通过 apply plugin 来调用编译系统，进而完成暴露 plugin api，构建 project 模型，生成编译任务等一系列流程。\n* extension 是承载 dsl model 的对象，它通过 delegate 的方式挂载到扩 gradle project 上，方便开发者通过对其成员赋值，从而完成编译配置过程。 \n* dsl model 的接口繁多，是 plugin api 的主体，代表了 android 编译过程的各种配置参数。\n\n### plugins\n\n![Android-Gradle-Plugins](https://i.loli.net/2019/03/07/5c80c1f57f944.jpg)\n\n`BasePlugin` 有多个继承类型，各个继承类型对应了不同类型的 android plugin，以支持不同的 android 编译类型。\n\n* `AppPlugin` (com.android.application)，构建 app 工程。\n* `LibraryPlugin` (com.android.library)，构建 library 工程。\n* `FeaturePlugin` (com.android.feature)，构建 app-bundle。\n* `InstantAppPlugin` (com.android.instantapp)，执行 intant-run。\n* `TestPlugin` （com.android.test)，用单独工程执行 instrumented-test。\n\nandroid plugin 绝大部分配置过程代码都包含在 `BasePlugin` 中，`BasePlugin` 的各个子类仅仅创建并返回了类型不同的 `BaseExtension`、`VariantFactory`、`TaskManager` 实现类对象。基于这些不同的实现对象，使各种编译类型在 plugin api、project 模型和编译任务等方面略有不同。\n\n### extensions\n\n\n\n\n\n\n## android 的 project 模型概览\n\n## android 的编译任务树概览\n\n## 在读源码之前\n\n### 源码工程 -- :gradle 和 :gradle-core\n\n:gradle 包含了 android plugin 链接到 gradle project 的 anchor 类，即一些 plugin 和 extension 类，这里就是 android plugin 的入口。    \n:gradle-core 是 android plugin 的实现工程，里面包含了 project 模型的管理类、 构建任务树的管理类、任务的实现类等。 这些类被 :gralde 工程中的 plugin 调用，处理 开发者编译脚本向 extension 中提交的信息、建立 project 模型、创建 android task，并经过各类 android task 链接到 android 构建的 toolchain。    \n\n### 源码阅读的起点 -- `BasePlugin.apply()`\n\n`BasePlugin` 是所有 android plugin 的基类，`BasePlugin.apply()` 方法可以视为 android plugin 的程序入口。这个方法涵盖了 android plugin 配置阶段的全部过程， 以 `BasePlugin.apply()` 为起点可以了解 android plugin 工程模型的创建过程和任务树的创建过程。\n\n## 源码分析\n\n### `BasePlugin::apply()`\n\n* 进行一系列的 validate 检查。\n* 读取 gradle.properties 文件中所有与 android plugin 有关的配置，并根据这些配置初始化一些编译参数。\n* 调用`configureProject()`、`configureExtension()`、`createTasks()` 三个方法；这三个方法就是 android plugin 配置阶段的主体操作。\n\n```\n protected void apply(@NonNull Project project) {\n        ...\n\n        //AndroidBasePlugin 会被所有 plugin 类型 apply，它不做任何事情，只是方便判断是否有某种 android 的 plugin 类被 applay 过了。\n        project.getPluginManager().apply(AndroidBasePlugin.class);\n        \n        // 检查 builder.jar 的版本号是否和 android plugin 的版本号一致，否则抛异常。\n        // 如果使用了 'com.android.tools.build:gradle-experimental' 中的  gradle-experimental 插件，\n        // 并且其版本和 'com.android.tools.build:gradle' 的版本不一致，\n        // 那么就会出现 builder.jar 的版本号是否和 android plugin 的版本号不一致的情况。\n        // TODO: what's gradle-experimental\n        checkPluginVersion();\n\n        this.project = project;\n\n        // ProjectOptions 是一个 Immutable 模型对象，它包含了很多类型为 Option<String> 对象。\n        // ProjectOptions 实际上是一个 key-value 形式的配置表，包含了 gradle.properties 文件中所有与 android plugin 有关的配置。\n        // 各类配置被定义在 :gradle-core > com.android.build.gradle.options 包下面的枚举类中。\n        // 这些配置大多以 'android.' 开头，详见附表部分。\n        this.projectOptions = new ProjectOptions(project);\n\n        // 由  {@GradleProperties 'android.threadPoolSize'} 配置来设置 ExecutorSingleton 的线程池尺寸。\n        ExecutionConfigurationUtil.setThreadPoolSize(projectOptions);\n\n        //在 window 平台上，gradle 工程 根目录的绝对路径上不能有非ASCII字符，否则就抛出异常，原因参见 http://b.android.com/95744；可以配置{@GradleProperties 'android.overridePathCheck'} = true 屏蔽这个检查。\n        checkPathForErrors();\n\n        //gradle 工程中，不能存在两个同名的子工程，否则就抛出异常。\n        checkModulesForErrors();\n        \n        // PluginInitializer 用于验证两件事情：\n        // 在一次构建中，不同子工程使用的 android plugin 版本一致。\n        // 在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。\n        PluginInitializer.initialize(project, projectOptions);\n\n        // ProfilerInitializer 通过向 gradle 注册监听，记录*当前子工程*所有 gradle task 的执行时间。\n        // 当构建结束之后，将所记录的时间输出到 'project.getRootProject()/build/android-profile/profile-'YYYY-MM-dd-HH-mm-ss-SSS'.rawproto' 文件中。\n        // TODO: 这个文件的作用是什么？猜测是给 IDE 用的。\n        ProfilerInitializer.init(project, projectOptions);\n\n        ...\n\n        // 涵盖 BasePlugin 主体操作的三个 private 方法。 \n        configureProject()\n        configureExtension()\n        createTasks()\n    }\n```\n\n#### `PluginInitializer`\n\n`PluginInitializer` 这个类比较有意思，它的作用是验证 android plugin 在各个子工程之间一致性。具体来说包含如下两方面验证：\n* 在一次构建中，不同子工程使用的 android plugin 版本一致。\n* 在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。\n那么问题来了，无论是不同的子工程使用了不同的 android plugin 版本，还是 android plugin 的 class 文件被不同的 classloader 加载，都会在 jvm 中形成两套相互独立的 class，要如何检测这种情况呢。\n`PluginInitializer` 有两个静态变量分别负责上述两种检查，分别是 `projectToPluginVersionMap` 和 `loadedPluginClass`，这两个变量是通过 `JvmWideVariable` 获得的。`JvmWideVariable` 提供了一种直接在 jvm 创建对象的方式，并通过字符串 key 来获取对象引用。所以 `PluginInitializer` 的 `projectToPluginVersionMap` 和 `loadedPluginClass` 并不是和 class 绑定的静态对象，而是通过字符串 key 直接维护在 jvm 的堆中。只要不同版本的 android plugin 使用相同的 key 从 jvm 中创建和获取对象，那么即使是相互独立的 class 也能取得同一个对象，从而经由不同版本 android plugin 相互协作实现 `PluginInitializer` 所需验证的情况。\n可以看见源码中对于 key 常量有如下注释：\n\n>IMPORTANT: This variable's group, name, and type must not be changed across\nplugin versions.\n\n另外，什么情况下会发生 android plugin 被不同的 classloader 加载呢？源码的异常信息中给了如下解释，如果有兴趣可以看[issue链接](https://d.android.com/r/tools/buildscript-classpath-check.html)\n\n> Due to a limitation of Gradle’s new variant-aware dependency management, loading the Android Gradle plugin in different class loaders leads to a build error.   \n> This can occur when the buildscript classpaths that contain the Android Gradle plugin in sub-projects, or included projects in the case of composite builds, are set differently.   \n> To resolve this issue, add the Android Gradle plugin to only the buildscript classpath of the top-level build.gradle file.   \n> In the case of composite builds, also make sure the build script classpaths that contain the Android Gradle plugin are identical across the main and included projects.   \n> If you are using a version of Gradle that has fixed the issue, you can disable this check by setting android.enableBuildScriptClasspathCheck=false in the gradle.properties file.   \n> To learn more about this issue, go to https://d.android.com/r/tools/buildscript-classpath-check.html.   \n\n\n```\npublic final class PluginInitializer {\n\n    // Map<gradle project 对象 , android plugin 版本的> , 所用版本的 android plugin 共用一个对象，用于判断是否存在多个版本。\n    // IMPORTANT: This variable's group, name, and type must not be changed across plugin versions.\n    @NonNull\n    private static final ConcurrentMap<Object, String> projectToPluginVersionMap =\n            Verify.verifyNotNull(\n                    new JvmWideVariable<>(\n                                    \n                                    \"PLUGIN_VERSION_CHECK\",\n                                    \"PROJECT_TO_PLUGIN_VERSION\",\n                                    new TypeToken<ConcurrentMap<Object, String>>() {},\n                                    ConcurrentHashMap::new)\n                            .get());\n\n    // AndroidBasePlugin.class 的引用，对于同一个 android plugin 版本的多次加载而言，共用一个对象，用于判断同一个版本是否被多个 classloader 加载。\n    @NonNull\n    private static final AtomicReference<Class<?>> loadedPluginClass =\n            Verify.verifyNotNull(\n                    new JvmWideVariable<>(\n                                    PluginInitializer.class.getName(),\n                                    \"loadedPluginClass\",\n                                    Version.ANDROID_GRADLE_PLUGIN_VERSION,\n                                    new TypeToken<AtomicReference<Class<?>>>() {},\n                                    () -> new AtomicReference<>(null))\n                            .get());\n\n    public static void initialize(\n        \n        // BuildSessionImpl 提供了一整次 gradle 构建结束的监听 (例如一次命令行输入全部执行完成)。\n        // 这里注册监听，当一整次构建结束之后，重置 projectToPluginVersionMap 和 loadedPluginClass。\n        // 由于 gradle 有进程重用机制，多次构建可能发生在同一个进程；只需要保证在一整次构建中，版本一致性，所以构建完成后重置状态。\n        BuildSessionImpl.getSingleton().initialize(project.getGradle());\n        BuildSessionImpl.getSingleton()\n                .executeOnceWhenBuildFinished(\n                        PluginInitializer.class.getName(),\n                        \"resetPluginCheckVariables\",\n                        () -> {\n                            projectToPluginVersionMap.clear();\n                            loadedPluginClass.set(null);\n                        });\n\n        // 向 projectToPluginVersionMap 中写入当前工程对象和现在所执行的 android plugin 版本，如果 Map 中有两个不一样的 android plugin 版本，那么就抛出异常。\n        synchronized (projectToPluginVersionMap) {\n            verifySamePluginVersion(\n                    projectToPluginVersionMap, project, Version.ANDROID_GRADLE_PLUGIN_VERSION);\n        }\n\n        // 向 loadedPluginClass 写入现在所执行的 android plugin 的 AndroidBasePlugin.class 对象，如果 loadedPluginClass 保存了和写入的 AndroidBasePlugin.class 对象不同的值，则抛出异常。\n        // 配置 {@GradleProperties 'android.enableBuildScriptClasspathCheck'} = false 来屏蔽这个检查。\n        verifyPluginLoadedOnce(\n                loadedPluginClass,\n                AndroidBasePlugin.class,\n                projectOptions.get(BooleanOption.ENABLE_BUILDSCRIPT_CLASSPATH_CHECK));\n    }\n\n```\n\n### `BasePlugin::apply() > configureProject()`\n\n`configureProject()` 做了一些零散的不易归类初始化任务，这些任务中需要进一步分析的也不多。\n\n```\nprivate void configureProject() {\n\n    // ExtraModelInfo 存储一些不易归类的 extra 信息 ：\n    // * 存储构建过程中的检测到的 waring 和 error 信息，并输出这些信息, 根据这次构建是由 ide 触发的还是开发者触发的，信息可能以 'MACHINE_PARSABLE' 或 'HUMAN_READABLE' 两种格式输出。\n    // TODO: 在后续源码分析中，补充在 ExtraModelInfo 其他信息的作用\n    extraModelInfo = new ExtraModelInfo(projectOptions, project.getLogger());\n\n    // 检查当前 gradle 版本不低于 当前运行的 android plugin 所要求的最低版本，否则抛出异常。\n    // 配置 {@GradleProperties 'android.overrideVersionCheck'} = true，可以仅输出 waring 信息不抛出异常。\n    checkGradleVersion();\n    \n    // SdkHandler 是 android sdk 信息的封装类，在构造方法中会寻找 andorid sdk 的路径。\n    sdkHandler = new SdkHandler(project, getLogger());\n\n    // 当 {@GradleProperties 'android.builder.sdkDownload'} = true、并且当前构建不是由 IDE 触发、并且当前构建的 gradle 建参数不包含 '--offline' 这个三个条件成立时：\n    // SdkHandler 会在使用 android sdk 中工具时自动下载，这样即使不安装 android sdk 也能完成 android 工程构建。\n    //  SdkLibData 时下载信息的抽象，包括 Downloader 对象和 SettingsController 的实现。\n    // SettingsController 是注入下载配置的接口，默认实现中包括了指定使用 https、从{@GradleProperties 'android.sdk.channel'} 中获取下载channel、从 System.getProperties() 获取网络代理信息等。\n    if (!project.getGradle().getStartParameter().isOffline() \n                && projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)\n                && !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) {\n            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());\n            sdkHandler.setSdkLibData(sdkLibData);\n    }  \n\n    // AndroidBuilder 是构建 toolchain 的接口类。\n    androidBuilder = new AndroidBuilder(\n                project == project.getRootProject() ? project.getName() : project.getPath(),\n                creator,\n                new GradleProcessExecutor(project),\n                new GradleJavaProcessExecutor(project),\n                extraModelInfo,\n                getLogger(),\n                isVerbose());\n\n    // @DataBinding 初始化 DataBindingBuilder。\n    [+] {...}\n\n    // apply 了 JavaBasePlugin 插件和 JacocoPlugin 插件\n    project.getPlugins().apply(JavaBasePlugin.class);\n    project.getPlugins().apply(JacocoPlugin.class);\n\n    // 替换 {@Task assemble} 的描述，{@Task assemble} 在 apply JavaBasePlugin.class 之后创建。\n    project.getTasks().getByName(\"assemble\")\n        .setDescription(\"Assembles all variants of all applications and secondary packages.\");\n\n    project.getGradle().addBuildListener(\n        buildFinished(BuildResult buildResult) -> {\n            // 构建结束后一些 release 工作。\n            ExecutorSingleton.shutdown();\n            sdkHandler.unload();\n\n            // 清理 PreDexCache 中的缓存，并将其写在 '{@File gradleProjectRoot}/build/intermediates/dex-cache/cache.xml' 文件\n            // TOOD : 分析 Dex 过程时在回来看这里。\n            PreDexCache.getCache().clear(\n                FileUtils.join(\n                    project.getRootProject().getBuildDir(),\n                    FD_INTERMEDIATES,\n                    \"dex-cache\",\n                    \"cache.xml\"),\n                getLogger());\n                Main.clearInternTables();\n        }\n    )\n\n    // 任务树生成后进行检查：如果任务树中存在 DexTransform 类型的任务，\n    // PreDexCache 从 '{@File gradleProjectRoot}/build/intermediates/dex-cache/cache.xml' 文件加载缓存。\n    // TOOD : 分析 Dex 过程时在回来看这里。\n    project.getGradle().getTaskGraph().addTaskExecutionGraphListener(\n        (taskGraph) -> {\n            for (Task task : taskGraph.getAllTasks()) {\n                if (task instanceof TransformTask) {\n                    Transform transform = ((TransformTask) task).getTransform();\n                    if (transform instanceof DexTransform) {\n                        PreDexCache.getCache().load(\n                            FileUtils.join(\n                                project.getRootProject().getBuildDir(),\n                                FD_INTERMEDIATES,\n                                dex-cache\",\n                                \"cache.xml\"));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n```\n\n#### `SdkHandler` 寻找 android sdk 路径\n\n```\npublic class SdkHandler {\n\n    public SdkHandler(@NonNull Project project,\n                      @NonNull ILogger logger) {\n        this.logger = logger;\n        findLocation(project);\n    }\n\n    private void findLocation(@NonNull Project project) {\n        \n        //@Test \n        [+] {...}\n\n        //读取 '{@File gradleProjectRoot}/local.properties'\n        File rootDir = project.getRootDir();\n        File localProperties = new File(rootDir, FN_LOCAL_PROPERTIES);\n        Properties properties = new Properties();\n        [+] {...}\n\n        // 按照如下优先级寻找 android sdk 路径：\n        // local.properties 的 'sdk.dir' 属性 > local.properties 的 'android.dir' 属性 > \n        // ANDROID_HOME 环境变量 > android.home 环境变量。\n        Pair<File, Boolean> sdkLocation = findSdkLocation(properties, rootDir);\n        sdkFolder = sdkLocation.getFirst();\n        \n        // isRegularSdk 的作用见下面 getSdkLoader() 方法前\n        isRegularSdk = sdkLocation.getSecond();\n\n        //按照如下优先级寻找 ndk路径\n        // local.properties 的 'ndk.dir' 属性 > ANDROID_NDK_HOME 环境变量\n        // > '{@File sdkFolder}/ndk-bundle'\n        ndkFolder = NdkHandler.findNdkDirectory(properties, rootDir);\n\n        // @Ndk 从 local.properties 中读出 'cmake.dir'，并赋值给 cmakePathInLocalProp 属性(File 类型)。\n        [+] {...}\n    }\n\n\n    // 仅当 android sdk 路径是由 local.properties 的 'android.dir' 属性定义时，isRegularSdk 为 false。\n    // 这时认为当前构建使用 \"Platform-based\" 的 android sdk，其文件布局与开发使用的 android sdk 不同，\n    // 所以在解析 android sdk 文件布局时使用 PlatformLoader 而非 DefaultSdkLoader。\n    // 在依赖 android 源码中的 android sdk 而非发布版的 android sdk 会出现这种情况。\n    public synchronized SdkLoader getSdkLoader() {\n        if (sdkLoader == null) {\n            if (isRegularSdk) {\n                sdkLoader = DefaultSdkLoader.getLoader(sdkFolder);\n            } else {\n                sdkLoader = PlatformLoader.getLoader(sdkFolder);\n            }\n        }\n        return sdkLoader;\n    }\n}\n```\n\n### `BasePlugin::apply() > configureExtension()`\n\n* 创建了 extension 对象并将其注册到 gradle project 中，extension 对象包含 android plugin 和用户构建脚本之间的所有 api 对象，这些 api 对象定义的 android plugin api 并承载了构建脚本中的开发者配置。\n* 初始化 project 模型和任务树有关的管理类：TaskManager、VariantManager、VariantFactory，这3个管理类可以说是配置阶段的核心；这些管理类通过注册 api 对象监听事件，收集开发者构建脚本中的配置信息。\n* 创建 FileCache、GlobalScope 等一些上下文对象。\n\n完成 `configureExtension()` 执行后 android plugin 就已经做好执行构建脚本，获取配置信息的准备了。\n\n```\nprivate void configureExtension() {\n\n    // 创建了承载 BuildType、ProductFlavor、SigningConfig 的3个容器。\n    // 这3个容器作为创建 extension 的参数，通过 extension 链接到编译脚步，收集开发者配置。\n    final NamedDomainObjectContainer<BuildType> buildTypeContainer =\n            project.container(BuildType.class,\n                    new BuildTypeFactory(instantiator, project, extraModelInfo));\n    final NamedDomainObjectContainer<ProductFlavor> productFlavorContainer =\n            project.container(ProductFlavor.class,\n                    new ProductFlavorFactory(\n                            instantiator, project, project.getLogger(), extraModelInfo));\n    final NamedDomainObjectContainer<SigningConfig> signingConfigContainer =\n            project.container(SigningConfig.class, new SigningConfigFactory(instantiator));\n\n    // TODO：BaseVariantOutput \n    final NamedDomainObjectContainer<BaseVariantOutput> buildOutputs =\n            project.container(BaseVariantOutput.class);\n    project.getExtensions().add(\"buildOutputs\", buildOutputs);\n\n    // 创建 extension 对象，可以看到之前创建的4个容器最终由 extension 对象持有。\n    // 创建 extension 的过程会完成以下工作：\n    // * 完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；\n    // * 通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；\n    // *为 android plugin api 对象添加默认配置。\n    extension =\n            createExtension(\n                    project,\n                    projectOptions,\n                    instantiator,\n                    androidBuilder,\n                    sdkHandler,\n                    buildTypeContainer,\n                    productFlavorContainer,\n                    signingConfigContainer,\n                    buildOutputs,\n                    extraModelInfo);\n\n    // @Ndk 创建 NdkHandler。\n    [+] {...}\n\n    // 创建 FileCache 和 GlobalScope 对象，FileCache 被 GlobalScope 对象持有。\n    \n    // 当 '{@GradleProperties android.enableBuildCache}' = true 时创建 FileCache。\n    // FileCache 默认缓存路径是 '{@File androidHomeDir}/build-cache'，可以通过 '{@GradleProperties android.buildCacheDir}' 自定义缓存路径。\n    // {@File androidHomeDir} 是选取规则在见后面设置 debug.keystore 的代码分析。\n    // FileCache 的实际作用留到它被使用时再分析。\n    @Nullable\n    FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);\n\n    // GlobalScope 对象是当前 android 工程的上下文对象，它只负责持有对象，方便获取。\n    // GlobalScope 对象 之后分别被 TaskManager、VariantManager、VariantFactory 3个对象持有。\n    GlobalScope globalScope =\n            new GlobalScope(\n                    project,\n                    projectOptions,\n                    androidBuilder,\n                    extension,\n                    sdkHandler,\n                    ndkHandler,\n                    registry,\n                    buildCache);\n\n    // 创建 TaskManager、VariantManager、VariantFactory 3个管理类。\n    variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);\n    taskManager =\n            createTaskManager(\n                    globalScope,\n                    project,\n                    projectOptions,\n                    androidBuilder,\n                    dataBindingBuilder,\n                    extension,\n                    sdkHandler,\n                    ndkHandler,\n                    registry,\n                    threadRecorder);\n    variantManager =\n            new VariantManager(\n                    globalScope,\n                    project,\n                    projectOptions,\n                    androidBuilder,\n                    extension,\n                    variantFactory,\n                    taskManager,\n                    threadRecorder);\n\n\n    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 Add 事件监听。\n    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);\n    buildTypeContainer.whenObjectAdded(\n            buildType -> {\n                SigningConfig signingConfig =\n                        signingConfigContainer.findByName(BuilderConstants.DEBUG);\n                buildType.init(signingConfig);\n                variantManager.addBuildType(buildType);\n            });\n    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);\n\n    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 remove 事件监听。\n    // 禁止开发者对这三个配置做 remove 操作，如果发生就抛出异常。\n    signingConfigContainer.whenObjectRemoved(\n            new UnsupportedAction(\"Removing signingConfigs is not supported.\"));\n    buildTypeContainer.whenObjectRemoved(\n            new UnsupportedAction(\"Removing build types is not supported.\"));\n    productFlavorContainer.whenObjectRemoved(\n            new UnsupportedAction(\"Removing product flavors is not supported.\"));\n\n    // 向 BuildType、ProductFlavor、SigningConfig 3个容器创建 default 成员。\n    // 大多数 VariantFactory 的实现，在这里创建了 'debug' SigningConfig、'debug' BuildType、'release' BuildType。\n    variantFactory.createDefaultComponents(\n            buildTypeContainer, productFlavorContainer, signingConfigContainer);\n}\n```\n\n#### `BuildType`、`ProductFlavor`、`SigningConfig` 容器内容构造\n\n这3个 NamedDomainObjectContainer<T> 类型的容器，在构造时传入 NamedDomainObjectFactory<T> 提供容器内容对象的构造方法。`BuildType` 和 `ProductFlavor` 构造方法都直接调用了构造函数，只有 `SigningConfig` 做了特殊处理。\n\n```\npublic class SigningConfigFactory implements NamedDomainObjectFactory<SigningConfig> {\n\n    ...\n\n    @NonNull\n    public SigningConfig create(@NonNull String name) {\n        SigningConfig signingConfig = instantiator.newInstance(SigningConfig.class, name);\n\n        // 如果 SigningConfig 对象的名字是 'debug'，那么用 android 环境的 debug keystore 来初始化这个对象。\n        // debug keystore 存放的位置在 '{@File androidHomeDir}/debug.keystore'；\n        // debug keystore 配置：store pw -> 'android'，key alias -> 'AndroidDebugKey'，key pw -> 'android'。\n        // {@File androidHomeDir} 为 '{@File homeDir}/.android' ，{@File homeDir} 按以下优先级寻找, ，没找到就会抛异常：\n        // ANDROID_SDK_HOME 环境变量或系统属性 > TEST_TMPDIR 环境变量 > user.home 系统属性 > HOME 环境变量 \n        if (BuilderConstants.DEBUG.equals(name)) {\n            try {\n                signingConfig.initWith(\n                        DefaultSigningConfig.debugSigningConfig(\n                                new File(KeystoreHelper.defaultDebugKeystoreLocation())));\n            } catch (AndroidLocation.AndroidLocationException e) {\n                throw new BuildException(\"Failed to get default debug keystore location.\", e);\n            }\n        }\n        return signingConfig;\n    }\n\n    ...\n}\n```\n\n### `BuildType`、`ProductFlavor`、`SigningConfig` Add 操作监听\n\n总体来说，VariantManager 监听了 `BuildType`、`ProductFlavor`、`SigningConfig` 对象的创建操作，并将被创建的对象分别保存在 map 容器中。\n\n```\nprivate void configureExtension() {\n    ...\n\n    // VariantManager.addSigningConfig() 仅仅将 SigningConfig 对象加入了 VariantManager 的 map 容器持有。\n    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);\n\n    // 这里看起来好像用 'debug' SigningConfig 初始化了所有 BuildType 对象。\n    // 实际上 BuildType.init(SigningConfig) 中有判断，只有 BuildType 的名字也是 'debug' 时才会用调用 BuildType.setSigningConfig(SigningConfig)。\n    buildTypeContainer.whenObjectAdded(\n            buildType -> {\n                SigningConfig signingConfig =\n                        signingConfigContainer.findByName(BuilderConstants.DEBUG);\n                buildType.init(signingConfig);\n                variantManager.addBuildType(buildType);\n            });\n    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);\n\n    ...\n}\n\n```\n\n```\npublic class VariantManager implements VariantModel {\n    ...\n\n    // BuildType 对象的加入引发 SourceSet 和 BuildTypeData 对象的创建。\n    public void addBuildType(@NonNull CoreBuildType buildType) {\n        String name = buildType.getName();\n\n        // 检查 BuildType 名字的合法性，名字不能以 'androidTest' 或 'test' 开头；名字不能为 'lint'。\n        checkName(name, \"BuildType\");\n\n        // BuildType 名字不能和任何 ProductFlavor 相同。\n        if (productFlavors.containsKey(name)) {\n            throw new RuntimeException(\"BuildType names cannot collide with ProductFlavor names\");\n        }\n\n        // 创建和 BuildType 同名的 SourceSet。\n        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(name);\n\n        // @Test，创建名为 '{$BuildTypeName}AndroidTest' 和 '{$BuildTypeName}UnitTest' 的 SourceSet。\n        [+] {...}\n\n        // 创建 BuildTypeData，其持有 BuildType 对象和 3个刚刚创建 SourceSet。\n        BuildTypeData buildTypeData =\n                new BuildTypeData(\n                        buildType, project, mainSourceSet, androidTestSourceSet, unitTestSourceSet);\n        buildTypes.put(name, buildTypeData);\n    }\n\n\n    public void addProductFlavor(@NonNull CoreProductFlavor productFlavor) {\n        String name = productFlavor.getName();\n\n        // 检查 BuildType 名字的合法性，名字不能以 'androidTest' 或 'test' 开头；名字不能为 'lint'。\n        checkName(name, \"ProductFlavor\");\n\n        // ProductFlavor 名字不能和任何 BuildType 相同。\n        if (buildTypes.containsKey(name)) {\n            throw new RuntimeException(\"ProductFlavor names cannot collide with BuildType names\");\n        }\n\n        // 创建和 ProductFlavor 同名的 SourceSet。\n        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(\n                productFlavor.getName());\n\n        // @Test，创建名为 '{$BuildTypeName}AndroidTest' 和 '{$BuildTypeName}UnitTest' 的 SourceSet。\n        [+] {...}\n\n        // 创建 ProductFlavorData，其持有 ProductFlavor 对象和 3个刚刚创建 SourceSet。\n        ProductFlavorData<CoreProductFlavor> productFlavorData =\n                new ProductFlavorData<>(\n                        productFlavor,\n                        mainSourceSet,\n                        androidTestSourceSet,\n                        unitTestSourceSet,\n                        project);\n        productFlavors.put(productFlavor.getName(), productFlavorData);\n    }\n\n    ...\n}\n\n```\n\n#### `BuildTypeData`、`ProductFlavorData` 的创建\n\nBuildTypeData、ProductFlavorData 的基类均为 VariantDimensionData，在导出类中没有特殊操作，仅仅额外持有了 BuildType 和 ProductFlavor 对象，生成任务树之后会额外持有 {@Task assemble{$BuildType}} 和 {@Task assemble{$ProductFlavor}} 的引用。\n\n```\npublic class VariantDimensionData {\n    ...\n\n    private final DefaultAndroidSourceSet sourceSet;\n    private final DefaultAndroidSourceSet androidTestSourceSet;\n    private final DefaultAndroidSourceSet unitTestSourceSet;\n\n    public VariantDimensionData(\n            @NonNull DefaultAndroidSourceSet sourceSet,\n            @Nullable DefaultAndroidSourceSet androidTestSourceSet,\n            @Nullable DefaultAndroidSourceSet unitTestSourceSet,\n            @NonNull Project project) {\n        this.sourceSet = sourceSet;\n        this.androidTestSourceSet = androidTestSourceSet;\n        this.unitTestSourceSet = unitTestSourceSet;\n\n        final ConfigurationContainer configurations = project.getConfigurations();\n\n        // @Test \n        // 让名为 '{$VariantDimensionName}AndroidTestImplementation' 和 '{$VariantDimensionName}UnitTestImplementation' 的 Configuration 继承 '{$VariantDimensionName}Implementation'\n        // 让名为 '{$VariantDimensionName}AndroidTestRuntimeOnly' 和 '{$VariantDimensionName}UnitTestRuntimeOnly' 的 Configuration 继承 '{$VariantDimensionName}RuntimeOnly'\n        if (androidTestSourceSet != null) {\n            makeTestExtendMain(sourceSet, androidTestSourceSet, configurations);\n        }\n        if (unitTestSourceSet != null) {\n            makeTestExtendMain(sourceSet, unitTestSourceSet, configurations);\n        }\n\n    }\n\n    ...\n}\n```\n\n#### `BasePlugin::configureExtension() > createExtension()`\n\n`createExtension()` 是个抽象函数，不过实际上 BasePlugin 的各个实现类只是构造了不同的 BaseExtension 类的实现，没有在这个方法中做别的事情。\n各个 BaseExtension 类的实现区别也很小，所以这里只会提到 BaseExtension 和 TestedExtension。\n\nBaseExtension\n    -> TestExtension\n    -> TestedExtension\n        -> AppExtension\n        -> LibraryExtension\n            -> FeatureExtension\n    -> InstantAppExtension \n\n在 BaseExtension 的构造函数中：\n* 完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；\n* 通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；\n* 为 android plugin api 对象添加少许默认配置。\n\n*创建 Configuration 的过程使用伪代码展现*\n\n```\npublic abstract class BaseExtension implements AndroidConfig {\n    ...\n\n    BaseExtension(\n            @NonNull final Project project,\n            @NonNull final ProjectOptions projectOptions,\n            @NonNull Instantiator instantiator,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypes,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavors,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigs,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull ExtraModelInfo extraModelInfo,\n            final boolean publishPackage) {\n        \n        // @Simplify 保存构造函数传入的参数。\n        [+] {...}\n\n        logger = Logging.getLogger(this.getClass());\n\n        // 创建 DefaultConfig 对象，DefaultConfig 对象是一个名为 'main' 的特殊的 ProductFlavor，DefaultConfig 和 ProductFlavor 有共同的父类。\n        defaultConfig =\n                instantiator.newInstance(\n                        DefaultConfig.class,\n                        BuilderConstants.MAIN,\n                        project,\n                        instantiator,\n                        project.getLogger(),\n                        extraModelInfo);\n\n        // @Simplify 创建各种 Options 类型对象，都用于描述 android plugin api 并承载编译脚本配置。\n        [+] {...}\n\n        // 创建 SourceSet 容器，容器中的使用 DefaultAndroidSourceSet 类构造。\n        sourceSetsContainer =\n                project.container(\n                        AndroidSourceSet.class,\n                        new AndroidSourceSetFactory(instantiator, project, publishPackage));\n\n        \n        // 监听 SourceSet 容器的 Add 操作。\n        // 当有新的 SoucreSet 加入容器之后，初始化 SourceSet 的默认布局，建与之相对应的 Configuration，设置被创建的 Configuration 之间的 extendsFrom 关系。\n        // 这是段较长的 labor 代码，改为用伪代码分析\n        sourceSetsContainer.whenObjectAdded() {\n            // @Pseudocode\n            sourceSet -> {\n                ConfigurationContainer configurations = project.getConfigurations();\n\n                String sourceSetName = sourceSet.getName();\n\n                // 创建名为 '{SouceSetName}Api'、'{SouceSetName}Implementation'、\n                // '{SouceSetName}RuntimeOnly'、'{SouceSetName}CompileOnly' 的 SourceSet。\n                // 创建名为 '{SouceSetName}Compile'、'{SouceSetName}Provided' 的 SourceSet。\n                // 在 App 工程中创建 '{SouceSetName}Apk'；在 Lib 工程中创建 '{SouceSetName}Publish'。\n                // 对于名为 'main' 的 sourceSet 而言，创建 Configuration 的命名规则特殊处理，不加前缀。\n                Configuration compile = createConfiguration(configurations, sourceSetName + 'Compile');\n                if ({in AppExtension}) {\n                    Configuration apk = createConfiguration(configurations, sourceSetName + 'Apk');\n                } else {\n                    Configuration apk = createConfiguration(configurations, sourceSetName + 'Publish');\n                }\n                Configuration provided = createConfiguration(configurations, sourceSetName + 'Provided');\n                Configuration api = createConfiguration(configurations, sourceSetName + 'Api');\n                Configuration implementation = createConfiguration(configurations, sourceSetName + 'Implementation');\n                Configuration runtimeOnly = createConfiguration(configurations, sourceSetName + 'RuntimeOnly');\n                Configuration compileOnly = createConfiguration(configurations, sourceSetName + 'CompileOnly');\n\n                // compile、apk、provided 3个 Configuration 属于 Depercated 设定。\n                // 当这3个 Configuration 有任何 dependency 增加时输出 warning。\n                compile.getAllDependencies().whenObjectAdded(\n                    new DeprecatedConfigurationAction());\n                apk.getAllDependencies().whenObjectAdded(\n                    new DeprecatedConfigurationAction());\n                provided.getAllDependencies().whenObjectAdded(\n                    new DeprecatedConfigurationAction());\n\n                // 设置 extendsFrom 关系。\n                api.extendsFrom(compile);\n                implementation.extendsFrom(api);\n                runtimeOnly.extendsFrom(apk);\n                compileOnly.extendsFrom(provided);\n\n                // @Wear 创建名为 '{SouceSetName}WearApp' 的 Configuration。\n                [+] {...}\n\n                // '{SouceSetName}AnnotationProcessor' 的 Configuration。\n                // 用于做 apt。\n                createConfiguration(configurations, sourceSetName + 'AnnotationProcessor');\n\n                // 设置 sourceSet 的默认布局：\n                // java -> 'src/{SouceSetName}/java'\n                // javaResources -> 'src/{SouceSetName}/resources'\n                // res -> 'src/{SouceSetName}/res'\n                // assets -> 'src/{SouceSetName}/assets'\n                // manifest -> 'src/{SouceSetName}/AndroidManifest.xml'\n                // aidl -> 'src/{SouceSetName}/aidl'\n                // renderscript -> 'src/{SouceSetName}/rs'\n                // jni -> 'src/{SouceSetName}/jni'\n                // jniLibs -> 'src/{SouceSetName}/jniLibs'\n                // shaders -> 'src/{SouceSetName}/shaders'\n                sourceSet.setRoot(String.format(\"src/%s\", sourceSet.getName()));\n            }\n        }\n\n        // @Test 创建名为 'androidTestUtil' 的 Configuration\n        [+] {...}\n        \n        // 创建名为 'main' 的 SourceSet。\n        sourceSetsContainer.create(defaultConfig.getName());\n\n        // 设置一些默认的编译脚本配置。\n        // 设置默认的 buildTools Revision，如果开发者没有在编译脚本中指定，就使用默认版本。不同版本的 android plugin 定一个默认 buildTools 版本不同。\n        buildToolsRevision = AndroidBuilder.DEFAULT_BUILD_TOOLS_REVISION;\n        // 这个函数会对 DefaultConfig 对象做一些有关矢量图的配置。 \n        setDefaultConfigValues();\n    }\n\n    ...\n}\n```\n\n在 TestedExtension 的构造函数中创建了名为 'androidTest' 和 'test' 的 SourceSet，与 'main' SourceSet 对应是默认存在基础 SourceSet。\n\n```\n// TestedExtension 是 AppExtension、LibraryExtension、FeatureExtension 的父类。\npublic abstract class TestedExtension extends BaseExtension implements TestedAndroidConfig {\n\n    ...\n    public TestedExtension(\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull Instantiator instantiator,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull SdkHandler sdkHandler,\n            @NonNull NamedDomainObjectContainer<BuildType> buildTypes,\n            @NonNull NamedDomainObjectContainer<ProductFlavor> productFlavors,\n            @NonNull NamedDomainObjectContainer<SigningConfig> signingConfigs,\n            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,\n            @NonNull ExtraModelInfo extraModelInfo,\n            boolean isDependency) {\n        super(\n                project,\n                projectOptions,\n                instantiator,\n                androidBuilder,\n                sdkHandler,\n                buildTypes,\n                productFlavors,\n                signingConfigs,\n                buildOutputs,\n                extraModelInfo,\n                isDependency);\n        // 创建名为 'androidTest' 和 'test' 的 SourceSet。\n        getSourceSets().create(ANDROID_TEST.getPrefix());\n        getSourceSets().create(UNIT_TEST.getPrefix());\n    }\n\n    ...\n}\n```\n\n#### 构造 `TaskManager`、`VariantManager`、`VariantFactory`\n\nTaskManager 通过 `createTaskManager()` 方法创建，VariantFactory 通过 `createVariantFactory` 方法创建。这两个方法均为抽象方法，在各种 plugin 的实现中，仅仅是调用了各种 TaskManager 和 VariantFactory 实现的构造函数，并无额外的代码。\n\nVariantManager 的构造函数中针对 DebugConfig 对象(DebugConfig 对象在 BaseExtension 构造时被创建)做了一些处理。\n\n\n```\npublic class VariantManager implements VariantModel {\n    ...\n\n    public VariantManager(\n            @NonNull GlobalScope globalScope,\n            @NonNull Project project,\n            @NonNull ProjectOptions projectOptions,\n            @NonNull AndroidBuilder androidBuilder,\n            @NonNull AndroidConfig extension,\n            @NonNull VariantFactory variantFactory,\n            @NonNull TaskManager taskManager,\n            @NonNull Recorder recorder) {\n        ...\n\n        DefaultAndroidSourceSet mainSourceSet =\n                (DefaultAndroidSourceSet) extension.getSourceSets().getByName(extension.getDefaultConfig().getName());\n\n        DefaultAndroidSourceSet androidTestSourceSet = null;\n        DefaultAndroidSourceSet unitTestSourceSet = null;\n        if (variantFactory.hasTestScope()) {\n            androidTestSourceSet =\n                    (DefaultAndroidSourceSet) extension.getSourceSets()\n                            .getByName(ANDROID_TEST.getPrefix());\n            unitTestSourceSet =\n                    (DefaultAndroidSourceSet) extension.getSourceSets()\n                            .getByName(UNIT_TEST.getPrefix());\n        }\n\n        // 使用 DebugConfig 对象，'main'、'androidTest'、'test' 3个 SourceSet，\n        // 创建了 defaultConfigData 对象。\n        // 'main'、'androidTest'、'test' 3个 SourceSet 都是在 extension 中直接创建的，而不是由 BuildType 或 ProductFlavor 触发生成的。\n        // 正如 DebugConfig 对象是一个特殊的 ProductFlavor，defaultConfigData 引用也持有了一个特殊的 ProductFlavorData。\n\n        this.defaultConfigData =\n                new ProductFlavorData<>(\n                        extension.getDefaultConfig(),\n                        mainSourceSet,\n                        androidTestSourceSet,\n                        unitTestSourceSet,\n                        project);\n    }\n\n    ...\n}\n\n```\n\n### BasePlugin::apply() > createTasks()\n\n运行到这里时，创建管理类、监听链建立、设置默认配置布局这些工作都完成了，终于要创建 gradle task 了。\n\n```\nprivate void createTasks() {\n    taskManager.createTasksBeforeEvaluate(\n        new TaskContainerAdaptor(project.getTasks())));\n\n    project.afterEvaluate(\n        project ->\n            () -> createAndroidTasks(false);\n```\n\n`createTasks()` 将创建 gradle task 的工作分为两部分，一部分在 evaluate 开始之前，用于创建不构建脚本配置影响的任务；另一部分在 evaluate 结束之后，这部分创建那些的任务取决于构建脚本配置。\n\n#### `TaskManager::createTasksBeforeEvaluate()`\n\nTaskManager 的绝大部分实没有扩展 `createTasksBeforeEvaluate()` (只有 InstantAppTaskManager 创建了多创建了一个 gradle task)，所以对于各类 android plugin 在这里创建的任务都是相同的。\n\n在这个方法中创建了一些 Anchor 任务（没有实际内容，仅作为上游节点使用），和一些独立任务例如和 Lint 和 单元测试相关的任务。\n\n*下面代码使用伪代码展现*\n\n```\npublic abstract class TaskManager {\n    public void createTasksBeforeEvaluate(@NonNull TaskFactory tasks) {\n\n        create \"uninstallAll\" task as anchor task. \n            it \"Uninstall all applications.\"\n\n        create \"deviceCheck\" task as anchor task.\n            it \"Runs all device checks using Device Providers and Test Servers.\"\n\n        create \"connectedCheck\" task as anchor task.\n            it \"Runs all device checks on currently connected devices.\"\n\n        create \"preBuild\" task as anchor task.\n            it \"Lead all build tasks.\"\n\n        create \"extractProguardFiles\" task as ExtractProguardFiles.class type.\n            let \"extractProguardFiles\" dependsOn \"preBuild\"\n\n        create \"sourceSets\" task as SourceSetsTask.class type.\n            it \"Prints out all the source sets defined in this project.\"\n\n        create \"assembleAndroidTest\" task as anchor task.\n            it \"Assembles all the Test applications.\"\n\n        create \"compileLint\" task as LintCompile.class type.\n\n        create \"lint\" task as LintGlobalTask.class type.\n            it \"Runs lint on all variants.\"\n            let \"check\" task (which from java plugin) dependsOn \"lint\" task.\n\n        create \"lintChecks\" configuration.\n            it \"Configuration to apply external lint check jar\"\n            GlobalScope will hold \"lintChecks\" configuration\n\n        if ({@Field buildCache} is not null) {\n            create \"cleanBuildCache\" task as CleanBuildCache.class type.\n                it \"Deletes the build cache directory.\"\n        }\n\n        create \"resolveConfigAttr\" task as ConfigAttrTask.class type.\n            set resolveConfigAttr.resolvable = true\n\n        create \"consumeConfigAttr\" task as ConfigAttrTask.class type.\n            set consumeConfigAttr.consumable true.\n    }\n}\n```\n\n#### `BasePlugin::createAndroidTasks()`\n\n`BasePlugin::createAndroidTasks()` 是创建 BuildVariant 和 Android 编译 task 的主流程，其中包含了一些检查和准备工作，创建 task 的代码主要包含在 `VariantManager::createAndroidTasks` 中。\n\n在这里主要做完成完成了：\n* 加载 Android Sdk 信息和添加 Android Sdk 提供的 Maven Repo\n* 创建 lint 相关的全局 task\n* 基于编译脚本输入创建 VariantData 对象\n* 基于 VariantData 信息创建编译 task\n* 完成 Variant 对象的创建。\n\n```\nfinal void createAndroidTasks(boolean force) {\n\n    // @Simplify\n    // 确保 buildToolsVersion 和 compileSdkVersion 被设置了。\n    // 确保 JavaPlugin.class 没有被 apply 过。\n    [+]{...}\n\n    // 初始化 Android SDK Target 信息。 \n    ensureTargetSetup();\n\n    if (hasCreatedTasks) {\n        return;\n    }\n    hasCreatedTasks = true;\n    // 禁止再修改 Extension 对象，编译脚本配置到此截止。\n    extension.disableWrite();\n\n    // 创建 PrepareLintJar.class 类型的 \"prepareLintJar\" 任务。\n    taskManager.configureCustomLintChecks(new TaskContainerAdaptor(project.getTasks()));\n\n    // 将 Android SDK 包含的 Repositories 加入的 Maven Repo 中，并将这些 Repositories 调整到 Maven Repo 列表的最前面。\n    sdkHandler.addLocalRepositories(project);\n\n    // @DataBinding，如果使用了 DataBinding，则向已有 configuration 添加一些依赖。\n    [+]{...}\n\n    // 创建 VariantData 对象和编译 Task。\n    variantManager.createAndroidTasks();\n\n    // 依照 VariantData 对象，创建 Variant 对象。\n    ApiObjectFactory apiObjectFactory =\n            new ApiObjectFactory(\n                    androidBuilder,\n                    extension,\n                    variantFactory,\n                    instantiator,\n                    project.getObjects());\n    for (VariantScope variantScope : variantManager.getVariantScopes()) {\n        BaseVariantData variantData = variantScope.getVariantData();\n        apiObjectFactory.create(variantData);\n    }\n\n    // 在 Variant 对象创建完成之后，创建全局 \"lint\" Task。\n    taskManager.configureGlobalLintTask(variantManager.getVariantScopes());\n\n    // @IDE\n    [+]{...}\n}\n\n...\n\nprivate void ensureTargetSetup() {    \n    TargetInfo targetInfo = androidBuilder.getTargetInfo();\n    if (targetInfo == null) {\n        if (extension.getCompileOptions() == null) {\n            throw new GradleException(\"Calling getBootClasspath before compileSdkVersion\");\n        }\n\n        // 获取 Android SDK Target 信息，并将其设置到 androidBuiler 中。\n        sdkHandler.initTarget(\n                extension.getCompileSdkVersion(),\n                extension.getBuildToolsRevision(),\n                extension.getLibraryRequests(),\n                androidBuilder,\n                SdkHandler.useCachedSdk(projectOptions));\n        // 确保 Android SDK 中没有安装了 platform tools，如果没有就下载它。\n        sdkHandler.ensurePlatformToolsIsInstalled(extraModelInfo);\n    }\n}\n```\n\n`SdkHandler::initTarget()` 中通过 SdkLoader 对象加载 Android Sdk 中的各种工具路径。\nSdkLoader 的不同实现对应不同的 Android Sdk 文件布局，通常使用 `DefaultSdkLoader` 。\n\n```\nclass SdkHandler {\n    ...\n\n     public void initTarget(\n                @NonNull String targetHash,\n                @NonNull Revision buildToolRevision,\n                @NonNull Collection<LibraryRequest> usedLibraries,\n                @NonNull AndroidBuilder androidBuilder,\n                boolean useCachedVersion) {\n            //检查targetHash和buildToolRevision不为空，否则抛异常。\n            ...\n\n            // 通过getSdkLoader()创建SdkLoader对象\n            // 如果useCachedVersion && sSdkLoader，那么重用旧的SdkLoader。\n            synchronized (LOCK_FOR_SDK_HANDLER) {\n                if (useCachedVersion && sSdkLoader == null) {\n                } else {\n                    sSdkLoader = getSdkLoader();\n                }\n                sdkLoader = sSdkLoader;\n            }\n\n            // 通过SdkLoader -> AndroidSdkHandler获得SdkInfo.\n            // SdkInfo包含annotations.jar和adb执行文件的位置。\n            // annotations.jar位置：${sdkLocation}/tools/support/annotations.jar\n            // adb文件位置：${sdkLocation}/platform-tools/adb\n            SdkInfo sdkInfo = sdkLoader.getSdkInfo(logger);\n\n            // 通过SdkLoader -> AndroidSdkHandler获得TargetInfo\n            // TargetInfo包括IAndroidTarget(包装target信息),BuildToolInfo(包装build-tools信息)。\n            TargetInfo targetInfo = sdkLoader.getTargetInfo(\n                    targetHash,\n                    buildToolRevision,\n                    logger,\n                    sdkLibData);\n\n            androidBuilder.setSdkInfo(sdkInfo);\n            androidBuilder.setTargetInfo(targetInfo);\n            androidBuilder.setLibraryRequests(usedLibraries);\n\n            // Check if platform-tools are installed. We check here because realistically, all projects\n            // should have platform-tools in order to build.\n            ProgressIndicator progress = new ConsoleProgressIndicator();\n            AndroidSdkHandler sdk = AndroidSdkHandler.getInstance(getSdkFolder());\n            LocalPackage platformToolsPackage =\n                    sdk.getLatestLocalPackageForPrefix(SdkConstants.FD_PLATFORM_TOOLS, true, progress);\n            if (platformToolsPackage == null) {\n                //如果sdkLibData.useSdkDownload()就尝试下载；否则什么都不做。\n                sdkLoader.installSdkTool(sdkLibData, SdkConstants.FD_PLATFORM_TOOLS);\n            }\n        }\n\n    ...\n}\n```\n\n// `configureCustomLintChecks` 和 `configureGlobalLintTask` 这两个方法都跟 Lint 任务创建相关，一个在创建 Variant 对象之前调用，一个在其后调用。\n\n```\nclass TaskMananger {\n    ...\n\n    // \"prepareLintJar\" 任务，这个任务会将 {@File lint.jar} 拷贝到 {@File build/intermediates/lint/lint.jar}。\n    public void configureCustomLintChecks(@NonNull TaskFactory tasks) {\n        File lintJar = FileUtils.join(globalScope.getIntermediatesDir(), \"lint\", FN_LINT_JAR);\n\n        AndroidTask<PrepareLintJar> copyLintTask =\n        getAndroidTasks()\n                .create(tasks, new PrepareLintJar.ConfigAction(globalScope, lintJar));\n        globalScope.addTaskOutput(LINT_JAR, lintJar, copyLintTask.getName());\n    }\n\n    ...\n\n    public void configureGlobalLintTask(@NonNull final Collection<VariantScope> variants) {\n\n        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());\n\n        // 筛选 'non testing' && 'non feature' 的 BuildVariant。\n        List<VariantScope> filteredVariants =\n                variants.stream().filter(TaskManager::isLintVariant).collect(Collectors.toList());\n        if (filteredVariants.isEmpty()) {\n            return;\n        }\n\n        // 创建全局的 'lint' 任务。\n        androidTasks.configure(\n                tasks, new LintGlobalTask.GlobalConfigAction(globalScope, filteredVariants));\n\n        // 将 'lint.jar' 文件加入每个 BuildVariant 的输出文件集中。\n        FileCollection lintJarCollection = globalScope.getOutput(LINT_JAR);\n        File lintJar = lintJarCollection.getSingleFile();\n        for (VariantScope scope : variants) {\n            scope.addTaskOutput(LINT_JAR, lintJar, PrepareLintJar.NAME);\n        }\n    }\n\n    ...\n}\n```\n\n在 `VariantManager::createAndroidTasks()` 中：\n* `populateVariantDataList()` 创建 VariantData 对象。\n* `TaskManager::createTopLevelTestTasks` 创建一些和单元测试有关的顶层 task。\n* `createTasksForVariantData()` 创建编译相关的所有 task。\n* `TaskManager::createReportTasks` 创建输出信息的工具 task。\n\n```\nclass VariantManager {\n    ...\n\n    public void createAndroidTasks() {\n        // 这是一个抽象方法，只有在 LibraryVariantFactory 中有实现。\n        // LibraryVariantFactory 的实现中，确保 BuildType 和 ProductFlavor 没有配置\n        // applicationId 或 applicationIdSuffix。\n        variantFactory.validateModel(this);\n\n        // 这又是一个抽象方法，在 BaseVariantFactory 的实现中检查，\n        // 如果使用了 'android-apt' 插件，则提示开发者使用更新的 'annotationProcessor' 配置。\n        variantFactory.preVariantWork(project);\n\n        // 创建 VariantData 对象。\n        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());\n        if (variantScopes.isEmpty()) {\n            populateVariantDataList();\n        }\n\n        //@Test, 创建一些和单元测试有关的顶层 task。\n        taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty());\n\n        // 创建基于 BuildVariant 的编译 task。\n        for (final VariantScope variantScope : variantScopes) {\n            createTasksForVariantData(tasks, variantScope)\n        }\n\n        // 创建一些输出信息的 task。\n        taskManager.createReportTasks(tasks, variantScopes);\n    }\n\n    ...\n\n    public void createReportTasks(TaskFactory tasks, final List<VariantScope> variantScopes) {\n    \n        create \"androidDependencies\" as DependencyReportTask type.\n\n        create \"signingReport\" as SigningReportTask type.\n    }\n\n    ...\n}\n```\n\n#### 创建 VariantData 对象\n\n`VariantManager::populateVariantDataList()` 依赖开发者编译脚本的配置，生成全部 VariantData 对象，进一步完成 project 模型的搭建。\n\n```\nclass VariantManager {\n    ...\n\n    public void populateVariantDataList() {\n        List<String> flavorDimensionList = extension.getFlavorDimensionList();\n\n        if (productFlavors.isEmpty()) {\n            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。\n            configureDependencies();\n            // 如果没有配置任何 ProductFlavor，使用空参数直接构造 VariantData 对象。\n            createVariantDataForProductFlavors(Collections.emptyList());\n        } else {\n            // 如果配置了 ProductFlavor，检查配置合法性，并根据配置构造 VariantData 对象。\n            // 确保每个 ProductFlavor 都有 Dimension\n            if (flavorDimensionList == null || flavorDimensionList.isEmpty()) {\n                // @Simplify 从 Android Gradle 3.0 之后，所有的 ProductFlavor 都需要有 Dimension\n                // 参见：https://d.android.com/r/tools/flavorDimensions-missing-error-message.html\n                [+]{...}\n            } else if (flavorDimensionList.size() == 1) {\n                // @Simplify 如果仅有一个 Dimension，将每个没有配置 Dimension 的 ProductFlavor 设为这个唯一的 Dimension。\n                [+]{...}\n            }\n\n            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。\n            configureDependencies();\n\n            // 下面这两个调用生成了 flavorComboList，\n            // 这个列表中的每个元素代表了一种 ProductFlavor 的组合方式\n            // (按照 Dimension 从高到低的方式)\n            Iterable<CoreProductFlavor> flavorDsl =\n                    Iterables.transform(\n                            productFlavors.values(),\n                            ProductFlavorData::getProductFlavor);\n            List<ProductFlavorCombo<CoreProductFlavor>> flavorComboList =\n                    ProductFlavorCombo.createCombinations(\n                            flavorDimensionList,\n                            flavorDsl);\n            // 以每一种 ProductFlavor 组合为输入，构造 VariantData 对象。\n            for (ProductFlavorCombo<CoreProductFlavor>  flavorCombo : flavorComboList) {\n                createVariantDataForProductFlavors(\n                        (List<ProductFlavor>) (List) flavorCombo.getFlavorList());\n            }\n        }\n    }\n\n    ...\n\n    private void createVariantDataForProductFlavors(\n            @NonNull List<ProductFlavor> productFlavorList) {\n\n        // getVariantConfigurationTypes() 是一个抽象方法，通常情况下只会返回长度为1的列表。\n        // 例如 ApplicationVariantFactory 会返回 VariantType.DEFAULT;\n        // LibraryVariantFactory 会返回 VariantType.LIBRARY;\n        // 这里实际上就是将 VariantType 加入构造 VariantData 的参数。\n        for (VariantType variantType : variantFactory.getVariantConfigurationTypes()) {\n            createVariantDataForProductFlavorsAndVariantType(productFlavorList, variantType);\n        }\n    }\n\n    private void createVariantDataForProductFlavorsAndVariantType(\n            @NonNull List<ProductFlavor> productFlavorList, @NonNull VariantType variantType) {\n\n        // @Test, 在工程支持单元测试的情况下，获取单元测试的目标 BuildTypeData\n        // 默认情况下单元测试的目标 BuildType 是 'debug'\n        BuildTypeData testBuildTypeData = null;\n        [+]{...}\n\n        BaseVariantData variantForAndroidTest = null;\n\n        CoreProductFlavor defaultConfig = defaultConfigData.getProductFlavor();\n\n        Action<com.android.build.api.variant.VariantFilter> variantFilterAction =\n                extension.getVariantFilter();\n\n        // @IDE\n        [+]{...}\n\n        for (BuildTypeData buildTypeData : buildTypes.values()) {\n            boolean ignore = false;\n\n            // 检查编译脚本中的 VariantFilter 配置，\n            // 以确认当前的 BuildType & ProductFlavor 组合是否要被忽略。\n            if (variantFilterAction != null) {\n                variantFilter.reset(\n                        defaultConfig,\n                        buildTypeData.getBuildType(),\n                        variantType,\n                        productFlavorList);\n\n                variantFilterAction.execute(variantFilter);\n                ignore = variantFilter.isIgnore();\n            }\n\n            if (!ignore) {\n                // 通过 BuildType & ProductFlavor 组合 创建 VariantData 对象。 \n                BaseVariantData variantData =\n                        createVariantDataForVariantType(\n                                buildTypeData.getBuildType(),\n                                productFlavorList,\n                                variantType,\n                                false);\n                // 将 VariantScope 对象保存在 variantScopes 中。\n                // VariantScope 对象和 VariantData 对象是一一对应、相互持有的关系。\n                addVariant(variantData);\n\n                // @Simplify\n                [+]{...}\n                \n                if (variantFactory.hasTestScope()) {\n                    if (buildTypeData == testBuildTypeData) {\n                        variantForAndroidTest = variantData;\n                    }\n\n                    // @Test, 创建单元测试的 VariantData 对象。\n                    [+]{...}\n                }\n            }\n        }\n\n        if (variantForAndroidTest != null) {\n            //@Test, 创建单 AndroidTest 的 VariantData 对象。\n            [+]{...}\n        }\n    }\n\n    ...\n\n    // 通过 BuildType & ProductFlavor 组合 创建 VariantData 对象。 \n    private BaseVariantData createVariantDataForVariantType(\n            @NonNull com.android.builder.model.BuildType buildType,\n            @NonNull List<? extends ProductFlavor> productFlavorList,\n            @NonNull VariantType variantType,\n            boolean componentPluginUsed) {\n        BuildTypeData buildTypeData = buildTypes.get(buildType.getName());\n        final DefaultAndroidSourceSet sourceSet = defaultConfigData.getSourceSet();\n\n        // 以 DefaultConfig 和 buildType 为基础创建 VariantConfiguration 对象，\n        // 这个对象代表了 BuildType & ProductFlavor 组合的配置，并且会将脚本中的的配置进行合并，确定最终的配置。\n        GradleVariantConfiguration variantConfig =\n            GradleVariantConfiguration.getBuilderForExtension(extension)\n                .create(\n                    globalScope.getProjectOptions(),\n                    defaultConfigData.getProductFlavor(),\n                    sourceSet,\n                    getParser(sourceSet.getManifestFile()),\n                    buildTypeData.getBuildType(),\n                    buildTypeData.getSourceSet(),\n                    variantType,\n                    signingOverride);\n\n        // @Simplify\n        [+]{...}\n\n        // 依次将 ProductFlavor 对象加入 VariantConfiguration 对象，每次加入操作都会进行配置合并，保存在 'mergedFlavor' 中。\n        // 合并时大部分属性会进行覆盖，高维 ProductFlavor > 低维 ProductFlavor > DefaultConfig。\n        // 但是 applicationIdSuffix 和 versionNameSuffix 两个配置会将各个维度与 DefaultConfig 拼接到一起。\n        // 此外 JavaCompileOptions、NdkOptions 等 Options 会进行覆盖合并，BuildType > 高维 ProductFlavor > 低维 ProductFlavor > DefaultConfig。\n        for (ProductFlavor productFlavor : productFlavorList) {\n            ProductFlavorData<CoreProductFlavor> data = productFlavors.get(\n                    productFlavor.getName());\n\n            String dimensionName = productFlavor.getDimension();\n            if (dimensionName == null) {\n                dimensionName = \"\";\n            }\n\n            variantConfig.addProductFlavor(\n                    data.getProductFlavor(),\n                    data.getSourceSet(),\n                    dimensionName);\n        }\n\n        // 创建 BuildType & ProductFlavor 拼接而成的 SourceSet。\n        // 名字分别为 '{BuildVaraintName}{ProductFlavorList}' 和 '{ProductFlavorList}'。\n        NamedDomainObjectContainer<AndroidSourceSet> sourceSetsContainer = extension.getSourceSets();\n        createCompoundSourceSets(productFlavorList, variantConfig, sourceSetsContainer, null);\n\n        // 下面的5个 step 收集了 Variant 的所有相关的 SourceSet，分别是：\n        // variant-specific, build type, multi-flavor, flavor1, flavor2, ..., defaultConfig.\n        // 后面会使用这些 SourceSets 创建 VariantDependencies 对象。\n        final List<DefaultAndroidSourceSet> variantSourceSets =\n                Lists.newArrayListWithExpectedSize(productFlavorList.size() + 4);\n\n        // 1. add the variant-specific if applicable.\n        if (!productFlavorList.isEmpty()) {\n            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getVariantSourceProvider());\n        }\n\n        // 2. the build type.\n        variantSourceSets.add(buildTypeData.getSourceSet());\n\n        // 3. the multi-flavor combination\n        if (productFlavorList.size() > 1) {\n            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getMultiFlavorSourceProvider());\n        }\n\n        // 4. the flavors.\n        for (ProductFlavor productFlavor : productFlavorList) {\n            variantSourceSets.add(productFlavors.get(productFlavor.getName()).getSourceSet());\n        }\n\n        // 5. The defaultConfig\n        variantSourceSets.add(defaultConfigData.getSourceSet());\n\n        // 创建 BaseVariantData 对象。\n        BaseVariantData variantData =\n                variantFactory.createVariantData(variantConfig, taskManager, recorder);\n\n        // 创建 VariantDependencies 对象并由 BaseVariantData 对象持有。\n        // 构造 VariantDependencies 对象的过程中，创建了几个新的 Configuration：\n        // '{VariantName}CompileClasspath'，'{VariantName}RuntimeClasspath' 等。\n        // 由于每个 SourceSet 都会对应一个 Configuration，\n        // 所以以通过 variantSourceSets 参数可以获取所有与 Variant 的所有相关的 Configuration。\n        // 这里新创建的 Configuration 会视情况依赖 与 Variant 的所有相关的 Configuration。\n        VariantDependencies.Builder builder =\n            VariantDependencies.builder(\n                        project, androidBuilder.getErrorReporter(), variantConfig)\n                .setConsumeType(\n                        getConsumeType(variantData.getVariantConfiguration().getType()))\n                .setPublishType(\n                        getPublishingType(variantData.getVariantConfiguration().getType()))\n                .setFlavorSelection(getFlavorSelection(variantConfig))\n                .addSourceSets(variantSourceSets)\n                .setBaseSplit(\n                        variantType == VariantType.FEATURE && extension.getBaseFeature());\n        final VariantDependencies variantDep = builder.build();\n        variantData.setVariantDependency(variantDep);\n\n        // 如果需要兼容 4.x 的 MultiDex，\n        // 那么添加依赖 'com.android.support:multidex:1.0.2'。\n        if (variantConfig.isLegacyMultiDexMode()) {\n            project.getDependencies().add(\n                    variantDep.getCompileClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);\n            project.getDependencies().add(\n                    variantDep.getRuntimeClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);\n        }\n\n        // @RenderScript\n        [+]{...}\n\n        return variantData;\n    }\n\n    ...\n\n    private void createCompoundSourceSets(\n            @NonNull List<? extends ProductFlavor> productFlavorList,\n            @NonNull GradleVariantConfiguration variantConfig,\n            @NonNull NamedDomainObjectContainer<AndroidSourceSet> sourceSetsContainer,\n            @Nullable BaseVariantData testedVariantData) {\n        if (!productFlavorList.isEmpty()) {\n            // 创建名为 '{BuildVaraintName}{ProductFlavorList}' 的 SourceSet。\n            DefaultAndroidSourceSet variantSourceSet =\n                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(\n                            computeSourceSetName(\n                                    variantConfig.getFullName(),\n                                    variantConfig.getType()));\n            variantConfig.setVariantSourceProvider(variantSourceSet);\n\n            if (testedVariantData != null) {\n                // @Test,配置 Configuration 的依赖关系。\n                [+]{...}\n            }\n        }\n\n        if (productFlavorList.size() > 1) {\n            // 创建名为 '{ProductFlavorList}' 的 SourceSet。\n            DefaultAndroidSourceSet multiFlavorSourceSet =\n                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(\n                            computeSourceSetName(\n                                    variantConfig.getFlavorName(),\n                                    variantConfig.getType()));\n            variantConfig.setMultiFlavorSourceProvider(multiFlavorSourceSet);\n\n            if (testedVariantData != null) {\n                // @Test,配置 Configuration 的依赖关系。\n                [+]{...}\n            }\n        }\n    }\n\n    ...\n}\n\n```\n\n#### `VariantMananger::configureDependencies()`\n\n在这个方法，通过注册 Gradle Transform 接口，解压缩并转移了所依赖 AAR 中的文件，使这些文件能够参与后续的编译过程。\n\n```\nclass VariantMananger {\n    ...\n\n    public void configureDependencies() {\n        final DependencyHandler dependencies = project.getDependencies();\n\n        // register transforms.\n        final String explodedAarType = ArtifactType.EXPLODED_AAR.getType();\n        dependencies.registerTransform(\n                reg -> {\n                    reg.getFrom().attribute(ARTIFACT_FORMAT, AndroidArtifacts.TYPE_AAR);\n                    reg.getTo().attribute(ARTIFACT_FORMAT, explodedAarType);\n                    reg.artifactTransform(ExtractAarTransform.class);\n                });\n\n        for (ArtifactType transformTarget : AarTransform.getTransformTargets()) {\n            dependencies.registerTransform(\n                    reg -> {\n                        reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);\n                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget.getType());\n                        reg.artifactTransform(\n                                AarTransform.class, config -> config.params(transformTarget));\n                    });\n        }\n\n        dependencies.registerTransform(\n                reg -> {\n                    reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);\n                    reg.getTo()\n                            .attribute(\n                                    ARTIFACT_FORMAT,\n                                    ArtifactType.SYMBOL_LIST_WITH_PACKAGE_NAME.getType());\n                    reg.artifactTransform(LibrarySymbolTableTransform.class);\n                });\n\n        for (String transformTarget : JarTransform.getTransformTargets()) {\n            dependencies.registerTransform(\n                    reg -> {\n                        reg.getFrom().attribute(ARTIFACT_FORMAT, \"jar\");\n                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget);\n                        reg.artifactTransform(JarTransform.class);\n                    });\n        }\n\n        AttributesSchema schema = dependencies.getAttributesSchema();\n\n        // custom strategy for AndroidTypeAttr\n        AttributeMatchingStrategy<AndroidTypeAttr> androidTypeAttrStrategy =\n                schema.attribute(AndroidTypeAttr.ATTRIBUTE);\n        androidTypeAttrStrategy.getCompatibilityRules().add(AndroidTypeAttrCompatRule.class);\n        androidTypeAttrStrategy.getDisambiguationRules().add(AndroidTypeAttrDisambRule.class);\n\n        // custom strategy for build-type and product-flavor.\n        setBuildTypeStrategy(schema);\n\n        setupFlavorStrategy(schema);\n    }\n\n    ...\n}\n```\n\n#### `VariantMananger::createTasksForVariantData()`\n\n*下面代码使用伪代码展现*\n\n```\nclass VariantMananger {\n    ...\n\n    public void createTasksForVariantData(\n            final TaskFactory tasks, final VariantScope variantScope) {\n        \n        create \"assemble{BuildTypeName}\" task as anchor task. \n            it \"Assembles all assemble{BuildTypeName} builds.\"\n            let \"assemble\" dependsOn \"assemble{BuildTypeName}\".\n\n        // 创建更多基于 Variant 的 assemble task. \n        createAssembleTaskForVariantData(tasks, variantData);\n\n        if (variantType.isForTesting()) {\n            // @Test，创建基于 Variant 的单元测试 task.\n            [+]{...}\n        } else {\n            // 创建基于 Variant 的编译 task.\n            taskManager.createTasksForVariantScope(tasks, variantScope);\n        }\n    }\n\n    ...\n\n    // 创建基于 Variant 的 assemble task. \n    private void createAssembleTaskForVariantData(\n            TaskFactory tasks, final BaseVariantData variantData) {\n        final VariantScope variantScope = variantData.getScope();\n        if (variantData.getType().isForTesting()) {\n\n            create \"assemble{VariantName}\" task as anchor task. \n                set variantScope assemble task with it.\n\n        } else {\n            if (productFlavors.isEmpty()) {\n                set variantScope assemble task with \"assemble{BuildTypeName}\".\n            } else {\n                \n                create \"assemble{VariantName}\" task as anchor task. \n                    set variantScope assemble task with it.\n                    let \"assemble{BuildTypeName}\" dependsOn \"assemble{VariantName}\".\n\n                for each flavor\n                    create \"assemble{ProductFlavor}\" as anchor task.\n                        set ProductFlavorData assemble task with it.\n                        let  \"assemble{ProductFlavor}\" dependsOn \"assemble{VariantName}\".\n\n                if (variantConfig.getProductFlavors().size() > 1) {\n\n                    create \"assmble{ProductFlavorList}\" as anchor task.\n                        it \"Assembles all builds for flavor combination: {ProductFlavorList}\".\n                        let \"assmble{ProductFlavorList}\" dependsOn \"assemble{VariantName}\".\n                    \n                    let \"assemble\" dependsOn \"assmble{ProductFlavorList}\".\n                }\n            }\n        }\n    }\n\n    ...\n}\n```\n\n#### `TaskMananger::createTasksForVariantScope()`\n\n`TaskMananger::createTasksForVariantScope()` 是一个抽象方法，创建基于 Variant 的编译 task，这些编译 task 就是 android 编译 toolchain 的调用者。\n这个方法在各个 TaskMananger 子类中实现不同，这里就选 ApplicationTaskManager 的实现来看。\n\n*下面代码使用伪代码展现*\n\n```\nclass ApplicationTaskManager extends TaskManager {\n    ...\n\n    public void createTasksForVariantScope(\n            @NonNull final TaskFactory tasks, @NonNull final VariantScope variantScope) {\n        BaseVariantData variantData = variantScope.getVariantData();\n        assert variantData instanceof ApplicationVariantData;\n\n        // in createAnchorTasks()\n        create \"pre{VariantName}Build\" task as AppPreBuildTask task. \n            set VariantScope prebuild task with it.\n            let \"pre{VariantName}Build\" dependsOn \"preBuild\".\n        if enable code skrink\n            let \"pre{VariantName}Build\" dependsOn \"extractProguardFiles\".\n\n        create \"generate{VariantName}Sources\" as anchor task. \n            let \"generate{VariantName}Sources\" dependsOn \"prepareLintJar\"\n\n        create \"generate{VariantName}Resources\" as anchor task. \n\n        create \"generate{VariantName}Assets\" as anchor task. \n\n        // @Test，创建单元测试覆盖率报告 task。\n        [+]{...}\n\n        create \"compile{VariantName}Sources\" as anchor task. \n            let \"assemble{VariantName}\" dependsOn \"compile{VariantName}Sources\".\n\n        // in createCheckManifestTask()\n        create \"check{VariantName}Manifest\" as CheckManifest type task. \n            let \"check{VariantName}Manifest\" dependsOn \"pre{VariantName}Build\".\n\n        // @Wear\n        handleMicroApp(tasks, variantScope);\n\n        // 创建基于依赖的 transform stream\n        createDependencyStreams(tasks, variantScope);\n\n        // in createApplicationIdWriterTask()\n        create \"write{VariantName}ApplicationId\" as ApplicationIdWriterTask type task. \n            add \"build/intermediates/applicationId/{ProductFlavorName}/{BuildTypeName}\" to VariantScope outputs.\n\n        // in createMergeApkManifestsTask()\n        create \"create{VariantName}CompatibleScreenManifests\" as CompatibleScreensManifest type task.\n\n        create \"process{VariantName}Manifest\" as MergeManifests type task.\n            let \"process{VariantName}Manifest\" dependsOn \"check{VariantName}Manifest\".\n\n        // in createGenerateResValuesTask()\n        create \"generate{VariantName}ResValues\" as GenerateResValues type task.\n            let \"generate{VariantName}Resources\" dependsOn \"generate{VariantName}ResValues\".\n\n        // in createRenderscriptTask()\n        create \"compile{VariantName}Renderscript\" as RenderscriptCompile type task.\n        if is testing\n            let \"compile{VariantName}Renderscript\" dependsOn \"process{VariantName}Manifest\".\n        else\n            let \"compile{VariantName}Renderscript\" dependsOn \"pre{VariantName}Build\".\n\n        let \"generate{VariantName}Resources\" dependsOn \"compile{VariantName}Renderscript\".\n\n        if not RenderscriptNdkModeEnabled\n            let \"generate{VariantName}Sources\" dependsOn \"compile{VariantName}Renderscript\".\n\n        // in createMergeResourcesTask()\n        create \"merge{VariantName}Resources\" as MergeResources type task.\n            let \"merge{VariantName}Resources\" dependsOn \"generate{VariantName}Resources\".\n\n        // in createMergeAssetsTask()\n        create \"merge{VariantName}Assets\" as MergeSourceSetFolders type task.\n            let \"merge{VariantName}Assets\" dependsOn \"generate{VariantName}Assets\".\n\n        // in createBuildConfigTask()\n        create \"generate{VariantName}BuildConfig\" as GenerateBuildConfig type task.\n            let \"generate{VariantName}Sources\" dependsOn \"generate{VariantName}BuildConfig\".\n            if is testing\n                let \"generate{VariantName}BuildConfig\" dependsOn \"process{VariantName}Manifest\".\n            else \n                let \"generate{VariantName}BuildConfig\" dependsOn \"check{VariantName}Manifest\".\n\n        // in createApkProcessResTask()\n        create \"process{VariantName}Resources\" as ProcessAndroidResources type task.\n            let \"generate{VariantName}Sources\" dependsOn \"process{VariantName}Resources\".\n\n        create \"process{VariantName}JavaRes\" as Sync type task.\n            let \"process{VariantName}JavaRes\" dependsOn \"pre{VariantName}Build\".\n\n        // in createAidlTask()\n        create \"compile{VariantName}Aidl\" as AidlCompile type task.\n            let \"generate{VariantName}Sources\" dependsOn \"compile{VariantName}Aidl\".\n            let \"compile{VariantName}Aidl\" dependsOn \"pre{VariantName}Build\".\n\n        // in createShaderTask()\n        create \"merge{VariantName}Shaders\" as MergeSourceSetFolders type task.\n        create \"compile{VariantName}Shaders\" as ShaderCompile type task.\n            let \"compile{VariantName}Shaders\" dependsOn \"merge{VariantName}Shaders\".\n            let \"generate{VariantName}Assets\" dependsOn \"compile{VariantName}Shaders\".\n\n        // @NDK, ndk 编译任务\n        [+]{...}\n\n        // in createMergeJniLibFoldersTasks()\n        create \"merge{VariantName}JniLibFolders\" as MergeSourceSetFolders type task.\n            let \"merge{VariantName}JniLibFolders\" dependsOn \"generate{VariantName}Assets\".\n\n        create \"mergedJniFolder\" stream\n            type ExtendedContentType.NATIVE_LIBS\n            scope Scope.PROJECT\n            from {@File 'intermediates/jniLibs/{VariantConfigurationDir}'}\n            let stream depend on \"merge{VariantName}JniLibFolders\" task\n\n        // @NDK, 创建当前工程 ndk 编译产出的 so 文件以及 obj 文件 的 stream\n        [+]{...}\n\n        // @RenderScript, 创建当前工程 rs 编译产物的 stream\n        [+]{...}\n\n        create \"transformNativeLibsWithMergeJniLibsFor{VariantName}\" task\n            with \"mergeJniLibs\" transform as MergeJavaResourcesTransform type.\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES. \n\n\n        // @DataBinding\n        createDataBindingTasksIfNecessary(tasks, variantScope);\n\n        // 创建 java 编译 task。\n        addCompileTask();\n\n        // @Ndk\n        createStripNativeLibraryTask(tasks, variantScope);\n\n        // @Multi\n        createSplitTasks(tasks, variantScope);\n\n        // @InstantRun\n        [+]{...}\n\n        // 创建打包 task。\n        createPackagingTask(tasks, variantScope, buildInfoWriterTask);\n\n        // in createLintTasks()\n        create \"lint{VariantName}\" as LintPerVariantTask type.\n    }\n\n    ...\n}\n```\n\n`TaskMananger::createDependencyStreams` 为 external 依赖（maven 或者 local jar 文件）和工程依赖创建 Android Transform stream 对象，使来自依赖的文件（主要是 class 文件）参与到 Android Transform 过程中。\n\n```\nclass TaskMananger {\n    ...\n\n    protected void createDependencyStreams(\n            @NonNull TaskFactory tasks,\n            @NonNull final VariantScope variantScope) {\n        \n        // @Test, 基于测试覆盖率需求，修改 Configuration\n        handleJacocoDependencies(variantScope);\n\n        TransformManager transformManager = variantScope.getTransformManager();\n\n        create \"ext-libs-classes\" stream\n            type DefaultContentType.CLASSES\n            scope Scope.EXTERNAL_LIBRARIES\n            from ArtifactType.CLASSES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  \n\n        create \"ext-libs-res-plus-native\" stream\n            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS\n            scope Scope.EXTERNAL_LIBRARIES\n            from ArtifactType.JAVA_RES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  \n\n        // and the android AAR also have a specific jni folder\n        create \"ext-libs-native\" stream\n            type ExtendedContentType.NATIVE_LIBS\n            scope Scope.EXTERNAL_LIBRARIES\n            from ArtifactType.JNI files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH\n\n        // data binding related artifacts for external libs\n        // @DataBinding, 创建 dataBinding 需要的 steams\n        if (extension.getDataBinding().isEnabled()) {\n            {...}\n        }\n\n        // for the sub modules, new intermediary classes artifact has its own stream\n        create \"sub-projects-classes\" stream\n            type DefaultContentType.CLASSES\n            scope Scope.SUB_PROJECTS\n            from ArtifactType.CLASSES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH\n\n        // same for the resources which can be java-res or jni\n        create \"sub-projects-res-plus-native\" stream\n            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS\n            scope Scope.SUB_PROJECTS\n            from ArtifactType.JAVA_RES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH\n\n        // and the android library sub-modules also have a specific jni folder\n        create \"sub-projects-native\" stream\n            type ExtendedContentType.NATIVE_LIBS\n            scope Scope.SUB_PROJECTS\n            from ArtifactType.JNI files in ArtifactScope.MODULE on RUNTIME_CLASSPATH\n\n        // provided only scopes.\n        create \"provided-classes\" stream\n            type DefaultContentType.CLASSES\n            scope Scope.PROVIDED_ONLY\n            from ArtifactType.JNI files in ArtifactScope.MODULE on (COMPILE_CLASSPATH minus RUNTIME_CLASSPATH)\n        \n        // @Test,  创建 test 需要的 steams\n        if (variantScope.getTestedVariantData() != null) {\n            {...}\n        }\n    }\n\n    ...\n}\n```\n\ncompile 任务创建流程: \n\n```\nclass ApplicationTaskManager extends TaskManager {\n    ...\n\n    private void addCompileTask(@NonNull TaskFactory tasks, @NonNull VariantScope variantScope) {\n        \n        // @DataBinding\n        createDataBindingMergeArtifactsTaskIfNecessary(tasks, variantScope);\n\n        // in createJavacTask()\n        create \"javaPreCompile{VariantName}\" as JavaPreCompileTask type.\n            let \"javaPreCompile{VariantName}\" dependsOn \"pre{VariantName}Build\"\n\n        create \"compile{VariantName}JavaWithJavac\" as AndroidJavaCompile type.\n            let \"compile{VariantName}JavaWithJavac\" dependsOn \"generate{VariantName}Sources\"\n\n        // Create the classes artifact for uses by external test modules.\n        create \"bundleAppClasses{VariantName}\" as Jar type.\n\n\n        // @Java8，一些基于 java8 配置的 validation 工作。\n        [+]{...}\n\n        // in addJavacClassesStream(variantScope)\n        create \"javac-output\" stream\n            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES\n            scope Scope.PROJECT\n            from JAVAC output on variantScope\n\n        create \"pre-javac-generated-bytecode\" stream\n            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES\n            scope Scope.PROJECT\n            from PreJavacGeneratedBytecode\n\n        create \"post-javac-generated-bytecode\" stream\n            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES\n            scope Scope.PROJECT\n            from PostJavacGeneratedBytecode\n        \n\n        // in setJavaCompilerTask()\n        let \"compile{VariantName}Sources\" dependsOn \"compile{VariantName}JavaWithJavac\".\n\n        // 创建生成 dex 相关的 task。\n        createPostCompilationTasks(tasks, variantScope);\n    }\n\n    ...\n}\n```\n\n```\nclass TaskMananger {\n    ...\n\n    public void createPostCompilationTasks(\n            @NonNull TaskFactory tasks,\n            @NonNull final VariantScope variantScope) {\n\n        checkNotNull(variantScope.getJavacTask());\n\n        final BaseVariantData variantData = variantScope.getVariantData();\n        final GradleVariantConfiguration config = variantData.getVariantConfiguration();\n\n        TransformManager transformManager = variantScope.getTransformManager();\n        // ---- Code Coverage first -----\n        \n        // @Test，创建测试覆盖率相关的 transform\n        if (isTestCoverageEnabled) {\n            createJacocoTransform(tasks, variantScope);\n        }\n\n        // in maybeCreateDesugarTask(tasks, variantScope, config.getMinSdkVersion(), transformManager)\n\n        // 如果 java8 支持使用 desuger\n        if (variantScope.getJava8LangSupportType() == Java8LangSupport.DESUGAR) {\n            create \"transformClassWithStackFramesFixerFor{VariantName}\" task \n                with \"stackFramesFixer\" transform as FixStackFramesTransform type.\n                on Scope.EXTERNAL_LIBRARIES\n\n            create \"transformClassWithDesugarFor{VariantName}\" task as TransformTask\n                with \"desugar\" transform as DesugarTransform type.\n                on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n\n            // 如果 minSdk.getFeatureLevel() 小于 19\n            if (minSdk.getFeatureLevel()\n                    < DesugarProcessBuilder.MIN_SUPPORTED_API_TRY_WITH_RESOURCES) {\n                create \"extractTryWithResourcesSupportJar{VariantName}\" as ExtractTryWithResourcesSupportJar type.\n                    let {@File 'intermediates/processing-tools/runtime-deps/{VariantConfigurationDir}/desugar_try_with_resources.jar'} depend on \"extractTryWithResourcesSupportJar{VariantName}\".\n\n                create 'runtime-deps-try-with-resources' stream\n                    type DefaultContentType.CLASSES\n                    scope Scope.EXTERNAL_LIBRARIES\n                    from {@File 'intermediates/processing-tools/runtime-deps/{VariantConfigurationDir}/desugar_try_with_resources.jar'}\n            }\n        }\n\n        AndroidConfig extension = variantScope.getGlobalScope().getExtension();\n\n        // in createMergeJavaResTransform(tasks, variantScope)\n        create 'transformResourcesWithMergeJavaResFor{VariantName}' task\n            with 'mergeJavaRes' transform as MergeJavaResourcesTransform type\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES \n        \n\n        // 处理开发者自行注册的 transform\n        // ----- External Transforms -----\n        // apply all the external transforms.\n        List<Transform> customTransforms = extension.getTransforms();\n        List<List<Object>> customTransformsDependencies = extension.getTransformsDependencies();\n\n        for (int i = 0, count = customTransforms.size(); i < count; i++) {\n            Transform transform = customTransforms.get(i);\n\n            List<Object> deps = customTransformsDependencies.get(i);\n            transformManager\n                    .addTransform(tasks, variantScope, transform)\n                    .ifPresent(t -> {\n                        if (!deps.isEmpty()) {\n                            t.dependsOn(tasks, deps);\n                        }\n\n                        // if the task is a no-op then we make assemble task depend on it.\n                        if (transform.getScopes().isEmpty()) {\n                            variantScope.getAssembleTask().dependsOn(tasks, t);\n                        }\n                    });\n        }\n\n        // @IDE \n        // ----- Android studio profiling transforms\n        [+]{...}\n\n        // 创建包大小压缩的 transform\n        // ----- Minify next -----\n        // in maybeCreateJavaCodeShrinkerTransform(tasks, variantScope)\n        create 'transformClassAndResourcesWithProguardFor{VariantName}' task\n            with 'proguard' as ProGuardTransform type\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n\n        create 'transformClassWithAndroidGradleClassShrinkerFor{VariantName}' task\n            with 'androidGradleClassShrinker' as BuiltInShrinkerTransform type\n            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n\n        create 'check{VariantName}ProguardFiles' as CheckProguardFiles type\n            let 'transformClassAndResourcesWithProguardFor{VariantName}' or 'transformClassWithAndroidGradleClassShrinkerFor{VariantName}' depend on 'check{VariantName}ProguardFiles'\n        \n        // in  maybeCreateResourcesShrinkerTransform(tasks, variantScope)\n        create 'transformClassWithShrinkResFor{VariantName}' task\n            with shrinkRes transform as ShrinkResourcesTransform type\n            on empty scope\n\n\n        // @InstantRun\n        // ----- 10x support\n        [+] {...}\n        \n        // ----- Multi-Dex support\n\n        DexingType dexingType = variantScope.getDexingType();\n\n        // Upgrade from legacy multi-dex to native multi-dex if possible when using with a device\n        if (dexingType == DexingType.LEGACY_MULTIDEX) {\n            if (variantScope.getVariantConfiguration().isMultiDexEnabled()\n                    && variantScope\n                                    .getVariantConfiguration()\n                                    .getMinSdkVersionWithTargetDeviceApi()\n                                    .getFeatureLevel()\n                            >= 21) {\n                dexingType = DexingType.NATIVE_MULTIDEX;\n            }\n        }\n\n        Optional<AndroidTask<TransformTask>> multiDexClassListTask;\n\n        if (dexingType == DexingType.LEGACY_MULTIDEX) {\n            boolean proguardInPipeline = variantScope.getCodeShrinker() == CodeShrinker.PROGUARD;\n\n            // If ProGuard will be used, we'll end up with a \"fat\" jar anyway. If we're using the\n            // new dexing pipeline, we'll use the new MainDexListTransform below, so there's no need\n            // for merging all classes into a single jar.\n            if (!proguardInPipeline && !usingIncrementalDexing(variantScope)) {\n                // Create a transform to jar the inputs into a single jar. Merge the classes only,\n                // no need to package the resources since they are not used during the computation.\n                 create 'transformClassWithJarMergingFor{VariantName}' task\n                    with jarMerging transform as JarMergingTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES\n            }\n\n            // ---------\n            // create the transform that's going to take the code and the proguard keep list\n            // from above and compute the main class list.\n            Transform multiDexTransform;\n            if (usingIncrementalDexing(variantScope)) {\n                create 'transformClassWithMultidexlistFor{VariantName}' task\n                    with multidexlist transform as MainDexListTransform type\n                    on empty scope\n                    set multiDexTransform with it\n            } else {\n                create 'transformClassWithMultidexlistFor{VariantName}' task\n                    with multidexlist transform as MultiDexTransform type\n                    on empty scope\n                    set multiDexTransform with it\n            }\n            multiDexClassListTask =\n                    transformManager.addTransform(tasks, variantScope, multiDexTransform);\n            multiDexClassListTask.ifPresent(variantScope::addColdSwapBuildTask);\n        } else {\n            multiDexClassListTask = Optional.empty();\n        }\n\n        if (usingIncrementalDexing(variantScope)) {\n            // in createNewDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)\n            create 'transformClassWithDexBuilderFor{VariantName}' task\n                    with dexBuilder transform as DexArchiveBuilderTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n\n            if (dexingType != DexingType.LEGACY_MULTIDEX\n                && variantScope.getCodeShrinker() == null\n                && extension.getTransforms().isEmpty()) {\n                \n                create 'transformDexArchiveWithExternalLibsDexMergerFor{VariantName}' task\n                    with externalLibsDexMerger transform as ExternalLibsMergerTransform type\n                    on Scope.EXTERNAL_LIBRARIES\n            }\n\n            create 'transformDexArchiveWithDexMergerFor{VariantName}' task\n                    with dexMerger transform as DexMergerTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n            let 'transformDexWithDexMergerFor{VariantName}' depend on 'transformClassWithMultidexlistFor{VariantName}'\n\n        } else {\n            // in createDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)\n\n            if (preDexEnabled) {\n                create 'transformClassWithPreDexFor{VariantName}' task\n                    with preDex transform as PreDexTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n            }\n\n            if (!preDexEnabled || dexingType != DexingType.NATIVE_MULTIDEX) {\n                // run if non native multidex or no pre-dexing\n                create 'transformClassWithDexFor{VariantName}' task\n                    with dex transform as DexTransform type\n                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT\n\n                let 'transformClassWithDexFor{VariantName}' depend on 'transformClassWithMultidexlistFor{VariantName}'\n            }\n\n        }\n\n        // @InstantRun\n        [+]{...}\n    }\n\n    ...\n}\n```\n\npackage 任务创建流程\n\n```\nclass TaskManager {\n    ...\n\n    public void createPackagingTask(\n            @NonNull TaskFactory tasks,\n            @NonNull VariantScope variantScope,\n            @Nullable AndroidTask<BuildInfoWriterTask> fullBuildInfoGeneratorTask) {\n        ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();\n\n        boolean signedApk = variantData.isSigned();\n\n        create \"package{VariantName}\" as PackageApplication type.\n\n        // @InstantRun\n        [+]{...}\n\n        let \"package{VariantName}\" dependsOn \"merge{VariantName}Assets\".\n        let \"package{VariantName}\" dependsOn \"process{VariantName}Resources\".\n\n        // @InstantRun\n        [+]{...}\n\n        create \"validateSigning{VariantName}\" as ValidateSigningTask type.\n            let \"package{VariantName}\" dependsOn \"validateSigning{VariantName}\".\n\n        let \"package{VariantName}\" dependsOn \"compile{VariantName}JavaWithJavac\".\n        let \"assemble{VariantName}\" dependsOn package{VariantName}\".\n\n        // @InstantRun\n        [+]{...}\n\n        // @Multi\n        [+]{...}\n\n        if (signedApk) {\n            create \"install{VariantName}\" as InstallVariantTask type.\n                let \"install{VariantName}\" dependsOn \"assemble{VariantName}\".\n        }\n\n        // in maybeCreateLintVitalTask()\n        create \"lintVital{VariantName}\" as LintPerVariantTask type.\n            let \"lintVital{VariantName}\" dependsOn \"compile{VariantName}JavaWithJavac\".\n        let \"assemble{VariantName}\" dependsOn \"lintVital{VariantName}\".\n\n        // 如果任务树中包含 \"lint\"，就不再执行 \"lintVital{VariantName}\".\n        project.getGradle().getTaskGraph().whenReady(\n            taskGraph -> {\n                if (taskGraph.hasTask(getTaskPath(LINT))) {\n                    project.getTasks()\n                            .getByName(lintReleaseCheck.getName())\n                            .setEnabled(false);\n                }});\n\n        create \"uninstall{VariantName}\" as UninstallTask type.\n            let \"uninstallAll\" dependsOn \"uninstall{VariantName}\".\n    }\n\n    ...\n}\n```\n\n#### `ApiObjectFactory.create()`\n\n基于 BaseVariantData 对象创建 BaseVariantImpl 对象, 并将 BaseVariantImpl 对象加入 extension 的容器中，到这里 project 模型的搭建完成。\n\n```\npublic BaseVariantImpl create(BaseVariantData variantData) {\n    if (variantData.getType().isForTesting()) {\n        // Testing variants are handled together with their \"owners\".\n        createVariantOutput(variantData, null);\n        return null;\n}\n\n    BaseVariantImpl variantApi =\n        variantFactory.createVariantApi(\n            instantiator,\n            objectFactory,\n            androidBuilder,\n            variantData,\n            readOnlyObjectProvider);\n\n    if (variantApi == null) {\n        return null;\n    }\n\n    // @Test\n    if (variantFactory.hasTestScope()) {\n        // 创建 TestVariantImpl 对象和 UnitTestVariantImpl 对象\n        [+]{...}\n    }\n\n    // in createVariantOutput(variantData, variantApi)\n    // 创建 VariantOutputFactory 对象\n    variantData.variantOutputFactory =\n        new VariantOutputFactory(\n            (variantData.getType() == LIBRARY)\n                    ? LibraryVariantOutputImpl.class\n                    : ApkVariantOutputImpl.class,\n            instantiator,\n            extension,\n            variantApi,\n            variantData);\n\n    // 修改 apk 输出的的 versionCode 和 versionName\n    variantData\n            .getOutputScope()\n            .getApkDatas()\n            .forEach(\n                apkData -> {\n                    apkData.setVersionCode(\n                        variantData.getVariantConfiguration().getVersionCode());\n                    apkData.setVersionName(\n                        variantData.getVariantConfiguration().getVersionName());\n                    variantData.variantOutputFactory.create(apkData);\n                });\n\n    // 将 BaseVariantImpl 对象置入 extension 的 variantList 容器中\n    // Only add the variant API object to the domain object set once it's been fully\n    // initialized.\n    extension.addVariant(variantApi);\n\n    return variantApi;\n}\n```\n\n\n### Android Transform 体系\n\n## 附表\n\n### android plugin 支持的 gradle properties\n\n","slug":"android-plugin-overview","published":0,"date":"2019-03-08T03:12:27.000Z","updated":"2019-03-08T03:12:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq0lr4pz00413mrf11r1ci7p","content":"<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why ?\"></a>Why ?</h2><p>目标：使 Android 编译过程由黑盒变为白盒。<br>好处： </p>\n<ul>\n<li>理解 android plugin 接口含义和能力，更好的编写编译脚本。  </li>\n<li>熟悉 android gradle 任务树，方便在编写 gradle 插件时 hook android 编译任务。 </li>\n<li>看懂编译中间产物、以及熟练的调试编译源码，以便在开发时定位编译时发生的问题。 </li>\n<li>了解 android 编译 toolChain 和 编译输出，是进一步学习 Android Runtime 的基础。 </li>\n</ul>\n<h2 id=\"行文\"><a href=\"#行文\" class=\"headerlink\" title=\"行文\"></a>行文</h2><p>版本：源码基于 android plugin 3.0.0，gradle 4.1。<br>主流程：<br>首先，在本篇概览中会概述 Android 的编译流程，浏览 android plugin 的入口源码。<br>而后，分别详述编译流程中的各个阶段 ：针对该编译阶段所涉及的 plugin api、project 模型、编译任务、toolChain、输入以及输出进行纵向分析，可能会浏览该阶段编译任务以及 toolChain 的源码。<br>最后，会分析 application 工程和 library 工程在编译时的区别。   </p>\n<p>副流程：<br>Android 编译中涉及到了很多 Optional 的话题，这些话题会渗透到编译流程的各个阶段。将这些话题从主流程中分离出来，以切面的形式归纳为副流程分别单独学习，也许是更好的方式。   </p>\n<p>副流程也许会包括 (排在越后面，会被包括的可能性越小)：</p>\n<ul>\n<li>Java8 support。</li>\n<li>Kotlin。</li>\n<li>AppBundle</li>\n<li>单元测试与集成测试。</li>\n<li>Lint。</li>\n<li>Ndk。</li>\n<li>Instant Run。</li>\n<li>DataBinding。</li>\n<li>Wear &amp; TV support。</li>\n<li>IDE。</li>\n</ul>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>gradle 编译脚本 &amp;  -&gt; plugin api -&gt; project 模型 -&gt; 编译任务树 &amp; Transtrom 流 -&gt; toolChain -&gt; 中间产物文件流 -&gt; 编译输出</p>\n<p>结构基础：gradle api、 gradle、android sdk。</p>\n<p>这一篇会包含 plugin api -&gt; project 模型 -&gt; 编译任务树 &amp; Transtrom 流 三个部分；之后在各个编译流程流程中会涉及到 编译任务树 &amp; Transtrom 流  -&gt; toolChain -&gt; 中间产物文件流。   </p>\n<h2 id=\"android-plugin-api-概览\"><a href=\"#android-plugin-api-概览\" class=\"headerlink\" title=\"android plugin api 概览\"></a>android plugin api 概览</h2><p>plugin api 是 android 编译系统暴露给开发者的配置接口，以基于 gradle &amp; groovy 的 DSL (Domain-specific language) 组织而成。plugin api 可以大致被划分为 plugin、extension、dsl model 三个部分：</p>\n<ul>\n<li>plugin 是 android 编译系统的入口，开发者通过 apply plugin 来调用编译系统，进而完成暴露 plugin api，构建 project 模型，生成编译任务等一系列流程。</li>\n<li>extension 是承载 dsl model 的对象，它通过 delegate 的方式挂载到扩 gradle project 上，方便开发者通过对其成员赋值，从而完成编译配置过程。 </li>\n<li>dsl model 的接口繁多，是 plugin api 的主体，代表了 android 编译过程的各种配置参数。</li>\n</ul>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p><img src=\"https://i.loli.net/2019/03/07/5c80c1f57f944.jpg\" alt=\"Android-Gradle-Plugins\"></p>\n<p><code>BasePlugin</code> 有多个继承类型，各个继承类型对应了不同类型的 android plugin，以支持不同的 android 编译类型。</p>\n<ul>\n<li><code>AppPlugin</code> (com.android.application)，构建 app 工程。</li>\n<li><code>LibraryPlugin</code> (com.android.library)，构建 library 工程。</li>\n<li><code>FeaturePlugin</code> (com.android.feature)，构建 app-bundle。</li>\n<li><code>InstantAppPlugin</code> (com.android.instantapp)，执行 intant-run。</li>\n<li><code>TestPlugin</code> （com.android.test)，用单独工程执行 instrumented-test。</li>\n</ul>\n<p>android plugin 绝大部分配置过程代码都包含在 <code>BasePlugin</code> 中，<code>BasePlugin</code> 的各个子类仅仅创建并返回了类型不同的 <code>BaseExtension</code>、<code>VariantFactory</code>、<code>TaskManager</code> 实现类对象。基于这些不同的实现对象，使各种编译类型在 plugin api、project 模型和编译任务等方面略有不同。</p>\n<h3 id=\"extensions\"><a href=\"#extensions\" class=\"headerlink\" title=\"extensions\"></a>extensions</h3><h2 id=\"android-的-project-模型概览\"><a href=\"#android-的-project-模型概览\" class=\"headerlink\" title=\"android 的 project 模型概览\"></a>android 的 project 模型概览</h2><h2 id=\"android-的编译任务树概览\"><a href=\"#android-的编译任务树概览\" class=\"headerlink\" title=\"android 的编译任务树概览\"></a>android 的编译任务树概览</h2><h2 id=\"在读源码之前\"><a href=\"#在读源码之前\" class=\"headerlink\" title=\"在读源码之前\"></a>在读源码之前</h2><h3 id=\"源码工程-–-gradle-和-gradle-core\"><a href=\"#源码工程-–-gradle-和-gradle-core\" class=\"headerlink\" title=\"源码工程 – :gradle 和 :gradle-core\"></a>源码工程 – :gradle 和 :gradle-core</h3><p>:gradle 包含了 android plugin 链接到 gradle project 的 anchor 类，即一些 plugin 和 extension 类，这里就是 android plugin 的入口。<br>:gradle-core 是 android plugin 的实现工程，里面包含了 project 模型的管理类、 构建任务树的管理类、任务的实现类等。 这些类被 :gralde 工程中的 plugin 调用，处理 开发者编译脚本向 extension 中提交的信息、建立 project 模型、创建 android task，并经过各类 android task 链接到 android 构建的 toolchain。    </p>\n<h3 id=\"源码阅读的起点-–-BasePlugin-apply\"><a href=\"#源码阅读的起点-–-BasePlugin-apply\" class=\"headerlink\" title=\"源码阅读的起点 – BasePlugin.apply()\"></a>源码阅读的起点 – <code>BasePlugin.apply()</code></h3><p><code>BasePlugin</code> 是所有 android plugin 的基类，<code>BasePlugin.apply()</code> 方法可以视为 android plugin 的程序入口。这个方法涵盖了 android plugin 配置阶段的全部过程， 以 <code>BasePlugin.apply()</code> 为起点可以了解 android plugin 工程模型的创建过程和任务树的创建过程。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"BasePlugin-apply\"><a href=\"#BasePlugin-apply\" class=\"headerlink\" title=\"BasePlugin::apply()\"></a><code>BasePlugin::apply()</code></h3><ul>\n<li>进行一系列的 validate 检查。</li>\n<li>读取 gradle.properties 文件中所有与 android plugin 有关的配置，并根据这些配置初始化一些编译参数。</li>\n<li>调用<code>configureProject()</code>、<code>configureExtension()</code>、<code>createTasks()</code> 三个方法；这三个方法就是 android plugin 配置阶段的主体操作。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void apply(@NonNull Project project) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\"></span><br><span class=\"line\">       //AndroidBasePlugin 会被所有 plugin 类型 apply，它不做任何事情，只是方便判断是否有某种 android 的 plugin 类被 applay 过了。</span><br><span class=\"line\">       project.getPluginManager().apply(AndroidBasePlugin.class);</span><br><span class=\"line\">       </span><br><span class=\"line\">       // 检查 builder.jar 的版本号是否和 android plugin 的版本号一致，否则抛异常。</span><br><span class=\"line\">       // 如果使用了 &#x27;com.android.tools.build:gradle-experimental&#x27; 中的  gradle-experimental 插件，</span><br><span class=\"line\">       // 并且其版本和 &#x27;com.android.tools.build:gradle&#x27; 的版本不一致，</span><br><span class=\"line\">       // 那么就会出现 builder.jar 的版本号是否和 android plugin 的版本号不一致的情况。</span><br><span class=\"line\">       // TODO: what&#x27;s gradle-experimental</span><br><span class=\"line\">       checkPluginVersion();</span><br><span class=\"line\"></span><br><span class=\"line\">       this.project = project;</span><br><span class=\"line\"></span><br><span class=\"line\">       // ProjectOptions 是一个 Immutable 模型对象，它包含了很多类型为 Option&lt;String&gt; 对象。</span><br><span class=\"line\">       // ProjectOptions 实际上是一个 key-value 形式的配置表，包含了 gradle.properties 文件中所有与 android plugin 有关的配置。</span><br><span class=\"line\">       // 各类配置被定义在 :gradle-core &gt; com.android.build.gradle.options 包下面的枚举类中。</span><br><span class=\"line\">       // 这些配置大多以 &#x27;android.&#x27; 开头，详见附表部分。</span><br><span class=\"line\">       this.projectOptions = new ProjectOptions(project);</span><br><span class=\"line\"></span><br><span class=\"line\">       // 由  &#123;@GradleProperties &#x27;android.threadPoolSize&#x27;&#125; 配置来设置 ExecutorSingleton 的线程池尺寸。</span><br><span class=\"line\">       ExecutionConfigurationUtil.setThreadPoolSize(projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">       //在 window 平台上，gradle 工程 根目录的绝对路径上不能有非ASCII字符，否则就抛出异常，原因参见 http://b.android.com/95744；可以配置&#123;@GradleProperties &#x27;android.overridePathCheck&#x27;&#125; = true 屏蔽这个检查。</span><br><span class=\"line\">       checkPathForErrors();</span><br><span class=\"line\"></span><br><span class=\"line\">       //gradle 工程中，不能存在两个同名的子工程，否则就抛出异常。</span><br><span class=\"line\">       checkModulesForErrors();</span><br><span class=\"line\">       </span><br><span class=\"line\">       // PluginInitializer 用于验证两件事情：</span><br><span class=\"line\">       // 在一次构建中，不同子工程使用的 android plugin 版本一致。</span><br><span class=\"line\">       // 在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。</span><br><span class=\"line\">       PluginInitializer.initialize(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">       // ProfilerInitializer 通过向 gradle 注册监听，记录*当前子工程*所有 gradle task 的执行时间。</span><br><span class=\"line\">       // 当构建结束之后，将所记录的时间输出到 &#x27;project.getRootProject()/build/android-profile/profile-&#x27;YYYY-MM-dd-HH-mm-ss-SSS&#x27;.rawproto&#x27; 文件中。</span><br><span class=\"line\">       // TODO: 这个文件的作用是什么？猜测是给 IDE 用的。</span><br><span class=\"line\">       ProfilerInitializer.init(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">       ...</span><br><span class=\"line\"></span><br><span class=\"line\">       // 涵盖 BasePlugin 主体操作的三个 private 方法。 </span><br><span class=\"line\">       configureProject()</span><br><span class=\"line\">       configureExtension()</span><br><span class=\"line\">       createTasks()</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"PluginInitializer\"><a href=\"#PluginInitializer\" class=\"headerlink\" title=\"PluginInitializer\"></a><code>PluginInitializer</code></h4><p><code>PluginInitializer</code> 这个类比较有意思，它的作用是验证 android plugin 在各个子工程之间一致性。具体来说包含如下两方面验证：</p>\n<ul>\n<li>在一次构建中，不同子工程使用的 android plugin 版本一致。</li>\n<li>在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。<br>那么问题来了，无论是不同的子工程使用了不同的 android plugin 版本，还是 android plugin 的 class 文件被不同的 classloader 加载，都会在 jvm 中形成两套相互独立的 class，要如何检测这种情况呢。<br><code>PluginInitializer</code> 有两个静态变量分别负责上述两种检查，分别是 <code>projectToPluginVersionMap</code> 和 <code>loadedPluginClass</code>，这两个变量是通过 <code>JvmWideVariable</code> 获得的。<code>JvmWideVariable</code> 提供了一种直接在 jvm 创建对象的方式，并通过字符串 key 来获取对象引用。所以 <code>PluginInitializer</code> 的 <code>projectToPluginVersionMap</code> 和 <code>loadedPluginClass</code> 并不是和 class 绑定的静态对象，而是通过字符串 key 直接维护在 jvm 的堆中。只要不同版本的 android plugin 使用相同的 key 从 jvm 中创建和获取对象，那么即使是相互独立的 class 也能取得同一个对象，从而经由不同版本 android plugin 相互协作实现 <code>PluginInitializer</code> 所需验证的情况。<br>可以看见源码中对于 key 常量有如下注释：</li>\n</ul>\n<blockquote>\n<p>IMPORTANT: This variable’s group, name, and type must not be changed across<br>plugin versions.</p>\n</blockquote>\n<p>另外，什么情况下会发生 android plugin 被不同的 classloader 加载呢？源码的异常信息中给了如下解释，如果有兴趣可以看<a href=\"https://d.android.com/r/tools/buildscript-classpath-check.html\">issue链接</a></p>\n<blockquote>\n<p>Due to a limitation of Gradle’s new variant-aware dependency management, loading the Android Gradle plugin in different class loaders leads to a build error.<br>This can occur when the buildscript classpaths that contain the Android Gradle plugin in sub-projects, or included projects in the case of composite builds, are set differently.<br>To resolve this issue, add the Android Gradle plugin to only the buildscript classpath of the top-level build.gradle file.<br>In the case of composite builds, also make sure the build script classpaths that contain the Android Gradle plugin are identical across the main and included projects.<br>If you are using a version of Gradle that has fixed the issue, you can disable this check by setting android.enableBuildScriptClasspathCheck=false in the gradle.properties file.<br>To learn more about this issue, go to <a href=\"https://d.android.com/r/tools/buildscript-classpath-check.html\">https://d.android.com/r/tools/buildscript-classpath-check.html</a>.   </p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class PluginInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Map&lt;gradle project 对象 , android plugin 版本的&gt; , 所用版本的 android plugin 共用一个对象，用于判断是否存在多个版本。</span><br><span class=\"line\">    // IMPORTANT: This variable&#x27;s group, name, and type must not be changed across plugin versions.</span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private static final ConcurrentMap&lt;Object, String&gt; projectToPluginVersionMap =</span><br><span class=\"line\">            Verify.verifyNotNull(</span><br><span class=\"line\">                    new JvmWideVariable&lt;&gt;(</span><br><span class=\"line\">                                    </span><br><span class=\"line\">                                    &quot;PLUGIN_VERSION_CHECK&quot;,</span><br><span class=\"line\">                                    &quot;PROJECT_TO_PLUGIN_VERSION&quot;,</span><br><span class=\"line\">                                    new TypeToken&lt;ConcurrentMap&lt;Object, String&gt;&gt;() &#123;&#125;,</span><br><span class=\"line\">                                    ConcurrentHashMap::new)</span><br><span class=\"line\">                            .get());</span><br><span class=\"line\"></span><br><span class=\"line\">    // AndroidBasePlugin.class 的引用，对于同一个 android plugin 版本的多次加载而言，共用一个对象，用于判断同一个版本是否被多个 classloader 加载。</span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private static final AtomicReference&lt;Class&lt;?&gt;&gt; loadedPluginClass =</span><br><span class=\"line\">            Verify.verifyNotNull(</span><br><span class=\"line\">                    new JvmWideVariable&lt;&gt;(</span><br><span class=\"line\">                                    PluginInitializer.class.getName(),</span><br><span class=\"line\">                                    &quot;loadedPluginClass&quot;,</span><br><span class=\"line\">                                    Version.ANDROID_GRADLE_PLUGIN_VERSION,</span><br><span class=\"line\">                                    new TypeToken&lt;AtomicReference&lt;Class&lt;?&gt;&gt;&gt;() &#123;&#125;,</span><br><span class=\"line\">                                    () -&gt; new AtomicReference&lt;&gt;(null))</span><br><span class=\"line\">                            .get());</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void initialize(</span><br><span class=\"line\">        </span><br><span class=\"line\">        // BuildSessionImpl 提供了一整次 gradle 构建结束的监听 (例如一次命令行输入全部执行完成)。</span><br><span class=\"line\">        // 这里注册监听，当一整次构建结束之后，重置 projectToPluginVersionMap 和 loadedPluginClass。</span><br><span class=\"line\">        // 由于 gradle 有进程重用机制，多次构建可能发生在同一个进程；只需要保证在一整次构建中，版本一致性，所以构建完成后重置状态。</span><br><span class=\"line\">        BuildSessionImpl.getSingleton().initialize(project.getGradle());</span><br><span class=\"line\">        BuildSessionImpl.getSingleton()</span><br><span class=\"line\">                .executeOnceWhenBuildFinished(</span><br><span class=\"line\">                        PluginInitializer.class.getName(),</span><br><span class=\"line\">                        &quot;resetPluginCheckVariables&quot;,</span><br><span class=\"line\">                        () -&gt; &#123;</span><br><span class=\"line\">                            projectToPluginVersionMap.clear();</span><br><span class=\"line\">                            loadedPluginClass.set(null);</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 向 projectToPluginVersionMap 中写入当前工程对象和现在所执行的 android plugin 版本，如果 Map 中有两个不一样的 android plugin 版本，那么就抛出异常。</span><br><span class=\"line\">        synchronized (projectToPluginVersionMap) &#123;</span><br><span class=\"line\">            verifySamePluginVersion(</span><br><span class=\"line\">                    projectToPluginVersionMap, project, Version.ANDROID_GRADLE_PLUGIN_VERSION);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 向 loadedPluginClass 写入现在所执行的 android plugin 的 AndroidBasePlugin.class 对象，如果 loadedPluginClass 保存了和写入的 AndroidBasePlugin.class 对象不同的值，则抛出异常。</span><br><span class=\"line\">        // 配置 &#123;@GradleProperties &#x27;android.enableBuildScriptClasspathCheck&#x27;&#125; = false 来屏蔽这个检查。</span><br><span class=\"line\">        verifyPluginLoadedOnce(</span><br><span class=\"line\">                loadedPluginClass,</span><br><span class=\"line\">                AndroidBasePlugin.class,</span><br><span class=\"line\">                projectOptions.get(BooleanOption.ENABLE_BUILDSCRIPT_CLASSPATH_CHECK));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"BasePlugin-apply-gt-configureProject\"><a href=\"#BasePlugin-apply-gt-configureProject\" class=\"headerlink\" title=\"BasePlugin::apply() &gt; configureProject()\"></a><code>BasePlugin::apply() &gt; configureProject()</code></h3><p><code>configureProject()</code> 做了一些零散的不易归类初始化任务，这些任务中需要进一步分析的也不多。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void configureProject() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ExtraModelInfo 存储一些不易归类的 extra 信息 ：</span><br><span class=\"line\">    // * 存储构建过程中的检测到的 waring 和 error 信息，并输出这些信息, 根据这次构建是由 ide 触发的还是开发者触发的，信息可能以 &#x27;MACHINE_PARSABLE&#x27; 或 &#x27;HUMAN_READABLE&#x27; 两种格式输出。</span><br><span class=\"line\">    // TODO: 在后续源码分析中，补充在 ExtraModelInfo 其他信息的作用</span><br><span class=\"line\">    extraModelInfo = new ExtraModelInfo(projectOptions, project.getLogger());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 检查当前 gradle 版本不低于 当前运行的 android plugin 所要求的最低版本，否则抛出异常。</span><br><span class=\"line\">    // 配置 &#123;@GradleProperties &#x27;android.overrideVersionCheck&#x27;&#125; = true，可以仅输出 waring 信息不抛出异常。</span><br><span class=\"line\">    checkGradleVersion();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // SdkHandler 是 android sdk 信息的封装类，在构造方法中会寻找 andorid sdk 的路径。</span><br><span class=\"line\">    sdkHandler = new SdkHandler(project, getLogger());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当 &#123;@GradleProperties &#x27;android.builder.sdkDownload&#x27;&#125; = true、并且当前构建不是由 IDE 触发、并且当前构建的 gradle 建参数不包含 &#x27;--offline&#x27; 这个三个条件成立时：</span><br><span class=\"line\">    // SdkHandler 会在使用 android sdk 中工具时自动下载，这样即使不安装 android sdk 也能完成 android 工程构建。</span><br><span class=\"line\">    //  SdkLibData 时下载信息的抽象，包括 Downloader 对象和 SettingsController 的实现。</span><br><span class=\"line\">    // SettingsController 是注入下载配置的接口，默认实现中包括了指定使用 https、从&#123;@GradleProperties &#x27;android.sdk.channel&#x27;&#125; 中获取下载channel、从 System.getProperties() 获取网络代理信息等。</span><br><span class=\"line\">    if (!project.getGradle().getStartParameter().isOffline() </span><br><span class=\"line\">                &amp;&amp; projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)</span><br><span class=\"line\">                &amp;&amp; !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) &#123;</span><br><span class=\"line\">            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());</span><br><span class=\"line\">            sdkHandler.setSdkLibData(sdkLibData);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    // AndroidBuilder 是构建 toolchain 的接口类。</span><br><span class=\"line\">    androidBuilder = new AndroidBuilder(</span><br><span class=\"line\">                project == project.getRootProject() ? project.getName() : project.getPath(),</span><br><span class=\"line\">                creator,</span><br><span class=\"line\">                new GradleProcessExecutor(project),</span><br><span class=\"line\">                new GradleJavaProcessExecutor(project),</span><br><span class=\"line\">                extraModelInfo,</span><br><span class=\"line\">                getLogger(),</span><br><span class=\"line\">                isVerbose());</span><br><span class=\"line\"></span><br><span class=\"line\">    // @DataBinding 初始化 DataBindingBuilder。</span><br><span class=\"line\">    [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // apply 了 JavaBasePlugin 插件和 JacocoPlugin 插件</span><br><span class=\"line\">    project.getPlugins().apply(JavaBasePlugin.class);</span><br><span class=\"line\">    project.getPlugins().apply(JacocoPlugin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 替换 &#123;@Task assemble&#125; 的描述，&#123;@Task assemble&#125; 在 apply JavaBasePlugin.class 之后创建。</span><br><span class=\"line\">    project.getTasks().getByName(&quot;assemble&quot;)</span><br><span class=\"line\">        .setDescription(&quot;Assembles all variants of all applications and secondary packages.&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    project.getGradle().addBuildListener(</span><br><span class=\"line\">        buildFinished(BuildResult buildResult) -&gt; &#123;</span><br><span class=\"line\">            // 构建结束后一些 release 工作。</span><br><span class=\"line\">            ExecutorSingleton.shutdown();</span><br><span class=\"line\">            sdkHandler.unload();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 清理 PreDexCache 中的缓存，并将其写在 &#x27;&#123;@File gradleProjectRoot&#125;/build/intermediates/dex-cache/cache.xml&#x27; 文件</span><br><span class=\"line\">            // TOOD : 分析 Dex 过程时在回来看这里。</span><br><span class=\"line\">            PreDexCache.getCache().clear(</span><br><span class=\"line\">                FileUtils.join(</span><br><span class=\"line\">                    project.getRootProject().getBuildDir(),</span><br><span class=\"line\">                    FD_INTERMEDIATES,</span><br><span class=\"line\">                    &quot;dex-cache&quot;,</span><br><span class=\"line\">                    &quot;cache.xml&quot;),</span><br><span class=\"line\">                getLogger());</span><br><span class=\"line\">                Main.clearInternTables();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    // 任务树生成后进行检查：如果任务树中存在 DexTransform 类型的任务，</span><br><span class=\"line\">    // PreDexCache 从 &#x27;&#123;@File gradleProjectRoot&#125;/build/intermediates/dex-cache/cache.xml&#x27; 文件加载缓存。</span><br><span class=\"line\">    // TOOD : 分析 Dex 过程时在回来看这里。</span><br><span class=\"line\">    project.getGradle().getTaskGraph().addTaskExecutionGraphListener(</span><br><span class=\"line\">        (taskGraph) -&gt; &#123;</span><br><span class=\"line\">            for (Task task : taskGraph.getAllTasks()) &#123;</span><br><span class=\"line\">                if (task instanceof TransformTask) &#123;</span><br><span class=\"line\">                    Transform transform = ((TransformTask) task).getTransform();</span><br><span class=\"line\">                    if (transform instanceof DexTransform) &#123;</span><br><span class=\"line\">                        PreDexCache.getCache().load(</span><br><span class=\"line\">                            FileUtils.join(</span><br><span class=\"line\">                                project.getRootProject().getBuildDir(),</span><br><span class=\"line\">                                FD_INTERMEDIATES,</span><br><span class=\"line\">                                dex-cache&quot;,</span><br><span class=\"line\">                                &quot;cache.xml&quot;));</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"SdkHandler-寻找-android-sdk-路径\"><a href=\"#SdkHandler-寻找-android-sdk-路径\" class=\"headerlink\" title=\"SdkHandler 寻找 android sdk 路径\"></a><code>SdkHandler</code> 寻找 android sdk 路径</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SdkHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public SdkHandler(@NonNull Project project,</span><br><span class=\"line\">                      @NonNull ILogger logger) &#123;</span><br><span class=\"line\">        this.logger = logger;</span><br><span class=\"line\">        findLocation(project);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void findLocation(@NonNull Project project) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //@Test </span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //读取 &#x27;&#123;@File gradleProjectRoot&#125;/local.properties&#x27;</span><br><span class=\"line\">        File rootDir = project.getRootDir();</span><br><span class=\"line\">        File localProperties = new File(rootDir, FN_LOCAL_PROPERTIES);</span><br><span class=\"line\">        Properties properties = new Properties();</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 按照如下优先级寻找 android sdk 路径：</span><br><span class=\"line\">        // local.properties 的 &#x27;sdk.dir&#x27; 属性 &gt; local.properties 的 &#x27;android.dir&#x27; 属性 &gt; </span><br><span class=\"line\">        // ANDROID_HOME 环境变量 &gt; android.home 环境变量。</span><br><span class=\"line\">        Pair&lt;File, Boolean&gt; sdkLocation = findSdkLocation(properties, rootDir);</span><br><span class=\"line\">        sdkFolder = sdkLocation.getFirst();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // isRegularSdk 的作用见下面 getSdkLoader() 方法前</span><br><span class=\"line\">        isRegularSdk = sdkLocation.getSecond();</span><br><span class=\"line\"></span><br><span class=\"line\">        //按照如下优先级寻找 ndk路径</span><br><span class=\"line\">        // local.properties 的 &#x27;ndk.dir&#x27; 属性 &gt; ANDROID_NDK_HOME 环境变量</span><br><span class=\"line\">        // &gt; &#x27;&#123;@File sdkFolder&#125;/ndk-bundle&#x27;</span><br><span class=\"line\">        ndkFolder = NdkHandler.findNdkDirectory(properties, rootDir);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Ndk 从 local.properties 中读出 &#x27;cmake.dir&#x27;，并赋值给 cmakePathInLocalProp 属性(File 类型)。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 仅当 android sdk 路径是由 local.properties 的 &#x27;android.dir&#x27; 属性定义时，isRegularSdk 为 false。</span><br><span class=\"line\">    // 这时认为当前构建使用 &quot;Platform-based&quot; 的 android sdk，其文件布局与开发使用的 android sdk 不同，</span><br><span class=\"line\">    // 所以在解析 android sdk 文件布局时使用 PlatformLoader 而非 DefaultSdkLoader。</span><br><span class=\"line\">    // 在依赖 android 源码中的 android sdk 而非发布版的 android sdk 会出现这种情况。</span><br><span class=\"line\">    public synchronized SdkLoader getSdkLoader() &#123;</span><br><span class=\"line\">        if (sdkLoader == null) &#123;</span><br><span class=\"line\">            if (isRegularSdk) &#123;</span><br><span class=\"line\">                sdkLoader = DefaultSdkLoader.getLoader(sdkFolder);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                sdkLoader = PlatformLoader.getLoader(sdkFolder);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sdkLoader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BasePlugin-apply-gt-configureExtension\"><a href=\"#BasePlugin-apply-gt-configureExtension\" class=\"headerlink\" title=\"BasePlugin::apply() &gt; configureExtension()\"></a><code>BasePlugin::apply() &gt; configureExtension()</code></h3><ul>\n<li>创建了 extension 对象并将其注册到 gradle project 中，extension 对象包含 android plugin 和用户构建脚本之间的所有 api 对象，这些 api 对象定义的 android plugin api 并承载了构建脚本中的开发者配置。</li>\n<li>初始化 project 模型和任务树有关的管理类：TaskManager、VariantManager、VariantFactory，这3个管理类可以说是配置阶段的核心；这些管理类通过注册 api 对象监听事件，收集开发者构建脚本中的配置信息。</li>\n<li>创建 FileCache、GlobalScope 等一些上下文对象。</li>\n</ul>\n<p>完成 <code>configureExtension()</code> 执行后 android plugin 就已经做好执行构建脚本，获取配置信息的准备了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void configureExtension() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建了承载 BuildType、ProductFlavor、SigningConfig 的3个容器。</span><br><span class=\"line\">    // 这3个容器作为创建 extension 的参数，通过 extension 链接到编译脚步，收集开发者配置。</span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer =</span><br><span class=\"line\">            project.container(BuildType.class,</span><br><span class=\"line\">                    new BuildTypeFactory(instantiator, project, extraModelInfo));</span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer =</span><br><span class=\"line\">            project.container(ProductFlavor.class,</span><br><span class=\"line\">                    new ProductFlavorFactory(</span><br><span class=\"line\">                            instantiator, project, project.getLogger(), extraModelInfo));</span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer =</span><br><span class=\"line\">            project.container(SigningConfig.class, new SigningConfigFactory(instantiator));</span><br><span class=\"line\"></span><br><span class=\"line\">    // TODO：BaseVariantOutput </span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs =</span><br><span class=\"line\">            project.container(BaseVariantOutput.class);</span><br><span class=\"line\">    project.getExtensions().add(&quot;buildOutputs&quot;, buildOutputs);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 extension 对象，可以看到之前创建的4个容器最终由 extension 对象持有。</span><br><span class=\"line\">    // 创建 extension 的过程会完成以下工作：</span><br><span class=\"line\">    // * 完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；</span><br><span class=\"line\">    // * 通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；</span><br><span class=\"line\">    // *为 android plugin api 对象添加默认配置。</span><br><span class=\"line\">    extension =</span><br><span class=\"line\">            createExtension(</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    instantiator,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    sdkHandler,</span><br><span class=\"line\">                    buildTypeContainer,</span><br><span class=\"line\">                    productFlavorContainer,</span><br><span class=\"line\">                    signingConfigContainer,</span><br><span class=\"line\">                    buildOutputs,</span><br><span class=\"line\">                    extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    // @Ndk 创建 NdkHandler。</span><br><span class=\"line\">    [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 FileCache 和 GlobalScope 对象，FileCache 被 GlobalScope 对象持有。</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 当 &#x27;&#123;@GradleProperties android.enableBuildCache&#125;&#x27; = true 时创建 FileCache。</span><br><span class=\"line\">    // FileCache 默认缓存路径是 &#x27;&#123;@File androidHomeDir&#125;/build-cache&#x27;，可以通过 &#x27;&#123;@GradleProperties android.buildCacheDir&#125;&#x27; 自定义缓存路径。</span><br><span class=\"line\">    // &#123;@File androidHomeDir&#125; 是选取规则在见后面设置 debug.keystore 的代码分析。</span><br><span class=\"line\">    // FileCache 的实际作用留到它被使用时再分析。</span><br><span class=\"line\">    @Nullable</span><br><span class=\"line\">    FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">    // GlobalScope 对象是当前 android 工程的上下文对象，它只负责持有对象，方便获取。</span><br><span class=\"line\">    // GlobalScope 对象 之后分别被 TaskManager、VariantManager、VariantFactory 3个对象持有。</span><br><span class=\"line\">    GlobalScope globalScope =</span><br><span class=\"line\">            new GlobalScope(</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    sdkHandler,</span><br><span class=\"line\">                    ndkHandler,</span><br><span class=\"line\">                    registry,</span><br><span class=\"line\">                    buildCache);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 TaskManager、VariantManager、VariantFactory 3个管理类。</span><br><span class=\"line\">    variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);</span><br><span class=\"line\">    taskManager =</span><br><span class=\"line\">            createTaskManager(</span><br><span class=\"line\">                    globalScope,</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    dataBindingBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    sdkHandler,</span><br><span class=\"line\">                    ndkHandler,</span><br><span class=\"line\">                    registry,</span><br><span class=\"line\">                    threadRecorder);</span><br><span class=\"line\">    variantManager =</span><br><span class=\"line\">            new VariantManager(</span><br><span class=\"line\">                    globalScope,</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    variantFactory,</span><br><span class=\"line\">                    taskManager,</span><br><span class=\"line\">                    threadRecorder);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 Add 事件监听。</span><br><span class=\"line\">    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class=\"line\">    buildTypeContainer.whenObjectAdded(</span><br><span class=\"line\">            buildType -&gt; &#123;</span><br><span class=\"line\">                SigningConfig signingConfig =</span><br><span class=\"line\">                        signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class=\"line\">                buildType.init(signingConfig);</span><br><span class=\"line\">                variantManager.addBuildType(buildType);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 remove 事件监听。</span><br><span class=\"line\">    // 禁止开发者对这三个配置做 remove 操作，如果发生就抛出异常。</span><br><span class=\"line\">    signingConfigContainer.whenObjectRemoved(</span><br><span class=\"line\">            new UnsupportedAction(&quot;Removing signingConfigs is not supported.&quot;));</span><br><span class=\"line\">    buildTypeContainer.whenObjectRemoved(</span><br><span class=\"line\">            new UnsupportedAction(&quot;Removing build types is not supported.&quot;));</span><br><span class=\"line\">    productFlavorContainer.whenObjectRemoved(</span><br><span class=\"line\">            new UnsupportedAction(&quot;Removing product flavors is not supported.&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 向 BuildType、ProductFlavor、SigningConfig 3个容器创建 default 成员。</span><br><span class=\"line\">    // 大多数 VariantFactory 的实现，在这里创建了 &#x27;debug&#x27; SigningConfig、&#x27;debug&#x27; BuildType、&#x27;release&#x27; BuildType。</span><br><span class=\"line\">    variantFactory.createDefaultComponents(</span><br><span class=\"line\">            buildTypeContainer, productFlavorContainer, signingConfigContainer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BuildType、ProductFlavor、SigningConfig-容器内容构造\"><a href=\"#BuildType、ProductFlavor、SigningConfig-容器内容构造\" class=\"headerlink\" title=\"BuildType、ProductFlavor、SigningConfig 容器内容构造\"></a><code>BuildType</code>、<code>ProductFlavor</code>、<code>SigningConfig</code> 容器内容构造</h4><p>这3个 NamedDomainObjectContainer<T> 类型的容器，在构造时传入 NamedDomainObjectFactory<T> 提供容器内容对象的构造方法。<code>BuildType</code> 和 <code>ProductFlavor</code> 构造方法都直接调用了构造函数，只有 <code>SigningConfig</code> 做了特殊处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SigningConfigFactory implements NamedDomainObjectFactory&lt;SigningConfig&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    public SigningConfig create(@NonNull String name) &#123;</span><br><span class=\"line\">        SigningConfig signingConfig = instantiator.newInstance(SigningConfig.class, name);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果 SigningConfig 对象的名字是 &#x27;debug&#x27;，那么用 android 环境的 debug keystore 来初始化这个对象。</span><br><span class=\"line\">        // debug keystore 存放的位置在 &#x27;&#123;@File androidHomeDir&#125;/debug.keystore&#x27;；</span><br><span class=\"line\">        // debug keystore 配置：store pw -&gt; &#x27;android&#x27;，key alias -&gt; &#x27;AndroidDebugKey&#x27;，key pw -&gt; &#x27;android&#x27;。</span><br><span class=\"line\">        // &#123;@File androidHomeDir&#125; 为 &#x27;&#123;@File homeDir&#125;/.android&#x27; ，&#123;@File homeDir&#125; 按以下优先级寻找, ，没找到就会抛异常：</span><br><span class=\"line\">        // ANDROID_SDK_HOME 环境变量或系统属性 &gt; TEST_TMPDIR 环境变量 &gt; user.home 系统属性 &gt; HOME 环境变量 </span><br><span class=\"line\">        if (BuilderConstants.DEBUG.equals(name)) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                signingConfig.initWith(</span><br><span class=\"line\">                        DefaultSigningConfig.debugSigningConfig(</span><br><span class=\"line\">                                new File(KeystoreHelper.defaultDebugKeystoreLocation())));</span><br><span class=\"line\">            &#125; catch (AndroidLocation.AndroidLocationException e) &#123;</span><br><span class=\"line\">                throw new BuildException(&quot;Failed to get default debug keystore location.&quot;, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return signingConfig;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BuildType、ProductFlavor、SigningConfig-Add-操作监听\"><a href=\"#BuildType、ProductFlavor、SigningConfig-Add-操作监听\" class=\"headerlink\" title=\"BuildType、ProductFlavor、SigningConfig Add 操作监听\"></a><code>BuildType</code>、<code>ProductFlavor</code>、<code>SigningConfig</code> Add 操作监听</h3><p>总体来说，VariantManager 监听了 <code>BuildType</code>、<code>ProductFlavor</code>、<code>SigningConfig</code> 对象的创建操作，并将被创建的对象分别保存在 map 容器中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void configureExtension() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // VariantManager.addSigningConfig() 仅仅将 SigningConfig 对象加入了 VariantManager 的 map 容器持有。</span><br><span class=\"line\">    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里看起来好像用 &#x27;debug&#x27; SigningConfig 初始化了所有 BuildType 对象。</span><br><span class=\"line\">    // 实际上 BuildType.init(SigningConfig) 中有判断，只有 BuildType 的名字也是 &#x27;debug&#x27; 时才会用调用 BuildType.setSigningConfig(SigningConfig)。</span><br><span class=\"line\">    buildTypeContainer.whenObjectAdded(</span><br><span class=\"line\">            buildType -&gt; &#123;</span><br><span class=\"line\">                SigningConfig signingConfig =</span><br><span class=\"line\">                        signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class=\"line\">                buildType.init(signingConfig);</span><br><span class=\"line\">                variantManager.addBuildType(buildType);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class VariantManager implements VariantModel &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // BuildType 对象的加入引发 SourceSet 和 BuildTypeData 对象的创建。</span><br><span class=\"line\">    public void addBuildType(@NonNull CoreBuildType buildType) &#123;</span><br><span class=\"line\">        String name = buildType.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 检查 BuildType 名字的合法性，名字不能以 &#x27;androidTest&#x27; 或 &#x27;test&#x27; 开头；名字不能为 &#x27;lint&#x27;。</span><br><span class=\"line\">        checkName(name, &quot;BuildType&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // BuildType 名字不能和任何 ProductFlavor 相同。</span><br><span class=\"line\">        if (productFlavors.containsKey(name)) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;BuildType names cannot collide with ProductFlavor names&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建和 BuildType 同名的 SourceSet。</span><br><span class=\"line\">        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(name);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test，创建名为 &#x27;&#123;$BuildTypeName&#125;AndroidTest&#x27; 和 &#x27;&#123;$BuildTypeName&#125;UnitTest&#x27; 的 SourceSet。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 BuildTypeData，其持有 BuildType 对象和 3个刚刚创建 SourceSet。</span><br><span class=\"line\">        BuildTypeData buildTypeData =</span><br><span class=\"line\">                new BuildTypeData(</span><br><span class=\"line\">                        buildType, project, mainSourceSet, androidTestSourceSet, unitTestSourceSet);</span><br><span class=\"line\">        buildTypes.put(name, buildTypeData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public void addProductFlavor(@NonNull CoreProductFlavor productFlavor) &#123;</span><br><span class=\"line\">        String name = productFlavor.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 检查 BuildType 名字的合法性，名字不能以 &#x27;androidTest&#x27; 或 &#x27;test&#x27; 开头；名字不能为 &#x27;lint&#x27;。</span><br><span class=\"line\">        checkName(name, &quot;ProductFlavor&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // ProductFlavor 名字不能和任何 BuildType 相同。</span><br><span class=\"line\">        if (buildTypes.containsKey(name)) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;ProductFlavor names cannot collide with BuildType names&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建和 ProductFlavor 同名的 SourceSet。</span><br><span class=\"line\">        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(</span><br><span class=\"line\">                productFlavor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test，创建名为 &#x27;&#123;$BuildTypeName&#125;AndroidTest&#x27; 和 &#x27;&#123;$BuildTypeName&#125;UnitTest&#x27; 的 SourceSet。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 ProductFlavorData，其持有 ProductFlavor 对象和 3个刚刚创建 SourceSet。</span><br><span class=\"line\">        ProductFlavorData&lt;CoreProductFlavor&gt; productFlavorData =</span><br><span class=\"line\">                new ProductFlavorData&lt;&gt;(</span><br><span class=\"line\">                        productFlavor,</span><br><span class=\"line\">                        mainSourceSet,</span><br><span class=\"line\">                        androidTestSourceSet,</span><br><span class=\"line\">                        unitTestSourceSet,</span><br><span class=\"line\">                        project);</span><br><span class=\"line\">        productFlavors.put(productFlavor.getName(), productFlavorData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"BuildTypeData、ProductFlavorData-的创建\"><a href=\"#BuildTypeData、ProductFlavorData-的创建\" class=\"headerlink\" title=\"BuildTypeData、ProductFlavorData 的创建\"></a><code>BuildTypeData</code>、<code>ProductFlavorData</code> 的创建</h4><p>BuildTypeData、ProductFlavorData 的基类均为 VariantDimensionData，在导出类中没有特殊操作，仅仅额外持有了 BuildType 和 ProductFlavor 对象，生成任务树之后会额外持有 {@Task assemble{$BuildType}} 和 {@Task assemble{$ProductFlavor}} 的引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class VariantDimensionData &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private final DefaultAndroidSourceSet sourceSet;</span><br><span class=\"line\">    private final DefaultAndroidSourceSet androidTestSourceSet;</span><br><span class=\"line\">    private final DefaultAndroidSourceSet unitTestSourceSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    public VariantDimensionData(</span><br><span class=\"line\">            @NonNull DefaultAndroidSourceSet sourceSet,</span><br><span class=\"line\">            @Nullable DefaultAndroidSourceSet androidTestSourceSet,</span><br><span class=\"line\">            @Nullable DefaultAndroidSourceSet unitTestSourceSet,</span><br><span class=\"line\">            @NonNull Project project) &#123;</span><br><span class=\"line\">        this.sourceSet = sourceSet;</span><br><span class=\"line\">        this.androidTestSourceSet = androidTestSourceSet;</span><br><span class=\"line\">        this.unitTestSourceSet = unitTestSourceSet;</span><br><span class=\"line\"></span><br><span class=\"line\">        final ConfigurationContainer configurations = project.getConfigurations();</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test </span><br><span class=\"line\">        // 让名为 &#x27;&#123;$VariantDimensionName&#125;AndroidTestImplementation&#x27; 和 &#x27;&#123;$VariantDimensionName&#125;UnitTestImplementation&#x27; 的 Configuration 继承 &#x27;&#123;$VariantDimensionName&#125;Implementation&#x27;</span><br><span class=\"line\">        // 让名为 &#x27;&#123;$VariantDimensionName&#125;AndroidTestRuntimeOnly&#x27; 和 &#x27;&#123;$VariantDimensionName&#125;UnitTestRuntimeOnly&#x27; 的 Configuration 继承 &#x27;&#123;$VariantDimensionName&#125;RuntimeOnly&#x27;</span><br><span class=\"line\">        if (androidTestSourceSet != null) &#123;</span><br><span class=\"line\">            makeTestExtendMain(sourceSet, androidTestSourceSet, configurations);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (unitTestSourceSet != null) &#123;</span><br><span class=\"line\">            makeTestExtendMain(sourceSet, unitTestSourceSet, configurations);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BasePlugin-configureExtension-gt-createExtension\"><a href=\"#BasePlugin-configureExtension-gt-createExtension\" class=\"headerlink\" title=\"BasePlugin::configureExtension() &gt; createExtension()\"></a><code>BasePlugin::configureExtension() &gt; createExtension()</code></h4><p><code>createExtension()</code> 是个抽象函数，不过实际上 BasePlugin 的各个实现类只是构造了不同的 BaseExtension 类的实现，没有在这个方法中做别的事情。<br>各个 BaseExtension 类的实现区别也很小，所以这里只会提到 BaseExtension 和 TestedExtension。</p>\n<p>BaseExtension<br>    -&gt; TestExtension<br>    -&gt; TestedExtension<br>        -&gt; AppExtension<br>        -&gt; LibraryExtension<br>            -&gt; FeatureExtension<br>    -&gt; InstantAppExtension </p>\n<p>在 BaseExtension 的构造函数中：</p>\n<ul>\n<li>完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；</li>\n<li>通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；</li>\n<li>为 android plugin api 对象添加少许默认配置。</li>\n</ul>\n<p><em>创建 Configuration 的过程使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class BaseExtension implements AndroidConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    BaseExtension(</span><br><span class=\"line\">            @NonNull final Project project,</span><br><span class=\"line\">            @NonNull final ProjectOptions projectOptions,</span><br><span class=\"line\">            @NonNull Instantiator instantiator,</span><br><span class=\"line\">            @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">            @NonNull SdkHandler sdkHandler,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypes,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavors,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigs,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">            @NonNull ExtraModelInfo extraModelInfo,</span><br><span class=\"line\">            final boolean publishPackage) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Simplify 保存构造函数传入的参数。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        logger = Logging.getLogger(this.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 DefaultConfig 对象，DefaultConfig 对象是一个名为 &#x27;main&#x27; 的特殊的 ProductFlavor，DefaultConfig 和 ProductFlavor 有共同的父类。</span><br><span class=\"line\">        defaultConfig =</span><br><span class=\"line\">                instantiator.newInstance(</span><br><span class=\"line\">                        DefaultConfig.class,</span><br><span class=\"line\">                        BuilderConstants.MAIN,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        instantiator,</span><br><span class=\"line\">                        project.getLogger(),</span><br><span class=\"line\">                        extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Simplify 创建各种 Options 类型对象，都用于描述 android plugin api 并承载编译脚本配置。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 SourceSet 容器，容器中的使用 DefaultAndroidSourceSet 类构造。</span><br><span class=\"line\">        sourceSetsContainer =</span><br><span class=\"line\">                project.container(</span><br><span class=\"line\">                        AndroidSourceSet.class,</span><br><span class=\"line\">                        new AndroidSourceSetFactory(instantiator, project, publishPackage));</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        // 监听 SourceSet 容器的 Add 操作。</span><br><span class=\"line\">        // 当有新的 SoucreSet 加入容器之后，初始化 SourceSet 的默认布局，建与之相对应的 Configuration，设置被创建的 Configuration 之间的 extendsFrom 关系。</span><br><span class=\"line\">        // 这是段较长的 labor 代码，改为用伪代码分析</span><br><span class=\"line\">        sourceSetsContainer.whenObjectAdded() &#123;</span><br><span class=\"line\">            // @Pseudocode</span><br><span class=\"line\">            sourceSet -&gt; &#123;</span><br><span class=\"line\">                ConfigurationContainer configurations = project.getConfigurations();</span><br><span class=\"line\"></span><br><span class=\"line\">                String sourceSetName = sourceSet.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">                // 创建名为 &#x27;&#123;SouceSetName&#125;Api&#x27;、&#x27;&#123;SouceSetName&#125;Implementation&#x27;、</span><br><span class=\"line\">                // &#x27;&#123;SouceSetName&#125;RuntimeOnly&#x27;、&#x27;&#123;SouceSetName&#125;CompileOnly&#x27; 的 SourceSet。</span><br><span class=\"line\">                // 创建名为 &#x27;&#123;SouceSetName&#125;Compile&#x27;、&#x27;&#123;SouceSetName&#125;Provided&#x27; 的 SourceSet。</span><br><span class=\"line\">                // 在 App 工程中创建 &#x27;&#123;SouceSetName&#125;Apk&#x27;；在 Lib 工程中创建 &#x27;&#123;SouceSetName&#125;Publish&#x27;。</span><br><span class=\"line\">                // 对于名为 &#x27;main&#x27; 的 sourceSet 而言，创建 Configuration 的命名规则特殊处理，不加前缀。</span><br><span class=\"line\">                Configuration compile = createConfiguration(configurations, sourceSetName + &#x27;Compile&#x27;);</span><br><span class=\"line\">                if (&#123;in AppExtension&#125;) &#123;</span><br><span class=\"line\">                    Configuration apk = createConfiguration(configurations, sourceSetName + &#x27;Apk&#x27;);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    Configuration apk = createConfiguration(configurations, sourceSetName + &#x27;Publish&#x27;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Configuration provided = createConfiguration(configurations, sourceSetName + &#x27;Provided&#x27;);</span><br><span class=\"line\">                Configuration api = createConfiguration(configurations, sourceSetName + &#x27;Api&#x27;);</span><br><span class=\"line\">                Configuration implementation = createConfiguration(configurations, sourceSetName + &#x27;Implementation&#x27;);</span><br><span class=\"line\">                Configuration runtimeOnly = createConfiguration(configurations, sourceSetName + &#x27;RuntimeOnly&#x27;);</span><br><span class=\"line\">                Configuration compileOnly = createConfiguration(configurations, sourceSetName + &#x27;CompileOnly&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">                // compile、apk、provided 3个 Configuration 属于 Depercated 设定。</span><br><span class=\"line\">                // 当这3个 Configuration 有任何 dependency 增加时输出 warning。</span><br><span class=\"line\">                compile.getAllDependencies().whenObjectAdded(</span><br><span class=\"line\">                    new DeprecatedConfigurationAction());</span><br><span class=\"line\">                apk.getAllDependencies().whenObjectAdded(</span><br><span class=\"line\">                    new DeprecatedConfigurationAction());</span><br><span class=\"line\">                provided.getAllDependencies().whenObjectAdded(</span><br><span class=\"line\">                    new DeprecatedConfigurationAction());</span><br><span class=\"line\"></span><br><span class=\"line\">                // 设置 extendsFrom 关系。</span><br><span class=\"line\">                api.extendsFrom(compile);</span><br><span class=\"line\">                implementation.extendsFrom(api);</span><br><span class=\"line\">                runtimeOnly.extendsFrom(apk);</span><br><span class=\"line\">                compileOnly.extendsFrom(provided);</span><br><span class=\"line\"></span><br><span class=\"line\">                // @Wear 创建名为 &#x27;&#123;SouceSetName&#125;WearApp&#x27; 的 Configuration。</span><br><span class=\"line\">                [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                // &#x27;&#123;SouceSetName&#125;AnnotationProcessor&#x27; 的 Configuration。</span><br><span class=\"line\">                // 用于做 apt。</span><br><span class=\"line\">                createConfiguration(configurations, sourceSetName + &#x27;AnnotationProcessor&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">                // 设置 sourceSet 的默认布局：</span><br><span class=\"line\">                // java -&gt; &#x27;src/&#123;SouceSetName&#125;/java&#x27;</span><br><span class=\"line\">                // javaResources -&gt; &#x27;src/&#123;SouceSetName&#125;/resources&#x27;</span><br><span class=\"line\">                // res -&gt; &#x27;src/&#123;SouceSetName&#125;/res&#x27;</span><br><span class=\"line\">                // assets -&gt; &#x27;src/&#123;SouceSetName&#125;/assets&#x27;</span><br><span class=\"line\">                // manifest -&gt; &#x27;src/&#123;SouceSetName&#125;/AndroidManifest.xml&#x27;</span><br><span class=\"line\">                // aidl -&gt; &#x27;src/&#123;SouceSetName&#125;/aidl&#x27;</span><br><span class=\"line\">                // renderscript -&gt; &#x27;src/&#123;SouceSetName&#125;/rs&#x27;</span><br><span class=\"line\">                // jni -&gt; &#x27;src/&#123;SouceSetName&#125;/jni&#x27;</span><br><span class=\"line\">                // jniLibs -&gt; &#x27;src/&#123;SouceSetName&#125;/jniLibs&#x27;</span><br><span class=\"line\">                // shaders -&gt; &#x27;src/&#123;SouceSetName&#125;/shaders&#x27;</span><br><span class=\"line\">                sourceSet.setRoot(String.format(&quot;src/%s&quot;, sourceSet.getName()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test 创建名为 &#x27;androidTestUtil&#x27; 的 Configuration</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 创建名为 &#x27;main&#x27; 的 SourceSet。</span><br><span class=\"line\">        sourceSetsContainer.create(defaultConfig.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 设置一些默认的编译脚本配置。</span><br><span class=\"line\">        // 设置默认的 buildTools Revision，如果开发者没有在编译脚本中指定，就使用默认版本。不同版本的 android plugin 定一个默认 buildTools 版本不同。</span><br><span class=\"line\">        buildToolsRevision = AndroidBuilder.DEFAULT_BUILD_TOOLS_REVISION;</span><br><span class=\"line\">        // 这个函数会对 DefaultConfig 对象做一些有关矢量图的配置。 </span><br><span class=\"line\">        setDefaultConfigValues();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 TestedExtension 的构造函数中创建了名为 ‘androidTest’ 和 ‘test’ 的 SourceSet，与 ‘main’ SourceSet 对应是默认存在基础 SourceSet。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// TestedExtension 是 AppExtension、LibraryExtension、FeatureExtension 的父类。</span><br><span class=\"line\">public abstract class TestedExtension extends BaseExtension implements TestedAndroidConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public TestedExtension(</span><br><span class=\"line\">            @NonNull Project project,</span><br><span class=\"line\">            @NonNull ProjectOptions projectOptions,</span><br><span class=\"line\">            @NonNull Instantiator instantiator,</span><br><span class=\"line\">            @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">            @NonNull SdkHandler sdkHandler,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypes,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavors,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigs,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">            @NonNull ExtraModelInfo extraModelInfo,</span><br><span class=\"line\">            boolean isDependency) &#123;</span><br><span class=\"line\">        super(</span><br><span class=\"line\">                project,</span><br><span class=\"line\">                projectOptions,</span><br><span class=\"line\">                instantiator,</span><br><span class=\"line\">                androidBuilder,</span><br><span class=\"line\">                sdkHandler,</span><br><span class=\"line\">                buildTypes,</span><br><span class=\"line\">                productFlavors,</span><br><span class=\"line\">                signingConfigs,</span><br><span class=\"line\">                buildOutputs,</span><br><span class=\"line\">                extraModelInfo,</span><br><span class=\"line\">                isDependency);</span><br><span class=\"line\">        // 创建名为 &#x27;androidTest&#x27; 和 &#x27;test&#x27; 的 SourceSet。</span><br><span class=\"line\">        getSourceSets().create(ANDROID_TEST.getPrefix());</span><br><span class=\"line\">        getSourceSets().create(UNIT_TEST.getPrefix());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造-TaskManager、VariantManager、VariantFactory\"><a href=\"#构造-TaskManager、VariantManager、VariantFactory\" class=\"headerlink\" title=\"构造 TaskManager、VariantManager、VariantFactory\"></a>构造 <code>TaskManager</code>、<code>VariantManager</code>、<code>VariantFactory</code></h4><p>TaskManager 通过 <code>createTaskManager()</code> 方法创建，VariantFactory 通过 <code>createVariantFactory</code> 方法创建。这两个方法均为抽象方法，在各种 plugin 的实现中，仅仅是调用了各种 TaskManager 和 VariantFactory 实现的构造函数，并无额外的代码。</p>\n<p>VariantManager 的构造函数中针对 DebugConfig 对象(DebugConfig 对象在 BaseExtension 构造时被创建)做了一些处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class VariantManager implements VariantModel &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public VariantManager(</span><br><span class=\"line\">            @NonNull GlobalScope globalScope,</span><br><span class=\"line\">            @NonNull Project project,</span><br><span class=\"line\">            @NonNull ProjectOptions projectOptions,</span><br><span class=\"line\">            @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">            @NonNull AndroidConfig extension,</span><br><span class=\"line\">            @NonNull VariantFactory variantFactory,</span><br><span class=\"line\">            @NonNull TaskManager taskManager,</span><br><span class=\"line\">            @NonNull Recorder recorder) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        DefaultAndroidSourceSet mainSourceSet =</span><br><span class=\"line\">                (DefaultAndroidSourceSet) extension.getSourceSets().getByName(extension.getDefaultConfig().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        DefaultAndroidSourceSet androidTestSourceSet = null;</span><br><span class=\"line\">        DefaultAndroidSourceSet unitTestSourceSet = null;</span><br><span class=\"line\">        if (variantFactory.hasTestScope()) &#123;</span><br><span class=\"line\">            androidTestSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) extension.getSourceSets()</span><br><span class=\"line\">                            .getByName(ANDROID_TEST.getPrefix());</span><br><span class=\"line\">            unitTestSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) extension.getSourceSets()</span><br><span class=\"line\">                            .getByName(UNIT_TEST.getPrefix());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 使用 DebugConfig 对象，&#x27;main&#x27;、&#x27;androidTest&#x27;、&#x27;test&#x27; 3个 SourceSet，</span><br><span class=\"line\">        // 创建了 defaultConfigData 对象。</span><br><span class=\"line\">        // &#x27;main&#x27;、&#x27;androidTest&#x27;、&#x27;test&#x27; 3个 SourceSet 都是在 extension 中直接创建的，而不是由 BuildType 或 ProductFlavor 触发生成的。</span><br><span class=\"line\">        // 正如 DebugConfig 对象是一个特殊的 ProductFlavor，defaultConfigData 引用也持有了一个特殊的 ProductFlavorData。</span><br><span class=\"line\"></span><br><span class=\"line\">        this.defaultConfigData =</span><br><span class=\"line\">                new ProductFlavorData&lt;&gt;(</span><br><span class=\"line\">                        extension.getDefaultConfig(),</span><br><span class=\"line\">                        mainSourceSet,</span><br><span class=\"line\">                        androidTestSourceSet,</span><br><span class=\"line\">                        unitTestSourceSet,</span><br><span class=\"line\">                        project);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"BasePlugin-apply-gt-createTasks\"><a href=\"#BasePlugin-apply-gt-createTasks\" class=\"headerlink\" title=\"BasePlugin::apply() &gt; createTasks()\"></a>BasePlugin::apply() &gt; createTasks()</h3><p>运行到这里时，创建管理类、监听链建立、设置默认配置布局这些工作都完成了，终于要创建 gradle task 了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void createTasks() &#123;</span><br><span class=\"line\">    taskManager.createTasksBeforeEvaluate(</span><br><span class=\"line\">        new TaskContainerAdaptor(project.getTasks())));</span><br><span class=\"line\"></span><br><span class=\"line\">    project.afterEvaluate(</span><br><span class=\"line\">        project -&gt;</span><br><span class=\"line\">            () -&gt; createAndroidTasks(false);</span><br></pre></td></tr></table></figure>\n<p><code>createTasks()</code> 将创建 gradle task 的工作分为两部分，一部分在 evaluate 开始之前，用于创建不构建脚本配置影响的任务；另一部分在 evaluate 结束之后，这部分创建那些的任务取决于构建脚本配置。</p>\n<h4 id=\"TaskManager-createTasksBeforeEvaluate\"><a href=\"#TaskManager-createTasksBeforeEvaluate\" class=\"headerlink\" title=\"TaskManager::createTasksBeforeEvaluate()\"></a><code>TaskManager::createTasksBeforeEvaluate()</code></h4><p>TaskManager 的绝大部分实没有扩展 <code>createTasksBeforeEvaluate()</code> (只有 InstantAppTaskManager 创建了多创建了一个 gradle task)，所以对于各类 android plugin 在这里创建的任务都是相同的。</p>\n<p>在这个方法中创建了一些 Anchor 任务（没有实际内容，仅作为上游节点使用），和一些独立任务例如和 Lint 和 单元测试相关的任务。</p>\n<p><em>下面代码使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TaskManager &#123;</span><br><span class=\"line\">    public void createTasksBeforeEvaluate(@NonNull TaskFactory tasks) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;uninstallAll&quot; task as anchor task. </span><br><span class=\"line\">            it &quot;Uninstall all applications.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;deviceCheck&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Runs all device checks using Device Providers and Test Servers.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;connectedCheck&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Runs all device checks on currently connected devices.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;preBuild&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Lead all build tasks.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;extractProguardFiles&quot; task as ExtractProguardFiles.class type.</span><br><span class=\"line\">            let &quot;extractProguardFiles&quot; dependsOn &quot;preBuild&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;sourceSets&quot; task as SourceSetsTask.class type.</span><br><span class=\"line\">            it &quot;Prints out all the source sets defined in this project.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;assembleAndroidTest&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Assembles all the Test applications.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;compileLint&quot; task as LintCompile.class type.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;lint&quot; task as LintGlobalTask.class type.</span><br><span class=\"line\">            it &quot;Runs lint on all variants.&quot;</span><br><span class=\"line\">            let &quot;check&quot; task (which from java plugin) dependsOn &quot;lint&quot; task.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;lintChecks&quot; configuration.</span><br><span class=\"line\">            it &quot;Configuration to apply external lint check jar&quot;</span><br><span class=\"line\">            GlobalScope will hold &quot;lintChecks&quot; configuration</span><br><span class=\"line\"></span><br><span class=\"line\">        if (&#123;@Field buildCache&#125; is not null) &#123;</span><br><span class=\"line\">            create &quot;cleanBuildCache&quot; task as CleanBuildCache.class type.</span><br><span class=\"line\">                it &quot;Deletes the build cache directory.&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;resolveConfigAttr&quot; task as ConfigAttrTask.class type.</span><br><span class=\"line\">            set resolveConfigAttr.resolvable = true</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;consumeConfigAttr&quot; task as ConfigAttrTask.class type.</span><br><span class=\"line\">            set consumeConfigAttr.consumable true.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BasePlugin-createAndroidTasks\"><a href=\"#BasePlugin-createAndroidTasks\" class=\"headerlink\" title=\"BasePlugin::createAndroidTasks()\"></a><code>BasePlugin::createAndroidTasks()</code></h4><p><code>BasePlugin::createAndroidTasks()</code> 是创建 BuildVariant 和 Android 编译 task 的主流程，其中包含了一些检查和准备工作，创建 task 的代码主要包含在 <code>VariantManager::createAndroidTasks</code> 中。</p>\n<p>在这里主要做完成完成了：</p>\n<ul>\n<li>加载 Android Sdk 信息和添加 Android Sdk 提供的 Maven Repo</li>\n<li>创建 lint 相关的全局 task</li>\n<li>基于编译脚本输入创建 VariantData 对象</li>\n<li>基于 VariantData 信息创建编译 task</li>\n<li>完成 Variant 对象的创建。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void createAndroidTasks(boolean force) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // @Simplify</span><br><span class=\"line\">    // 确保 buildToolsVersion 和 compileSdkVersion 被设置了。</span><br><span class=\"line\">    // 确保 JavaPlugin.class 没有被 apply 过。</span><br><span class=\"line\">    [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化 Android SDK Target 信息。 </span><br><span class=\"line\">    ensureTargetSetup();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (hasCreatedTasks) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hasCreatedTasks = true;</span><br><span class=\"line\">    // 禁止再修改 Extension 对象，编译脚本配置到此截止。</span><br><span class=\"line\">    extension.disableWrite();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 PrepareLintJar.class 类型的 &quot;prepareLintJar&quot; 任务。</span><br><span class=\"line\">    taskManager.configureCustomLintChecks(new TaskContainerAdaptor(project.getTasks()));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将 Android SDK 包含的 Repositories 加入的 Maven Repo 中，并将这些 Repositories 调整到 Maven Repo 列表的最前面。</span><br><span class=\"line\">    sdkHandler.addLocalRepositories(project);</span><br><span class=\"line\"></span><br><span class=\"line\">    // @DataBinding，如果使用了 DataBinding，则向已有 configuration 添加一些依赖。</span><br><span class=\"line\">    [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 VariantData 对象和编译 Task。</span><br><span class=\"line\">    variantManager.createAndroidTasks();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 依照 VariantData 对象，创建 Variant 对象。</span><br><span class=\"line\">    ApiObjectFactory apiObjectFactory =</span><br><span class=\"line\">            new ApiObjectFactory(</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    variantFactory,</span><br><span class=\"line\">                    instantiator,</span><br><span class=\"line\">                    project.getObjects());</span><br><span class=\"line\">    for (VariantScope variantScope : variantManager.getVariantScopes()) &#123;</span><br><span class=\"line\">        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">        apiObjectFactory.create(variantData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 在 Variant 对象创建完成之后，创建全局 &quot;lint&quot; Task。</span><br><span class=\"line\">    taskManager.configureGlobalLintTask(variantManager.getVariantScopes());</span><br><span class=\"line\"></span><br><span class=\"line\">    // @IDE</span><br><span class=\"line\">    [+]&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureTargetSetup() &#123;    </span><br><span class=\"line\">    TargetInfo targetInfo = androidBuilder.getTargetInfo();</span><br><span class=\"line\">    if (targetInfo == null) &#123;</span><br><span class=\"line\">        if (extension.getCompileOptions() == null) &#123;</span><br><span class=\"line\">            throw new GradleException(&quot;Calling getBootClasspath before compileSdkVersion&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 Android SDK Target 信息，并将其设置到 androidBuiler 中。</span><br><span class=\"line\">        sdkHandler.initTarget(</span><br><span class=\"line\">                extension.getCompileSdkVersion(),</span><br><span class=\"line\">                extension.getBuildToolsRevision(),</span><br><span class=\"line\">                extension.getLibraryRequests(),</span><br><span class=\"line\">                androidBuilder,</span><br><span class=\"line\">                SdkHandler.useCachedSdk(projectOptions));</span><br><span class=\"line\">        // 确保 Android SDK 中没有安装了 platform tools，如果没有就下载它。</span><br><span class=\"line\">        sdkHandler.ensurePlatformToolsIsInstalled(extraModelInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SdkHandler::initTarget()</code> 中通过 SdkLoader 对象加载 Android Sdk 中的各种工具路径。<br>SdkLoader 的不同实现对应不同的 Android Sdk 文件布局，通常使用 <code>DefaultSdkLoader</code> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SdkHandler &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">     public void initTarget(</span><br><span class=\"line\">                @NonNull String targetHash,</span><br><span class=\"line\">                @NonNull Revision buildToolRevision,</span><br><span class=\"line\">                @NonNull Collection&lt;LibraryRequest&gt; usedLibraries,</span><br><span class=\"line\">                @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">                boolean useCachedVersion) &#123;</span><br><span class=\"line\">            //检查targetHash和buildToolRevision不为空，否则抛异常。</span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">            // 通过getSdkLoader()创建SdkLoader对象</span><br><span class=\"line\">            // 如果useCachedVersion &amp;&amp; sSdkLoader，那么重用旧的SdkLoader。</span><br><span class=\"line\">            synchronized (LOCK_FOR_SDK_HANDLER) &#123;</span><br><span class=\"line\">                if (useCachedVersion &amp;&amp; sSdkLoader == null) &#123;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    sSdkLoader = getSdkLoader();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sdkLoader = sSdkLoader;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 通过SdkLoader -&gt; AndroidSdkHandler获得SdkInfo.</span><br><span class=\"line\">            // SdkInfo包含annotations.jar和adb执行文件的位置。</span><br><span class=\"line\">            // annotations.jar位置：$&#123;sdkLocation&#125;/tools/support/annotations.jar</span><br><span class=\"line\">            // adb文件位置：$&#123;sdkLocation&#125;/platform-tools/adb</span><br><span class=\"line\">            SdkInfo sdkInfo = sdkLoader.getSdkInfo(logger);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 通过SdkLoader -&gt; AndroidSdkHandler获得TargetInfo</span><br><span class=\"line\">            // TargetInfo包括IAndroidTarget(包装target信息),BuildToolInfo(包装build-tools信息)。</span><br><span class=\"line\">            TargetInfo targetInfo = sdkLoader.getTargetInfo(</span><br><span class=\"line\">                    targetHash,</span><br><span class=\"line\">                    buildToolRevision,</span><br><span class=\"line\">                    logger,</span><br><span class=\"line\">                    sdkLibData);</span><br><span class=\"line\"></span><br><span class=\"line\">            androidBuilder.setSdkInfo(sdkInfo);</span><br><span class=\"line\">            androidBuilder.setTargetInfo(targetInfo);</span><br><span class=\"line\">            androidBuilder.setLibraryRequests(usedLibraries);</span><br><span class=\"line\"></span><br><span class=\"line\">            // Check if platform-tools are installed. We check here because realistically, all projects</span><br><span class=\"line\">            // should have platform-tools in order to build.</span><br><span class=\"line\">            ProgressIndicator progress = new ConsoleProgressIndicator();</span><br><span class=\"line\">            AndroidSdkHandler sdk = AndroidSdkHandler.getInstance(getSdkFolder());</span><br><span class=\"line\">            LocalPackage platformToolsPackage =</span><br><span class=\"line\">                    sdk.getLatestLocalPackageForPrefix(SdkConstants.FD_PLATFORM_TOOLS, true, progress);</span><br><span class=\"line\">            if (platformToolsPackage == null) &#123;</span><br><span class=\"line\">                //如果sdkLibData.useSdkDownload()就尝试下载；否则什么都不做。</span><br><span class=\"line\">                sdkLoader.installSdkTool(sdkLibData, SdkConstants.FD_PLATFORM_TOOLS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// <code>configureCustomLintChecks</code> 和 <code>configureGlobalLintTask</code> 这两个方法都跟 Lint 任务创建相关，一个在创建 Variant 对象之前调用，一个在其后调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // &quot;prepareLintJar&quot; 任务，这个任务会将 &#123;@File lint.jar&#125; 拷贝到 &#123;@File build/intermediates/lint/lint.jar&#125;。</span><br><span class=\"line\">    public void configureCustomLintChecks(@NonNull TaskFactory tasks) &#123;</span><br><span class=\"line\">        File lintJar = FileUtils.join(globalScope.getIntermediatesDir(), &quot;lint&quot;, FN_LINT_JAR);</span><br><span class=\"line\"></span><br><span class=\"line\">        AndroidTask&lt;PrepareLintJar&gt; copyLintTask =</span><br><span class=\"line\">        getAndroidTasks()</span><br><span class=\"line\">                .create(tasks, new PrepareLintJar.ConfigAction(globalScope, lintJar));</span><br><span class=\"line\">        globalScope.addTaskOutput(LINT_JAR, lintJar, copyLintTask.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void configureGlobalLintTask(@NonNull final Collection&lt;VariantScope&gt; variants) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 筛选 &#x27;non testing&#x27; &amp;&amp; &#x27;non feature&#x27; 的 BuildVariant。</span><br><span class=\"line\">        List&lt;VariantScope&gt; filteredVariants =</span><br><span class=\"line\">                variants.stream().filter(TaskManager::isLintVariant).collect(Collectors.toList());</span><br><span class=\"line\">        if (filteredVariants.isEmpty()) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建全局的 &#x27;lint&#x27; 任务。</span><br><span class=\"line\">        androidTasks.configure(</span><br><span class=\"line\">                tasks, new LintGlobalTask.GlobalConfigAction(globalScope, filteredVariants));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将 &#x27;lint.jar&#x27; 文件加入每个 BuildVariant 的输出文件集中。</span><br><span class=\"line\">        FileCollection lintJarCollection = globalScope.getOutput(LINT_JAR);</span><br><span class=\"line\">        File lintJar = lintJarCollection.getSingleFile();</span><br><span class=\"line\">        for (VariantScope scope : variants) &#123;</span><br><span class=\"line\">            scope.addTaskOutput(LINT_JAR, lintJar, PrepareLintJar.NAME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>VariantManager::createAndroidTasks()</code> 中：</p>\n<ul>\n<li><code>populateVariantDataList()</code> 创建 VariantData 对象。</li>\n<li><code>TaskManager::createTopLevelTestTasks</code> 创建一些和单元测试有关的顶层 task。</li>\n<li><code>createTasksForVariantData()</code> 创建编译相关的所有 task。</li>\n<li><code>TaskManager::createReportTasks</code> 创建输出信息的工具 task。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createAndroidTasks() &#123;</span><br><span class=\"line\">        // 这是一个抽象方法，只有在 LibraryVariantFactory 中有实现。</span><br><span class=\"line\">        // LibraryVariantFactory 的实现中，确保 BuildType 和 ProductFlavor 没有配置</span><br><span class=\"line\">        // applicationId 或 applicationIdSuffix。</span><br><span class=\"line\">        variantFactory.validateModel(this);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这又是一个抽象方法，在 BaseVariantFactory 的实现中检查，</span><br><span class=\"line\">        // 如果使用了 &#x27;android-apt&#x27; 插件，则提示开发者使用更新的 &#x27;annotationProcessor&#x27; 配置。</span><br><span class=\"line\">        variantFactory.preVariantWork(project);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 VariantData 对象。</span><br><span class=\"line\">        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());</span><br><span class=\"line\">        if (variantScopes.isEmpty()) &#123;</span><br><span class=\"line\">            populateVariantDataList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //@Test, 创建一些和单元测试有关的顶层 task。</span><br><span class=\"line\">        taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建基于 BuildVariant 的编译 task。</span><br><span class=\"line\">        for (final VariantScope variantScope : variantScopes) &#123;</span><br><span class=\"line\">            createTasksForVariantData(tasks, variantScope)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一些输出信息的 task。</span><br><span class=\"line\">        taskManager.createReportTasks(tasks, variantScopes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createReportTasks(TaskFactory tasks, final List&lt;VariantScope&gt; variantScopes) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        create &quot;androidDependencies&quot; as DependencyReportTask type.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;signingReport&quot; as SigningReportTask type.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建-VariantData-对象\"><a href=\"#创建-VariantData-对象\" class=\"headerlink\" title=\"创建 VariantData 对象\"></a>创建 VariantData 对象</h4><p><code>VariantManager::populateVariantDataList()</code> 依赖开发者编译脚本的配置，生成全部 VariantData 对象，进一步完成 project 模型的搭建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void populateVariantDataList() &#123;</span><br><span class=\"line\">        List&lt;String&gt; flavorDimensionList = extension.getFlavorDimensionList();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (productFlavors.isEmpty()) &#123;</span><br><span class=\"line\">            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。</span><br><span class=\"line\">            configureDependencies();</span><br><span class=\"line\">            // 如果没有配置任何 ProductFlavor，使用空参数直接构造 VariantData 对象。</span><br><span class=\"line\">            createVariantDataForProductFlavors(Collections.emptyList());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 如果配置了 ProductFlavor，检查配置合法性，并根据配置构造 VariantData 对象。</span><br><span class=\"line\">            // 确保每个 ProductFlavor 都有 Dimension</span><br><span class=\"line\">            if (flavorDimensionList == null || flavorDimensionList.isEmpty()) &#123;</span><br><span class=\"line\">                // @Simplify 从 Android Gradle 3.0 之后，所有的 ProductFlavor 都需要有 Dimension</span><br><span class=\"line\">                // 参见：https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125; else if (flavorDimensionList.size() == 1) &#123;</span><br><span class=\"line\">                // @Simplify 如果仅有一个 Dimension，将每个没有配置 Dimension 的 ProductFlavor 设为这个唯一的 Dimension。</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。</span><br><span class=\"line\">            configureDependencies();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 下面这两个调用生成了 flavorComboList，</span><br><span class=\"line\">            // 这个列表中的每个元素代表了一种 ProductFlavor 的组合方式</span><br><span class=\"line\">            // (按照 Dimension 从高到低的方式)</span><br><span class=\"line\">            Iterable&lt;CoreProductFlavor&gt; flavorDsl =</span><br><span class=\"line\">                    Iterables.transform(</span><br><span class=\"line\">                            productFlavors.values(),</span><br><span class=\"line\">                            ProductFlavorData::getProductFlavor);</span><br><span class=\"line\">            List&lt;ProductFlavorCombo&lt;CoreProductFlavor&gt;&gt; flavorComboList =</span><br><span class=\"line\">                    ProductFlavorCombo.createCombinations(</span><br><span class=\"line\">                            flavorDimensionList,</span><br><span class=\"line\">                            flavorDsl);</span><br><span class=\"line\">            // 以每一种 ProductFlavor 组合为输入，构造 VariantData 对象。</span><br><span class=\"line\">            for (ProductFlavorCombo&lt;CoreProductFlavor&gt;  flavorCombo : flavorComboList) &#123;</span><br><span class=\"line\">                createVariantDataForProductFlavors(</span><br><span class=\"line\">                        (List&lt;ProductFlavor&gt;) (List) flavorCombo.getFlavorList());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private void createVariantDataForProductFlavors(</span><br><span class=\"line\">            @NonNull List&lt;ProductFlavor&gt; productFlavorList) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // getVariantConfigurationTypes() 是一个抽象方法，通常情况下只会返回长度为1的列表。</span><br><span class=\"line\">        // 例如 ApplicationVariantFactory 会返回 VariantType.DEFAULT;</span><br><span class=\"line\">        // LibraryVariantFactory 会返回 VariantType.LIBRARY;</span><br><span class=\"line\">        // 这里实际上就是将 VariantType 加入构造 VariantData 的参数。</span><br><span class=\"line\">        for (VariantType variantType : variantFactory.getVariantConfigurationTypes()) &#123;</span><br><span class=\"line\">            createVariantDataForProductFlavorsAndVariantType(productFlavorList, variantType);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void createVariantDataForProductFlavorsAndVariantType(</span><br><span class=\"line\">            @NonNull List&lt;ProductFlavor&gt; productFlavorList, @NonNull VariantType variantType) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test, 在工程支持单元测试的情况下，获取单元测试的目标 BuildTypeData</span><br><span class=\"line\">        // 默认情况下单元测试的目标 BuildType 是 &#x27;debug&#x27;</span><br><span class=\"line\">        BuildTypeData testBuildTypeData = null;</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        BaseVariantData variantForAndroidTest = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        CoreProductFlavor defaultConfig = defaultConfigData.getProductFlavor();</span><br><span class=\"line\"></span><br><span class=\"line\">        Action&lt;com.android.build.api.variant.VariantFilter&gt; variantFilterAction =</span><br><span class=\"line\">                extension.getVariantFilter();</span><br><span class=\"line\"></span><br><span class=\"line\">        // @IDE</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (BuildTypeData buildTypeData : buildTypes.values()) &#123;</span><br><span class=\"line\">            boolean ignore = false;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 检查编译脚本中的 VariantFilter 配置，</span><br><span class=\"line\">            // 以确认当前的 BuildType &amp; ProductFlavor 组合是否要被忽略。</span><br><span class=\"line\">            if (variantFilterAction != null) &#123;</span><br><span class=\"line\">                variantFilter.reset(</span><br><span class=\"line\">                        defaultConfig,</span><br><span class=\"line\">                        buildTypeData.getBuildType(),</span><br><span class=\"line\">                        variantType,</span><br><span class=\"line\">                        productFlavorList);</span><br><span class=\"line\"></span><br><span class=\"line\">                variantFilterAction.execute(variantFilter);</span><br><span class=\"line\">                ignore = variantFilter.isIgnore();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (!ignore) &#123;</span><br><span class=\"line\">                // 通过 BuildType &amp; ProductFlavor 组合 创建 VariantData 对象。 </span><br><span class=\"line\">                BaseVariantData variantData =</span><br><span class=\"line\">                        createVariantDataForVariantType(</span><br><span class=\"line\">                                buildTypeData.getBuildType(),</span><br><span class=\"line\">                                productFlavorList,</span><br><span class=\"line\">                                variantType,</span><br><span class=\"line\">                                false);</span><br><span class=\"line\">                // 将 VariantScope 对象保存在 variantScopes 中。</span><br><span class=\"line\">                // VariantScope 对象和 VariantData 对象是一一对应、相互持有的关系。</span><br><span class=\"line\">                addVariant(variantData);</span><br><span class=\"line\"></span><br><span class=\"line\">                // @Simplify</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                if (variantFactory.hasTestScope()) &#123;</span><br><span class=\"line\">                    if (buildTypeData == testBuildTypeData) &#123;</span><br><span class=\"line\">                        variantForAndroidTest = variantData;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    // @Test, 创建单元测试的 VariantData 对象。</span><br><span class=\"line\">                    [+]&#123;...&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (variantForAndroidTest != null) &#123;</span><br><span class=\"line\">            //@Test, 创建单 AndroidTest 的 VariantData 对象。</span><br><span class=\"line\">            [+]&#123;...&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通过 BuildType &amp; ProductFlavor 组合 创建 VariantData 对象。 </span><br><span class=\"line\">    private BaseVariantData createVariantDataForVariantType(</span><br><span class=\"line\">            @NonNull com.android.builder.model.BuildType buildType,</span><br><span class=\"line\">            @NonNull List&lt;? extends ProductFlavor&gt; productFlavorList,</span><br><span class=\"line\">            @NonNull VariantType variantType,</span><br><span class=\"line\">            boolean componentPluginUsed) &#123;</span><br><span class=\"line\">        BuildTypeData buildTypeData = buildTypes.get(buildType.getName());</span><br><span class=\"line\">        final DefaultAndroidSourceSet sourceSet = defaultConfigData.getSourceSet();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 以 DefaultConfig 和 buildType 为基础创建 VariantConfiguration 对象，</span><br><span class=\"line\">        // 这个对象代表了 BuildType &amp; ProductFlavor 组合的配置，并且会将脚本中的的配置进行合并，确定最终的配置。</span><br><span class=\"line\">        GradleVariantConfiguration variantConfig =</span><br><span class=\"line\">            GradleVariantConfiguration.getBuilderForExtension(extension)</span><br><span class=\"line\">                .create(</span><br><span class=\"line\">                    globalScope.getProjectOptions(),</span><br><span class=\"line\">                    defaultConfigData.getProductFlavor(),</span><br><span class=\"line\">                    sourceSet,</span><br><span class=\"line\">                    getParser(sourceSet.getManifestFile()),</span><br><span class=\"line\">                    buildTypeData.getBuildType(),</span><br><span class=\"line\">                    buildTypeData.getSourceSet(),</span><br><span class=\"line\">                    variantType,</span><br><span class=\"line\">                    signingOverride);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Simplify</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 依次将 ProductFlavor 对象加入 VariantConfiguration 对象，每次加入操作都会进行配置合并，保存在 &#x27;mergedFlavor&#x27; 中。</span><br><span class=\"line\">        // 合并时大部分属性会进行覆盖，高维 ProductFlavor &gt; 低维 ProductFlavor &gt; DefaultConfig。</span><br><span class=\"line\">        // 但是 applicationIdSuffix 和 versionNameSuffix 两个配置会将各个维度与 DefaultConfig 拼接到一起。</span><br><span class=\"line\">        // 此外 JavaCompileOptions、NdkOptions 等 Options 会进行覆盖合并，BuildType &gt; 高维 ProductFlavor &gt; 低维 ProductFlavor &gt; DefaultConfig。</span><br><span class=\"line\">        for (ProductFlavor productFlavor : productFlavorList) &#123;</span><br><span class=\"line\">            ProductFlavorData&lt;CoreProductFlavor&gt; data = productFlavors.get(</span><br><span class=\"line\">                    productFlavor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">            String dimensionName = productFlavor.getDimension();</span><br><span class=\"line\">            if (dimensionName == null) &#123;</span><br><span class=\"line\">                dimensionName = &quot;&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            variantConfig.addProductFlavor(</span><br><span class=\"line\">                    data.getProductFlavor(),</span><br><span class=\"line\">                    data.getSourceSet(),</span><br><span class=\"line\">                    dimensionName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 BuildType &amp; ProductFlavor 拼接而成的 SourceSet。</span><br><span class=\"line\">        // 名字分别为 &#x27;&#123;BuildVaraintName&#125;&#123;ProductFlavorList&#125;&#x27; 和 &#x27;&#123;ProductFlavorList&#125;&#x27;。</span><br><span class=\"line\">        NamedDomainObjectContainer&lt;AndroidSourceSet&gt; sourceSetsContainer = extension.getSourceSets();</span><br><span class=\"line\">        createCompoundSourceSets(productFlavorList, variantConfig, sourceSetsContainer, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 下面的5个 step 收集了 Variant 的所有相关的 SourceSet，分别是：</span><br><span class=\"line\">        // variant-specific, build type, multi-flavor, flavor1, flavor2, ..., defaultConfig.</span><br><span class=\"line\">        // 后面会使用这些 SourceSets 创建 VariantDependencies 对象。</span><br><span class=\"line\">        final List&lt;DefaultAndroidSourceSet&gt; variantSourceSets =</span><br><span class=\"line\">                Lists.newArrayListWithExpectedSize(productFlavorList.size() + 4);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. add the variant-specific if applicable.</span><br><span class=\"line\">        if (!productFlavorList.isEmpty()) &#123;</span><br><span class=\"line\">            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getVariantSourceProvider());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. the build type.</span><br><span class=\"line\">        variantSourceSets.add(buildTypeData.getSourceSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. the multi-flavor combination</span><br><span class=\"line\">        if (productFlavorList.size() &gt; 1) &#123;</span><br><span class=\"line\">            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getMultiFlavorSourceProvider());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. the flavors.</span><br><span class=\"line\">        for (ProductFlavor productFlavor : productFlavorList) &#123;</span><br><span class=\"line\">            variantSourceSets.add(productFlavors.get(productFlavor.getName()).getSourceSet());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 5. The defaultConfig</span><br><span class=\"line\">        variantSourceSets.add(defaultConfigData.getSourceSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 BaseVariantData 对象。</span><br><span class=\"line\">        BaseVariantData variantData =</span><br><span class=\"line\">                variantFactory.createVariantData(variantConfig, taskManager, recorder);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 VariantDependencies 对象并由 BaseVariantData 对象持有。</span><br><span class=\"line\">        // 构造 VariantDependencies 对象的过程中，创建了几个新的 Configuration：</span><br><span class=\"line\">        // &#x27;&#123;VariantName&#125;CompileClasspath&#x27;，&#x27;&#123;VariantName&#125;RuntimeClasspath&#x27; 等。</span><br><span class=\"line\">        // 由于每个 SourceSet 都会对应一个 Configuration，</span><br><span class=\"line\">        // 所以以通过 variantSourceSets 参数可以获取所有与 Variant 的所有相关的 Configuration。</span><br><span class=\"line\">        // 这里新创建的 Configuration 会视情况依赖 与 Variant 的所有相关的 Configuration。</span><br><span class=\"line\">        VariantDependencies.Builder builder =</span><br><span class=\"line\">            VariantDependencies.builder(</span><br><span class=\"line\">                        project, androidBuilder.getErrorReporter(), variantConfig)</span><br><span class=\"line\">                .setConsumeType(</span><br><span class=\"line\">                        getConsumeType(variantData.getVariantConfiguration().getType()))</span><br><span class=\"line\">                .setPublishType(</span><br><span class=\"line\">                        getPublishingType(variantData.getVariantConfiguration().getType()))</span><br><span class=\"line\">                .setFlavorSelection(getFlavorSelection(variantConfig))</span><br><span class=\"line\">                .addSourceSets(variantSourceSets)</span><br><span class=\"line\">                .setBaseSplit(</span><br><span class=\"line\">                        variantType == VariantType.FEATURE &amp;&amp; extension.getBaseFeature());</span><br><span class=\"line\">        final VariantDependencies variantDep = builder.build();</span><br><span class=\"line\">        variantData.setVariantDependency(variantDep);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果需要兼容 4.x 的 MultiDex，</span><br><span class=\"line\">        // 那么添加依赖 &#x27;com.android.support:multidex:1.0.2&#x27;。</span><br><span class=\"line\">        if (variantConfig.isLegacyMultiDexMode()) &#123;</span><br><span class=\"line\">            project.getDependencies().add(</span><br><span class=\"line\">                    variantDep.getCompileClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);</span><br><span class=\"line\">            project.getDependencies().add(</span><br><span class=\"line\">                    variantDep.getRuntimeClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @RenderScript</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return variantData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private void createCompoundSourceSets(</span><br><span class=\"line\">            @NonNull List&lt;? extends ProductFlavor&gt; productFlavorList,</span><br><span class=\"line\">            @NonNull GradleVariantConfiguration variantConfig,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;AndroidSourceSet&gt; sourceSetsContainer,</span><br><span class=\"line\">            @Nullable BaseVariantData testedVariantData) &#123;</span><br><span class=\"line\">        if (!productFlavorList.isEmpty()) &#123;</span><br><span class=\"line\">            // 创建名为 &#x27;&#123;BuildVaraintName&#125;&#123;ProductFlavorList&#125;&#x27; 的 SourceSet。</span><br><span class=\"line\">            DefaultAndroidSourceSet variantSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(</span><br><span class=\"line\">                            computeSourceSetName(</span><br><span class=\"line\">                                    variantConfig.getFullName(),</span><br><span class=\"line\">                                    variantConfig.getType()));</span><br><span class=\"line\">            variantConfig.setVariantSourceProvider(variantSourceSet);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (testedVariantData != null) &#123;</span><br><span class=\"line\">                // @Test,配置 Configuration 的依赖关系。</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (productFlavorList.size() &gt; 1) &#123;</span><br><span class=\"line\">            // 创建名为 &#x27;&#123;ProductFlavorList&#125;&#x27; 的 SourceSet。</span><br><span class=\"line\">            DefaultAndroidSourceSet multiFlavorSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(</span><br><span class=\"line\">                            computeSourceSetName(</span><br><span class=\"line\">                                    variantConfig.getFlavorName(),</span><br><span class=\"line\">                                    variantConfig.getType()));</span><br><span class=\"line\">            variantConfig.setMultiFlavorSourceProvider(multiFlavorSourceSet);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (testedVariantData != null) &#123;</span><br><span class=\"line\">                // @Test,配置 Configuration 的依赖关系。</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"VariantMananger-configureDependencies\"><a href=\"#VariantMananger-configureDependencies\" class=\"headerlink\" title=\"VariantMananger::configureDependencies()\"></a><code>VariantMananger::configureDependencies()</code></h4><p>在这个方法，通过注册 Gradle Transform 接口，解压缩并转移了所依赖 AAR 中的文件，使这些文件能够参与后续的编译过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void configureDependencies() &#123;</span><br><span class=\"line\">        final DependencyHandler dependencies = project.getDependencies();</span><br><span class=\"line\"></span><br><span class=\"line\">        // register transforms.</span><br><span class=\"line\">        final String explodedAarType = ArtifactType.EXPLODED_AAR.getType();</span><br><span class=\"line\">        dependencies.registerTransform(</span><br><span class=\"line\">                reg -&gt; &#123;</span><br><span class=\"line\">                    reg.getFrom().attribute(ARTIFACT_FORMAT, AndroidArtifacts.TYPE_AAR);</span><br><span class=\"line\">                    reg.getTo().attribute(ARTIFACT_FORMAT, explodedAarType);</span><br><span class=\"line\">                    reg.artifactTransform(ExtractAarTransform.class);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (ArtifactType transformTarget : AarTransform.getTransformTargets()) &#123;</span><br><span class=\"line\">            dependencies.registerTransform(</span><br><span class=\"line\">                    reg -&gt; &#123;</span><br><span class=\"line\">                        reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);</span><br><span class=\"line\">                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget.getType());</span><br><span class=\"line\">                        reg.artifactTransform(</span><br><span class=\"line\">                                AarTransform.class, config -&gt; config.params(transformTarget));</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dependencies.registerTransform(</span><br><span class=\"line\">                reg -&gt; &#123;</span><br><span class=\"line\">                    reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);</span><br><span class=\"line\">                    reg.getTo()</span><br><span class=\"line\">                            .attribute(</span><br><span class=\"line\">                                    ARTIFACT_FORMAT,</span><br><span class=\"line\">                                    ArtifactType.SYMBOL_LIST_WITH_PACKAGE_NAME.getType());</span><br><span class=\"line\">                    reg.artifactTransform(LibrarySymbolTableTransform.class);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (String transformTarget : JarTransform.getTransformTargets()) &#123;</span><br><span class=\"line\">            dependencies.registerTransform(</span><br><span class=\"line\">                    reg -&gt; &#123;</span><br><span class=\"line\">                        reg.getFrom().attribute(ARTIFACT_FORMAT, &quot;jar&quot;);</span><br><span class=\"line\">                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget);</span><br><span class=\"line\">                        reg.artifactTransform(JarTransform.class);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        AttributesSchema schema = dependencies.getAttributesSchema();</span><br><span class=\"line\"></span><br><span class=\"line\">        // custom strategy for AndroidTypeAttr</span><br><span class=\"line\">        AttributeMatchingStrategy&lt;AndroidTypeAttr&gt; androidTypeAttrStrategy =</span><br><span class=\"line\">                schema.attribute(AndroidTypeAttr.ATTRIBUTE);</span><br><span class=\"line\">        androidTypeAttrStrategy.getCompatibilityRules().add(AndroidTypeAttrCompatRule.class);</span><br><span class=\"line\">        androidTypeAttrStrategy.getDisambiguationRules().add(AndroidTypeAttrDisambRule.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        // custom strategy for build-type and product-flavor.</span><br><span class=\"line\">        setBuildTypeStrategy(schema);</span><br><span class=\"line\"></span><br><span class=\"line\">        setupFlavorStrategy(schema);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"VariantMananger-createTasksForVariantData\"><a href=\"#VariantMananger-createTasksForVariantData\" class=\"headerlink\" title=\"VariantMananger::createTasksForVariantData()\"></a><code>VariantMananger::createTasksForVariantData()</code></h4><p><em>下面代码使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createTasksForVariantData(</span><br><span class=\"line\">            final TaskFactory tasks, final VariantScope variantScope) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        create &quot;assemble&#123;BuildTypeName&#125;&quot; task as anchor task. </span><br><span class=\"line\">            it &quot;Assembles all assemble&#123;BuildTypeName&#125; builds.&quot;</span><br><span class=\"line\">            let &quot;assemble&quot; dependsOn &quot;assemble&#123;BuildTypeName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建更多基于 Variant 的 assemble task. </span><br><span class=\"line\">        createAssembleTaskForVariantData(tasks, variantData);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (variantType.isForTesting()) &#123;</span><br><span class=\"line\">            // @Test，创建基于 Variant 的单元测试 task.</span><br><span class=\"line\">            [+]&#123;...&#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 创建基于 Variant 的编译 task.</span><br><span class=\"line\">            taskManager.createTasksForVariantScope(tasks, variantScope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建基于 Variant 的 assemble task. </span><br><span class=\"line\">    private void createAssembleTaskForVariantData(</span><br><span class=\"line\">            TaskFactory tasks, final BaseVariantData variantData) &#123;</span><br><span class=\"line\">        final VariantScope variantScope = variantData.getScope();</span><br><span class=\"line\">        if (variantData.getType().isForTesting()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            create &quot;assemble&#123;VariantName&#125;&quot; task as anchor task. </span><br><span class=\"line\">                set variantScope assemble task with it.</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (productFlavors.isEmpty()) &#123;</span><br><span class=\"line\">                set variantScope assemble task with &quot;assemble&#123;BuildTypeName&#125;&quot;.</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                create &quot;assemble&#123;VariantName&#125;&quot; task as anchor task. </span><br><span class=\"line\">                    set variantScope assemble task with it.</span><br><span class=\"line\">                    let &quot;assemble&#123;BuildTypeName&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">                for each flavor</span><br><span class=\"line\">                    create &quot;assemble&#123;ProductFlavor&#125;&quot; as anchor task.</span><br><span class=\"line\">                        set ProductFlavorData assemble task with it.</span><br><span class=\"line\">                        let  &quot;assemble&#123;ProductFlavor&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">                if (variantConfig.getProductFlavors().size() &gt; 1) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    create &quot;assmble&#123;ProductFlavorList&#125;&quot; as anchor task.</span><br><span class=\"line\">                        it &quot;Assembles all builds for flavor combination: &#123;ProductFlavorList&#125;&quot;.</span><br><span class=\"line\">                        let &quot;assmble&#123;ProductFlavorList&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    let &quot;assemble&quot; dependsOn &quot;assmble&#123;ProductFlavorList&#125;&quot;.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"TaskMananger-createTasksForVariantScope\"><a href=\"#TaskMananger-createTasksForVariantScope\" class=\"headerlink\" title=\"TaskMananger::createTasksForVariantScope()\"></a><code>TaskMananger::createTasksForVariantScope()</code></h4><p><code>TaskMananger::createTasksForVariantScope()</code> 是一个抽象方法，创建基于 Variant 的编译 task，这些编译 task 就是 android 编译 toolchain 的调用者。<br>这个方法在各个 TaskMananger 子类中实现不同，这里就选 ApplicationTaskManager 的实现来看。</p>\n<p><em>下面代码使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationTaskManager extends TaskManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createTasksForVariantScope(</span><br><span class=\"line\">            @NonNull final TaskFactory tasks, @NonNull final VariantScope variantScope) &#123;</span><br><span class=\"line\">        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">        assert variantData instanceof ApplicationVariantData;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createAnchorTasks()</span><br><span class=\"line\">        create &quot;pre&#123;VariantName&#125;Build&quot; task as AppPreBuildTask task. </span><br><span class=\"line\">            set VariantScope prebuild task with it.</span><br><span class=\"line\">            let &quot;pre&#123;VariantName&#125;Build&quot; dependsOn &quot;preBuild&quot;.</span><br><span class=\"line\">        if enable code skrink</span><br><span class=\"line\">            let &quot;pre&#123;VariantName&#125;Build&quot; dependsOn &quot;extractProguardFiles&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;Sources&quot; as anchor task. </span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;prepareLintJar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;Resources&quot; as anchor task. </span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;Assets&quot; as anchor task. </span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test，创建单元测试覆盖率报告 task。</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Sources&quot; as anchor task. </span><br><span class=\"line\">            let &quot;assemble&#123;VariantName&#125;&quot; dependsOn &quot;compile&#123;VariantName&#125;Sources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createCheckManifestTask()</span><br><span class=\"line\">        create &quot;check&#123;VariantName&#125;Manifest&quot; as CheckManifest type task. </span><br><span class=\"line\">            let &quot;check&#123;VariantName&#125;Manifest&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Wear</span><br><span class=\"line\">        handleMicroApp(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建基于依赖的 transform stream</span><br><span class=\"line\">        createDependencyStreams(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createApplicationIdWriterTask()</span><br><span class=\"line\">        create &quot;write&#123;VariantName&#125;ApplicationId&quot; as ApplicationIdWriterTask type task. </span><br><span class=\"line\">            add &quot;build/intermediates/applicationId/&#123;ProductFlavorName&#125;/&#123;BuildTypeName&#125;&quot; to VariantScope outputs.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeApkManifestsTask()</span><br><span class=\"line\">        create &quot;create&#123;VariantName&#125;CompatibleScreenManifests&quot; as CompatibleScreensManifest type task.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;process&#123;VariantName&#125;Manifest&quot; as MergeManifests type task.</span><br><span class=\"line\">            let &quot;process&#123;VariantName&#125;Manifest&quot; dependsOn &quot;check&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createGenerateResValuesTask()</span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;ResValues&quot; as GenerateResValues type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Resources&quot; dependsOn &quot;generate&#123;VariantName&#125;ResValues&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createRenderscriptTask()</span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Renderscript&quot; as RenderscriptCompile type task.</span><br><span class=\"line\">        if is testing</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Renderscript&quot; dependsOn &quot;process&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\">        else</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Renderscript&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        let &quot;generate&#123;VariantName&#125;Resources&quot; dependsOn &quot;compile&#123;VariantName&#125;Renderscript&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        if not RenderscriptNdkModeEnabled</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;compile&#123;VariantName&#125;Renderscript&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeResourcesTask()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;Resources&quot; as MergeResources type task.</span><br><span class=\"line\">            let &quot;merge&#123;VariantName&#125;Resources&quot; dependsOn &quot;generate&#123;VariantName&#125;Resources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeAssetsTask()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;Assets&quot; as MergeSourceSetFolders type task.</span><br><span class=\"line\">            let &quot;merge&#123;VariantName&#125;Assets&quot; dependsOn &quot;generate&#123;VariantName&#125;Assets&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createBuildConfigTask()</span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;BuildConfig&quot; as GenerateBuildConfig type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;generate&#123;VariantName&#125;BuildConfig&quot;.</span><br><span class=\"line\">            if is testing</span><br><span class=\"line\">                let &quot;generate&#123;VariantName&#125;BuildConfig&quot; dependsOn &quot;process&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\">            else </span><br><span class=\"line\">                let &quot;generate&#123;VariantName&#125;BuildConfig&quot; dependsOn &quot;check&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createApkProcessResTask()</span><br><span class=\"line\">        create &quot;process&#123;VariantName&#125;Resources&quot; as ProcessAndroidResources type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;process&#123;VariantName&#125;Resources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;process&#123;VariantName&#125;JavaRes&quot; as Sync type task.</span><br><span class=\"line\">            let &quot;process&#123;VariantName&#125;JavaRes&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createAidlTask()</span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Aidl&quot; as AidlCompile type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;compile&#123;VariantName&#125;Aidl&quot;.</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Aidl&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createShaderTask()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;Shaders&quot; as MergeSourceSetFolders type task.</span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Shaders&quot; as ShaderCompile type task.</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Shaders&quot; dependsOn &quot;merge&#123;VariantName&#125;Shaders&quot;.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Assets&quot; dependsOn &quot;compile&#123;VariantName&#125;Shaders&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @NDK, ndk 编译任务</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeJniLibFoldersTasks()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;JniLibFolders&quot; as MergeSourceSetFolders type task.</span><br><span class=\"line\">            let &quot;merge&#123;VariantName&#125;JniLibFolders&quot; dependsOn &quot;generate&#123;VariantName&#125;Assets&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;mergedJniFolder&quot; stream</span><br><span class=\"line\">            type ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from &#123;@File &#x27;intermediates/jniLibs/&#123;VariantConfigurationDir&#125;&#x27;&#125;</span><br><span class=\"line\">            let stream depend on &quot;merge&#123;VariantName&#125;JniLibFolders&quot; task</span><br><span class=\"line\"></span><br><span class=\"line\">        // @NDK, 创建当前工程 ndk 编译产出的 so 文件以及 obj 文件 的 stream</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @RenderScript, 创建当前工程 rs 编译产物的 stream</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;transformNativeLibsWithMergeJniLibsFor&#123;VariantName&#125;&quot; task</span><br><span class=\"line\">            with &quot;mergeJniLibs&quot; transform as MergeJavaResourcesTransform type.</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES. </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // @DataBinding</span><br><span class=\"line\">        createDataBindingTasksIfNecessary(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 java 编译 task。</span><br><span class=\"line\">        addCompileTask();</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Ndk</span><br><span class=\"line\">        createStripNativeLibraryTask(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Multi</span><br><span class=\"line\">        createSplitTasks(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建打包 task。</span><br><span class=\"line\">        createPackagingTask(tasks, variantScope, buildInfoWriterTask);</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createLintTasks()</span><br><span class=\"line\">        create &quot;lint&#123;VariantName&#125;&quot; as LintPerVariantTask type.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TaskMananger::createDependencyStreams</code> 为 external 依赖（maven 或者 local jar 文件）和工程依赖创建 Android Transform stream 对象，使来自依赖的文件（主要是 class 文件）参与到 Android Transform 过程中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void createDependencyStreams(</span><br><span class=\"line\">            @NonNull TaskFactory tasks,</span><br><span class=\"line\">            @NonNull final VariantScope variantScope) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Test, 基于测试覆盖率需求，修改 Configuration</span><br><span class=\"line\">        handleJacocoDependencies(variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        TransformManager transformManager = variantScope.getTransformManager();</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;ext-libs-classes&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES</span><br><span class=\"line\">            scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            from ArtifactType.CLASSES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  </span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;ext-libs-res-plus-native&quot; stream</span><br><span class=\"line\">            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            from ArtifactType.JAVA_RES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  </span><br><span class=\"line\"></span><br><span class=\"line\">        // and the android AAR also have a specific jni folder</span><br><span class=\"line\">        create &quot;ext-libs-native&quot; stream</span><br><span class=\"line\">            type ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            from ArtifactType.JNI files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // data binding related artifacts for external libs</span><br><span class=\"line\">        // @DataBinding, 创建 dataBinding 需要的 steams</span><br><span class=\"line\">        if (extension.getDataBinding().isEnabled()) &#123;</span><br><span class=\"line\">            &#123;...&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // for the sub modules, new intermediary classes artifact has its own stream</span><br><span class=\"line\">        create &quot;sub-projects-classes&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES</span><br><span class=\"line\">            scope Scope.SUB_PROJECTS</span><br><span class=\"line\">            from ArtifactType.CLASSES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // same for the resources which can be java-res or jni</span><br><span class=\"line\">        create &quot;sub-projects-res-plus-native&quot; stream</span><br><span class=\"line\">            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.SUB_PROJECTS</span><br><span class=\"line\">            from ArtifactType.JAVA_RES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // and the android library sub-modules also have a specific jni folder</span><br><span class=\"line\">        create &quot;sub-projects-native&quot; stream</span><br><span class=\"line\">            type ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.SUB_PROJECTS</span><br><span class=\"line\">            from ArtifactType.JNI files in ArtifactScope.MODULE on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // provided only scopes.</span><br><span class=\"line\">        create &quot;provided-classes&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES</span><br><span class=\"line\">            scope Scope.PROVIDED_ONLY</span><br><span class=\"line\">            from ArtifactType.JNI files in ArtifactScope.MODULE on (COMPILE_CLASSPATH minus RUNTIME_CLASSPATH)</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Test,  创建 test 需要的 steams</span><br><span class=\"line\">        if (variantScope.getTestedVariantData() != null) &#123;</span><br><span class=\"line\">            &#123;...&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>compile 任务创建流程: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationTaskManager extends TaskManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private void addCompileTask(@NonNull TaskFactory tasks, @NonNull VariantScope variantScope) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @DataBinding</span><br><span class=\"line\">        createDataBindingMergeArtifactsTaskIfNecessary(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createJavacTask()</span><br><span class=\"line\">        create &quot;javaPreCompile&#123;VariantName&#125;&quot; as JavaPreCompileTask type.</span><br><span class=\"line\">            let &quot;javaPreCompile&#123;VariantName&#125;&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;JavaWithJavac&quot; as AndroidJavaCompile type.</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;JavaWithJavac&quot; dependsOn &quot;generate&#123;VariantName&#125;Sources&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Create the classes artifact for uses by external test modules.</span><br><span class=\"line\">        create &quot;bundleAppClasses&#123;VariantName&#125;&quot; as Jar type.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // @Java8，一些基于 java8 配置的 validation 工作。</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in addJavacClassesStream(variantScope)</span><br><span class=\"line\">        create &quot;javac-output&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from JAVAC output on variantScope</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;pre-javac-generated-bytecode&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from PreJavacGeneratedBytecode</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;post-javac-generated-bytecode&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from PostJavacGeneratedBytecode</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        // in setJavaCompilerTask()</span><br><span class=\"line\">        let &quot;compile&#123;VariantName&#125;Sources&quot; dependsOn &quot;compile&#123;VariantName&#125;JavaWithJavac&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建生成 dex 相关的 task。</span><br><span class=\"line\">        createPostCompilationTasks(tasks, variantScope);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createPostCompilationTasks(</span><br><span class=\"line\">            @NonNull TaskFactory tasks,</span><br><span class=\"line\">            @NonNull final VariantScope variantScope) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        checkNotNull(variantScope.getJavacTask());</span><br><span class=\"line\"></span><br><span class=\"line\">        final BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">        final GradleVariantConfiguration config = variantData.getVariantConfiguration();</span><br><span class=\"line\"></span><br><span class=\"line\">        TransformManager transformManager = variantScope.getTransformManager();</span><br><span class=\"line\">        // ---- Code Coverage first -----</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Test，创建测试覆盖率相关的 transform</span><br><span class=\"line\">        if (isTestCoverageEnabled) &#123;</span><br><span class=\"line\">            createJacocoTransform(tasks, variantScope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in maybeCreateDesugarTask(tasks, variantScope, config.getMinSdkVersion(), transformManager)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果 java8 支持使用 desuger</span><br><span class=\"line\">        if (variantScope.getJava8LangSupportType() == Java8LangSupport.DESUGAR) &#123;</span><br><span class=\"line\">            create &quot;transformClassWithStackFramesFixerFor&#123;VariantName&#125;&quot; task </span><br><span class=\"line\">                with &quot;stackFramesFixer&quot; transform as FixStackFramesTransform type.</span><br><span class=\"line\">                on Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">            create &quot;transformClassWithDesugarFor&#123;VariantName&#125;&quot; task as TransformTask</span><br><span class=\"line\">                with &quot;desugar&quot; transform as DesugarTransform type.</span><br><span class=\"line\">                on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">            // 如果 minSdk.getFeatureLevel() 小于 19</span><br><span class=\"line\">            if (minSdk.getFeatureLevel()</span><br><span class=\"line\">                    &lt; DesugarProcessBuilder.MIN_SUPPORTED_API_TRY_WITH_RESOURCES) &#123;</span><br><span class=\"line\">                create &quot;extractTryWithResourcesSupportJar&#123;VariantName&#125;&quot; as ExtractTryWithResourcesSupportJar type.</span><br><span class=\"line\">                    let &#123;@File &#x27;intermediates/processing-tools/runtime-deps/&#123;VariantConfigurationDir&#125;/desugar_try_with_resources.jar&#x27;&#125; depend on &quot;extractTryWithResourcesSupportJar&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">                create &#x27;runtime-deps-try-with-resources&#x27; stream</span><br><span class=\"line\">                    type DefaultContentType.CLASSES</span><br><span class=\"line\">                    scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">                    from &#123;@File &#x27;intermediates/processing-tools/runtime-deps/&#123;VariantConfigurationDir&#125;/desugar_try_with_resources.jar&#x27;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        AndroidConfig extension = variantScope.getGlobalScope().getExtension();</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeJavaResTransform(tasks, variantScope)</span><br><span class=\"line\">        create &#x27;transformResourcesWithMergeJavaResFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with &#x27;mergeJavaRes&#x27; transform as MergeJavaResourcesTransform type</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES </span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        // 处理开发者自行注册的 transform</span><br><span class=\"line\">        // ----- External Transforms -----</span><br><span class=\"line\">        // apply all the external transforms.</span><br><span class=\"line\">        List&lt;Transform&gt; customTransforms = extension.getTransforms();</span><br><span class=\"line\">        List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0, count = customTransforms.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">            Transform transform = customTransforms.get(i);</span><br><span class=\"line\"></span><br><span class=\"line\">            List&lt;Object&gt; deps = customTransformsDependencies.get(i);</span><br><span class=\"line\">            transformManager</span><br><span class=\"line\">                    .addTransform(tasks, variantScope, transform)</span><br><span class=\"line\">                    .ifPresent(t -&gt; &#123;</span><br><span class=\"line\">                        if (!deps.isEmpty()) &#123;</span><br><span class=\"line\">                            t.dependsOn(tasks, deps);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        // if the task is a no-op then we make assemble task depend on it.</span><br><span class=\"line\">                        if (transform.getScopes().isEmpty()) &#123;</span><br><span class=\"line\">                            variantScope.getAssembleTask().dependsOn(tasks, t);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @IDE </span><br><span class=\"line\">        // ----- Android studio profiling transforms</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建包大小压缩的 transform</span><br><span class=\"line\">        // ----- Minify next -----</span><br><span class=\"line\">        // in maybeCreateJavaCodeShrinkerTransform(tasks, variantScope)</span><br><span class=\"line\">        create &#x27;transformClassAndResourcesWithProguardFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with &#x27;proguard&#x27; as ProGuardTransform type</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">        create &#x27;transformClassWithAndroidGradleClassShrinkerFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with &#x27;androidGradleClassShrinker&#x27; as BuiltInShrinkerTransform type</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">        create &#x27;check&#123;VariantName&#125;ProguardFiles&#x27; as CheckProguardFiles type</span><br><span class=\"line\">            let &#x27;transformClassAndResourcesWithProguardFor&#123;VariantName&#125;&#x27; or &#x27;transformClassWithAndroidGradleClassShrinkerFor&#123;VariantName&#125;&#x27; depend on &#x27;check&#123;VariantName&#125;ProguardFiles&#x27;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // in  maybeCreateResourcesShrinkerTransform(tasks, variantScope)</span><br><span class=\"line\">        create &#x27;transformClassWithShrinkResFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with shrinkRes transform as ShrinkResourcesTransform type</span><br><span class=\"line\">            on empty scope</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        // ----- 10x support</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ----- Multi-Dex support</span><br><span class=\"line\"></span><br><span class=\"line\">        DexingType dexingType = variantScope.getDexingType();</span><br><span class=\"line\"></span><br><span class=\"line\">        // Upgrade from legacy multi-dex to native multi-dex if possible when using with a device</span><br><span class=\"line\">        if (dexingType == DexingType.LEGACY_MULTIDEX) &#123;</span><br><span class=\"line\">            if (variantScope.getVariantConfiguration().isMultiDexEnabled()</span><br><span class=\"line\">                    &amp;&amp; variantScope</span><br><span class=\"line\">                                    .getVariantConfiguration()</span><br><span class=\"line\">                                    .getMinSdkVersionWithTargetDeviceApi()</span><br><span class=\"line\">                                    .getFeatureLevel()</span><br><span class=\"line\">                            &gt;= 21) &#123;</span><br><span class=\"line\">                dexingType = DexingType.NATIVE_MULTIDEX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;AndroidTask&lt;TransformTask&gt;&gt; multiDexClassListTask;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (dexingType == DexingType.LEGACY_MULTIDEX) &#123;</span><br><span class=\"line\">            boolean proguardInPipeline = variantScope.getCodeShrinker() == CodeShrinker.PROGUARD;</span><br><span class=\"line\"></span><br><span class=\"line\">            // If ProGuard will be used, we&#x27;ll end up with a &quot;fat&quot; jar anyway. If we&#x27;re using the</span><br><span class=\"line\">            // new dexing pipeline, we&#x27;ll use the new MainDexListTransform below, so there&#x27;s no need</span><br><span class=\"line\">            // for merging all classes into a single jar.</span><br><span class=\"line\">            if (!proguardInPipeline &amp;&amp; !usingIncrementalDexing(variantScope)) &#123;</span><br><span class=\"line\">                // Create a transform to jar the inputs into a single jar. Merge the classes only,</span><br><span class=\"line\">                // no need to package the resources since they are not used during the computation.</span><br><span class=\"line\">                 create &#x27;transformClassWithJarMergingFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with jarMerging transform as JarMergingTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // ---------</span><br><span class=\"line\">            // create the transform that&#x27;s going to take the code and the proguard keep list</span><br><span class=\"line\">            // from above and compute the main class list.</span><br><span class=\"line\">            Transform multiDexTransform;</span><br><span class=\"line\">            if (usingIncrementalDexing(variantScope)) &#123;</span><br><span class=\"line\">                create &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with multidexlist transform as MainDexListTransform type</span><br><span class=\"line\">                    on empty scope</span><br><span class=\"line\">                    set multiDexTransform with it</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                create &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with multidexlist transform as MultiDexTransform type</span><br><span class=\"line\">                    on empty scope</span><br><span class=\"line\">                    set multiDexTransform with it</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            multiDexClassListTask =</span><br><span class=\"line\">                    transformManager.addTransform(tasks, variantScope, multiDexTransform);</span><br><span class=\"line\">            multiDexClassListTask.ifPresent(variantScope::addColdSwapBuildTask);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            multiDexClassListTask = Optional.empty();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (usingIncrementalDexing(variantScope)) &#123;</span><br><span class=\"line\">            // in createNewDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)</span><br><span class=\"line\">            create &#x27;transformClassWithDexBuilderFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with dexBuilder transform as DexArchiveBuilderTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\"></span><br><span class=\"line\">            if (dexingType != DexingType.LEGACY_MULTIDEX</span><br><span class=\"line\">                &amp;&amp; variantScope.getCodeShrinker() == null</span><br><span class=\"line\">                &amp;&amp; extension.getTransforms().isEmpty()) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                create &#x27;transformDexArchiveWithExternalLibsDexMergerFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with externalLibsDexMerger transform as ExternalLibsMergerTransform type</span><br><span class=\"line\">                    on Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            create &#x27;transformDexArchiveWithDexMergerFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with dexMerger transform as DexMergerTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\">            let &#x27;transformDexWithDexMergerFor&#123;VariantName&#125;&#x27; depend on &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // in createDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (preDexEnabled) &#123;</span><br><span class=\"line\">                create &#x27;transformClassWithPreDexFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with preDex transform as PreDexTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (!preDexEnabled || dexingType != DexingType.NATIVE_MULTIDEX) &#123;</span><br><span class=\"line\">                // run if non native multidex or no pre-dexing</span><br><span class=\"line\">                create &#x27;transformClassWithDexFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with dex transform as DexTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\"></span><br><span class=\"line\">                let &#x27;transformClassWithDexFor&#123;VariantName&#125;&#x27; depend on &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>package 任务创建流程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createPackagingTask(</span><br><span class=\"line\">            @NonNull TaskFactory tasks,</span><br><span class=\"line\">            @NonNull VariantScope variantScope,</span><br><span class=\"line\">            @Nullable AndroidTask&lt;BuildInfoWriterTask&gt; fullBuildInfoGeneratorTask) &#123;</span><br><span class=\"line\">        ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();</span><br><span class=\"line\"></span><br><span class=\"line\">        boolean signedApk = variantData.isSigned();</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;package&#123;VariantName&#125;&quot; as PackageApplication type.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;merge&#123;VariantName&#125;Assets&quot;.</span><br><span class=\"line\">        let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;process&#123;VariantName&#125;Resources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;validateSigning&#123;VariantName&#125;&quot; as ValidateSigningTask type.</span><br><span class=\"line\">            let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;validateSigning&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;compile&#123;VariantName&#125;JavaWithJavac&quot;.</span><br><span class=\"line\">        let &quot;assemble&#123;VariantName&#125;&quot; dependsOn package&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Multi</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (signedApk) &#123;</span><br><span class=\"line\">            create &quot;install&#123;VariantName&#125;&quot; as InstallVariantTask type.</span><br><span class=\"line\">                let &quot;install&#123;VariantName&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in maybeCreateLintVitalTask()</span><br><span class=\"line\">        create &quot;lintVital&#123;VariantName&#125;&quot; as LintPerVariantTask type.</span><br><span class=\"line\">            let &quot;lintVital&#123;VariantName&#125;&quot; dependsOn &quot;compile&#123;VariantName&#125;JavaWithJavac&quot;.</span><br><span class=\"line\">        let &quot;assemble&#123;VariantName&#125;&quot; dependsOn &quot;lintVital&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果任务树中包含 &quot;lint&quot;，就不再执行 &quot;lintVital&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">        project.getGradle().getTaskGraph().whenReady(</span><br><span class=\"line\">            taskGraph -&gt; &#123;</span><br><span class=\"line\">                if (taskGraph.hasTask(getTaskPath(LINT))) &#123;</span><br><span class=\"line\">                    project.getTasks()</span><br><span class=\"line\">                            .getByName(lintReleaseCheck.getName())</span><br><span class=\"line\">                            .setEnabled(false);</span><br><span class=\"line\">                &#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;uninstall&#123;VariantName&#125;&quot; as UninstallTask type.</span><br><span class=\"line\">            let &quot;uninstallAll&quot; dependsOn &quot;uninstall&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ApiObjectFactory-create\"><a href=\"#ApiObjectFactory-create\" class=\"headerlink\" title=\"ApiObjectFactory.create()\"></a><code>ApiObjectFactory.create()</code></h4><p>基于 BaseVariantData 对象创建 BaseVariantImpl 对象, 并将 BaseVariantImpl 对象加入 extension 的容器中，到这里 project 模型的搭建完成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public BaseVariantImpl create(BaseVariantData variantData) &#123;</span><br><span class=\"line\">    if (variantData.getType().isForTesting()) &#123;</span><br><span class=\"line\">        // Testing variants are handled together with their &quot;owners&quot;.</span><br><span class=\"line\">        createVariantOutput(variantData, null);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BaseVariantImpl variantApi =</span><br><span class=\"line\">        variantFactory.createVariantApi(</span><br><span class=\"line\">            instantiator,</span><br><span class=\"line\">            objectFactory,</span><br><span class=\"line\">            androidBuilder,</span><br><span class=\"line\">            variantData,</span><br><span class=\"line\">            readOnlyObjectProvider);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (variantApi == null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // @Test</span><br><span class=\"line\">    if (variantFactory.hasTestScope()) &#123;</span><br><span class=\"line\">        // 创建 TestVariantImpl 对象和 UnitTestVariantImpl 对象</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // in createVariantOutput(variantData, variantApi)</span><br><span class=\"line\">    // 创建 VariantOutputFactory 对象</span><br><span class=\"line\">    variantData.variantOutputFactory =</span><br><span class=\"line\">        new VariantOutputFactory(</span><br><span class=\"line\">            (variantData.getType() == LIBRARY)</span><br><span class=\"line\">                    ? LibraryVariantOutputImpl.class</span><br><span class=\"line\">                    : ApkVariantOutputImpl.class,</span><br><span class=\"line\">            instantiator,</span><br><span class=\"line\">            extension,</span><br><span class=\"line\">            variantApi,</span><br><span class=\"line\">            variantData);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修改 apk 输出的的 versionCode 和 versionName</span><br><span class=\"line\">    variantData</span><br><span class=\"line\">            .getOutputScope()</span><br><span class=\"line\">            .getApkDatas()</span><br><span class=\"line\">            .forEach(</span><br><span class=\"line\">                apkData -&gt; &#123;</span><br><span class=\"line\">                    apkData.setVersionCode(</span><br><span class=\"line\">                        variantData.getVariantConfiguration().getVersionCode());</span><br><span class=\"line\">                    apkData.setVersionName(</span><br><span class=\"line\">                        variantData.getVariantConfiguration().getVersionName());</span><br><span class=\"line\">                    variantData.variantOutputFactory.create(apkData);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将 BaseVariantImpl 对象置入 extension 的 variantList 容器中</span><br><span class=\"line\">    // Only add the variant API object to the domain object set once it&#x27;s been fully</span><br><span class=\"line\">    // initialized.</span><br><span class=\"line\">    extension.addVariant(variantApi);</span><br><span class=\"line\"></span><br><span class=\"line\">    return variantApi;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Android-Transform-体系\"><a href=\"#Android-Transform-体系\" class=\"headerlink\" title=\"Android Transform 体系\"></a>Android Transform 体系</h3><h2 id=\"附表\"><a href=\"#附表\" class=\"headerlink\" title=\"附表\"></a>附表</h2><h3 id=\"android-plugin-支持的-gradle-properties\"><a href=\"#android-plugin-支持的-gradle-properties\" class=\"headerlink\" title=\"android plugin 支持的 gradle properties\"></a>android plugin 支持的 gradle properties</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why ?\"></a>Why ?</h2><p>目标：使 Android 编译过程由黑盒变为白盒。<br>好处： </p>\n<ul>\n<li>理解 android plugin 接口含义和能力，更好的编写编译脚本。  </li>\n<li>熟悉 android gradle 任务树，方便在编写 gradle 插件时 hook android 编译任务。 </li>\n<li>看懂编译中间产物、以及熟练的调试编译源码，以便在开发时定位编译时发生的问题。 </li>\n<li>了解 android 编译 toolChain 和 编译输出，是进一步学习 Android Runtime 的基础。 </li>\n</ul>\n<h2 id=\"行文\"><a href=\"#行文\" class=\"headerlink\" title=\"行文\"></a>行文</h2><p>版本：源码基于 android plugin 3.0.0，gradle 4.1。<br>主流程：<br>首先，在本篇概览中会概述 Android 的编译流程，浏览 android plugin 的入口源码。<br>而后，分别详述编译流程中的各个阶段 ：针对该编译阶段所涉及的 plugin api、project 模型、编译任务、toolChain、输入以及输出进行纵向分析，可能会浏览该阶段编译任务以及 toolChain 的源码。<br>最后，会分析 application 工程和 library 工程在编译时的区别。   </p>\n<p>副流程：<br>Android 编译中涉及到了很多 Optional 的话题，这些话题会渗透到编译流程的各个阶段。将这些话题从主流程中分离出来，以切面的形式归纳为副流程分别单独学习，也许是更好的方式。   </p>\n<p>副流程也许会包括 (排在越后面，会被包括的可能性越小)：</p>\n<ul>\n<li>Java8 support。</li>\n<li>Kotlin。</li>\n<li>AppBundle</li>\n<li>单元测试与集成测试。</li>\n<li>Lint。</li>\n<li>Ndk。</li>\n<li>Instant Run。</li>\n<li>DataBinding。</li>\n<li>Wear &amp; TV support。</li>\n<li>IDE。</li>\n</ul>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p>gradle 编译脚本 &amp;  -&gt; plugin api -&gt; project 模型 -&gt; 编译任务树 &amp; Transtrom 流 -&gt; toolChain -&gt; 中间产物文件流 -&gt; 编译输出</p>\n<p>结构基础：gradle api、 gradle、android sdk。</p>\n<p>这一篇会包含 plugin api -&gt; project 模型 -&gt; 编译任务树 &amp; Transtrom 流 三个部分；之后在各个编译流程流程中会涉及到 编译任务树 &amp; Transtrom 流  -&gt; toolChain -&gt; 中间产物文件流。   </p>\n<h2 id=\"android-plugin-api-概览\"><a href=\"#android-plugin-api-概览\" class=\"headerlink\" title=\"android plugin api 概览\"></a>android plugin api 概览</h2><p>plugin api 是 android 编译系统暴露给开发者的配置接口，以基于 gradle &amp; groovy 的 DSL (Domain-specific language) 组织而成。plugin api 可以大致被划分为 plugin、extension、dsl model 三个部分：</p>\n<ul>\n<li>plugin 是 android 编译系统的入口，开发者通过 apply plugin 来调用编译系统，进而完成暴露 plugin api，构建 project 模型，生成编译任务等一系列流程。</li>\n<li>extension 是承载 dsl model 的对象，它通过 delegate 的方式挂载到扩 gradle project 上，方便开发者通过对其成员赋值，从而完成编译配置过程。 </li>\n<li>dsl model 的接口繁多，是 plugin api 的主体，代表了 android 编译过程的各种配置参数。</li>\n</ul>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p><img src=\"https://i.loli.net/2019/03/07/5c80c1f57f944.jpg\" alt=\"Android-Gradle-Plugins\"></p>\n<p><code>BasePlugin</code> 有多个继承类型，各个继承类型对应了不同类型的 android plugin，以支持不同的 android 编译类型。</p>\n<ul>\n<li><code>AppPlugin</code> (com.android.application)，构建 app 工程。</li>\n<li><code>LibraryPlugin</code> (com.android.library)，构建 library 工程。</li>\n<li><code>FeaturePlugin</code> (com.android.feature)，构建 app-bundle。</li>\n<li><code>InstantAppPlugin</code> (com.android.instantapp)，执行 intant-run。</li>\n<li><code>TestPlugin</code> （com.android.test)，用单独工程执行 instrumented-test。</li>\n</ul>\n<p>android plugin 绝大部分配置过程代码都包含在 <code>BasePlugin</code> 中，<code>BasePlugin</code> 的各个子类仅仅创建并返回了类型不同的 <code>BaseExtension</code>、<code>VariantFactory</code>、<code>TaskManager</code> 实现类对象。基于这些不同的实现对象，使各种编译类型在 plugin api、project 模型和编译任务等方面略有不同。</p>\n<h3 id=\"extensions\"><a href=\"#extensions\" class=\"headerlink\" title=\"extensions\"></a>extensions</h3><h2 id=\"android-的-project-模型概览\"><a href=\"#android-的-project-模型概览\" class=\"headerlink\" title=\"android 的 project 模型概览\"></a>android 的 project 模型概览</h2><h2 id=\"android-的编译任务树概览\"><a href=\"#android-的编译任务树概览\" class=\"headerlink\" title=\"android 的编译任务树概览\"></a>android 的编译任务树概览</h2><h2 id=\"在读源码之前\"><a href=\"#在读源码之前\" class=\"headerlink\" title=\"在读源码之前\"></a>在读源码之前</h2><h3 id=\"源码工程-–-gradle-和-gradle-core\"><a href=\"#源码工程-–-gradle-和-gradle-core\" class=\"headerlink\" title=\"源码工程 – :gradle 和 :gradle-core\"></a>源码工程 – :gradle 和 :gradle-core</h3><p>:gradle 包含了 android plugin 链接到 gradle project 的 anchor 类，即一些 plugin 和 extension 类，这里就是 android plugin 的入口。<br>:gradle-core 是 android plugin 的实现工程，里面包含了 project 模型的管理类、 构建任务树的管理类、任务的实现类等。 这些类被 :gralde 工程中的 plugin 调用，处理 开发者编译脚本向 extension 中提交的信息、建立 project 模型、创建 android task，并经过各类 android task 链接到 android 构建的 toolchain。    </p>\n<h3 id=\"源码阅读的起点-–-BasePlugin-apply\"><a href=\"#源码阅读的起点-–-BasePlugin-apply\" class=\"headerlink\" title=\"源码阅读的起点 – BasePlugin.apply()\"></a>源码阅读的起点 – <code>BasePlugin.apply()</code></h3><p><code>BasePlugin</code> 是所有 android plugin 的基类，<code>BasePlugin.apply()</code> 方法可以视为 android plugin 的程序入口。这个方法涵盖了 android plugin 配置阶段的全部过程， 以 <code>BasePlugin.apply()</code> 为起点可以了解 android plugin 工程模型的创建过程和任务树的创建过程。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"BasePlugin-apply\"><a href=\"#BasePlugin-apply\" class=\"headerlink\" title=\"BasePlugin::apply()\"></a><code>BasePlugin::apply()</code></h3><ul>\n<li>进行一系列的 validate 检查。</li>\n<li>读取 gradle.properties 文件中所有与 android plugin 有关的配置，并根据这些配置初始化一些编译参数。</li>\n<li>调用<code>configureProject()</code>、<code>configureExtension()</code>、<code>createTasks()</code> 三个方法；这三个方法就是 android plugin 配置阶段的主体操作。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void apply(@NonNull Project project) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\"></span><br><span class=\"line\">       //AndroidBasePlugin 会被所有 plugin 类型 apply，它不做任何事情，只是方便判断是否有某种 android 的 plugin 类被 applay 过了。</span><br><span class=\"line\">       project.getPluginManager().apply(AndroidBasePlugin.class);</span><br><span class=\"line\">       </span><br><span class=\"line\">       // 检查 builder.jar 的版本号是否和 android plugin 的版本号一致，否则抛异常。</span><br><span class=\"line\">       // 如果使用了 &#x27;com.android.tools.build:gradle-experimental&#x27; 中的  gradle-experimental 插件，</span><br><span class=\"line\">       // 并且其版本和 &#x27;com.android.tools.build:gradle&#x27; 的版本不一致，</span><br><span class=\"line\">       // 那么就会出现 builder.jar 的版本号是否和 android plugin 的版本号不一致的情况。</span><br><span class=\"line\">       // TODO: what&#x27;s gradle-experimental</span><br><span class=\"line\">       checkPluginVersion();</span><br><span class=\"line\"></span><br><span class=\"line\">       this.project = project;</span><br><span class=\"line\"></span><br><span class=\"line\">       // ProjectOptions 是一个 Immutable 模型对象，它包含了很多类型为 Option&lt;String&gt; 对象。</span><br><span class=\"line\">       // ProjectOptions 实际上是一个 key-value 形式的配置表，包含了 gradle.properties 文件中所有与 android plugin 有关的配置。</span><br><span class=\"line\">       // 各类配置被定义在 :gradle-core &gt; com.android.build.gradle.options 包下面的枚举类中。</span><br><span class=\"line\">       // 这些配置大多以 &#x27;android.&#x27; 开头，详见附表部分。</span><br><span class=\"line\">       this.projectOptions = new ProjectOptions(project);</span><br><span class=\"line\"></span><br><span class=\"line\">       // 由  &#123;@GradleProperties &#x27;android.threadPoolSize&#x27;&#125; 配置来设置 ExecutorSingleton 的线程池尺寸。</span><br><span class=\"line\">       ExecutionConfigurationUtil.setThreadPoolSize(projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">       //在 window 平台上，gradle 工程 根目录的绝对路径上不能有非ASCII字符，否则就抛出异常，原因参见 http://b.android.com/95744；可以配置&#123;@GradleProperties &#x27;android.overridePathCheck&#x27;&#125; = true 屏蔽这个检查。</span><br><span class=\"line\">       checkPathForErrors();</span><br><span class=\"line\"></span><br><span class=\"line\">       //gradle 工程中，不能存在两个同名的子工程，否则就抛出异常。</span><br><span class=\"line\">       checkModulesForErrors();</span><br><span class=\"line\">       </span><br><span class=\"line\">       // PluginInitializer 用于验证两件事情：</span><br><span class=\"line\">       // 在一次构建中，不同子工程使用的 android plugin 版本一致。</span><br><span class=\"line\">       // 在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。</span><br><span class=\"line\">       PluginInitializer.initialize(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">       // ProfilerInitializer 通过向 gradle 注册监听，记录*当前子工程*所有 gradle task 的执行时间。</span><br><span class=\"line\">       // 当构建结束之后，将所记录的时间输出到 &#x27;project.getRootProject()/build/android-profile/profile-&#x27;YYYY-MM-dd-HH-mm-ss-SSS&#x27;.rawproto&#x27; 文件中。</span><br><span class=\"line\">       // TODO: 这个文件的作用是什么？猜测是给 IDE 用的。</span><br><span class=\"line\">       ProfilerInitializer.init(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">       ...</span><br><span class=\"line\"></span><br><span class=\"line\">       // 涵盖 BasePlugin 主体操作的三个 private 方法。 </span><br><span class=\"line\">       configureProject()</span><br><span class=\"line\">       configureExtension()</span><br><span class=\"line\">       createTasks()</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"PluginInitializer\"><a href=\"#PluginInitializer\" class=\"headerlink\" title=\"PluginInitializer\"></a><code>PluginInitializer</code></h4><p><code>PluginInitializer</code> 这个类比较有意思，它的作用是验证 android plugin 在各个子工程之间一致性。具体来说包含如下两方面验证：</p>\n<ul>\n<li>在一次构建中，不同子工程使用的 android plugin 版本一致。</li>\n<li>在一次构建中，android plugin 的 class 文件是被同一个 classloader 加载的。<br>那么问题来了，无论是不同的子工程使用了不同的 android plugin 版本，还是 android plugin 的 class 文件被不同的 classloader 加载，都会在 jvm 中形成两套相互独立的 class，要如何检测这种情况呢。<br><code>PluginInitializer</code> 有两个静态变量分别负责上述两种检查，分别是 <code>projectToPluginVersionMap</code> 和 <code>loadedPluginClass</code>，这两个变量是通过 <code>JvmWideVariable</code> 获得的。<code>JvmWideVariable</code> 提供了一种直接在 jvm 创建对象的方式，并通过字符串 key 来获取对象引用。所以 <code>PluginInitializer</code> 的 <code>projectToPluginVersionMap</code> 和 <code>loadedPluginClass</code> 并不是和 class 绑定的静态对象，而是通过字符串 key 直接维护在 jvm 的堆中。只要不同版本的 android plugin 使用相同的 key 从 jvm 中创建和获取对象，那么即使是相互独立的 class 也能取得同一个对象，从而经由不同版本 android plugin 相互协作实现 <code>PluginInitializer</code> 所需验证的情况。<br>可以看见源码中对于 key 常量有如下注释：</li>\n</ul>\n<blockquote>\n<p>IMPORTANT: This variable’s group, name, and type must not be changed across<br>plugin versions.</p>\n</blockquote>\n<p>另外，什么情况下会发生 android plugin 被不同的 classloader 加载呢？源码的异常信息中给了如下解释，如果有兴趣可以看<a href=\"https://d.android.com/r/tools/buildscript-classpath-check.html\">issue链接</a></p>\n<blockquote>\n<p>Due to a limitation of Gradle’s new variant-aware dependency management, loading the Android Gradle plugin in different class loaders leads to a build error.<br>This can occur when the buildscript classpaths that contain the Android Gradle plugin in sub-projects, or included projects in the case of composite builds, are set differently.<br>To resolve this issue, add the Android Gradle plugin to only the buildscript classpath of the top-level build.gradle file.<br>In the case of composite builds, also make sure the build script classpaths that contain the Android Gradle plugin are identical across the main and included projects.<br>If you are using a version of Gradle that has fixed the issue, you can disable this check by setting android.enableBuildScriptClasspathCheck=false in the gradle.properties file.<br>To learn more about this issue, go to <a href=\"https://d.android.com/r/tools/buildscript-classpath-check.html\">https://d.android.com/r/tools/buildscript-classpath-check.html</a>.   </p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class PluginInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Map&lt;gradle project 对象 , android plugin 版本的&gt; , 所用版本的 android plugin 共用一个对象，用于判断是否存在多个版本。</span><br><span class=\"line\">    // IMPORTANT: This variable&#x27;s group, name, and type must not be changed across plugin versions.</span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private static final ConcurrentMap&lt;Object, String&gt; projectToPluginVersionMap =</span><br><span class=\"line\">            Verify.verifyNotNull(</span><br><span class=\"line\">                    new JvmWideVariable&lt;&gt;(</span><br><span class=\"line\">                                    </span><br><span class=\"line\">                                    &quot;PLUGIN_VERSION_CHECK&quot;,</span><br><span class=\"line\">                                    &quot;PROJECT_TO_PLUGIN_VERSION&quot;,</span><br><span class=\"line\">                                    new TypeToken&lt;ConcurrentMap&lt;Object, String&gt;&gt;() &#123;&#125;,</span><br><span class=\"line\">                                    ConcurrentHashMap::new)</span><br><span class=\"line\">                            .get());</span><br><span class=\"line\"></span><br><span class=\"line\">    // AndroidBasePlugin.class 的引用，对于同一个 android plugin 版本的多次加载而言，共用一个对象，用于判断同一个版本是否被多个 classloader 加载。</span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private static final AtomicReference&lt;Class&lt;?&gt;&gt; loadedPluginClass =</span><br><span class=\"line\">            Verify.verifyNotNull(</span><br><span class=\"line\">                    new JvmWideVariable&lt;&gt;(</span><br><span class=\"line\">                                    PluginInitializer.class.getName(),</span><br><span class=\"line\">                                    &quot;loadedPluginClass&quot;,</span><br><span class=\"line\">                                    Version.ANDROID_GRADLE_PLUGIN_VERSION,</span><br><span class=\"line\">                                    new TypeToken&lt;AtomicReference&lt;Class&lt;?&gt;&gt;&gt;() &#123;&#125;,</span><br><span class=\"line\">                                    () -&gt; new AtomicReference&lt;&gt;(null))</span><br><span class=\"line\">                            .get());</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void initialize(</span><br><span class=\"line\">        </span><br><span class=\"line\">        // BuildSessionImpl 提供了一整次 gradle 构建结束的监听 (例如一次命令行输入全部执行完成)。</span><br><span class=\"line\">        // 这里注册监听，当一整次构建结束之后，重置 projectToPluginVersionMap 和 loadedPluginClass。</span><br><span class=\"line\">        // 由于 gradle 有进程重用机制，多次构建可能发生在同一个进程；只需要保证在一整次构建中，版本一致性，所以构建完成后重置状态。</span><br><span class=\"line\">        BuildSessionImpl.getSingleton().initialize(project.getGradle());</span><br><span class=\"line\">        BuildSessionImpl.getSingleton()</span><br><span class=\"line\">                .executeOnceWhenBuildFinished(</span><br><span class=\"line\">                        PluginInitializer.class.getName(),</span><br><span class=\"line\">                        &quot;resetPluginCheckVariables&quot;,</span><br><span class=\"line\">                        () -&gt; &#123;</span><br><span class=\"line\">                            projectToPluginVersionMap.clear();</span><br><span class=\"line\">                            loadedPluginClass.set(null);</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 向 projectToPluginVersionMap 中写入当前工程对象和现在所执行的 android plugin 版本，如果 Map 中有两个不一样的 android plugin 版本，那么就抛出异常。</span><br><span class=\"line\">        synchronized (projectToPluginVersionMap) &#123;</span><br><span class=\"line\">            verifySamePluginVersion(</span><br><span class=\"line\">                    projectToPluginVersionMap, project, Version.ANDROID_GRADLE_PLUGIN_VERSION);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 向 loadedPluginClass 写入现在所执行的 android plugin 的 AndroidBasePlugin.class 对象，如果 loadedPluginClass 保存了和写入的 AndroidBasePlugin.class 对象不同的值，则抛出异常。</span><br><span class=\"line\">        // 配置 &#123;@GradleProperties &#x27;android.enableBuildScriptClasspathCheck&#x27;&#125; = false 来屏蔽这个检查。</span><br><span class=\"line\">        verifyPluginLoadedOnce(</span><br><span class=\"line\">                loadedPluginClass,</span><br><span class=\"line\">                AndroidBasePlugin.class,</span><br><span class=\"line\">                projectOptions.get(BooleanOption.ENABLE_BUILDSCRIPT_CLASSPATH_CHECK));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"BasePlugin-apply-gt-configureProject\"><a href=\"#BasePlugin-apply-gt-configureProject\" class=\"headerlink\" title=\"BasePlugin::apply() &gt; configureProject()\"></a><code>BasePlugin::apply() &gt; configureProject()</code></h3><p><code>configureProject()</code> 做了一些零散的不易归类初始化任务，这些任务中需要进一步分析的也不多。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void configureProject() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ExtraModelInfo 存储一些不易归类的 extra 信息 ：</span><br><span class=\"line\">    // * 存储构建过程中的检测到的 waring 和 error 信息，并输出这些信息, 根据这次构建是由 ide 触发的还是开发者触发的，信息可能以 &#x27;MACHINE_PARSABLE&#x27; 或 &#x27;HUMAN_READABLE&#x27; 两种格式输出。</span><br><span class=\"line\">    // TODO: 在后续源码分析中，补充在 ExtraModelInfo 其他信息的作用</span><br><span class=\"line\">    extraModelInfo = new ExtraModelInfo(projectOptions, project.getLogger());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 检查当前 gradle 版本不低于 当前运行的 android plugin 所要求的最低版本，否则抛出异常。</span><br><span class=\"line\">    // 配置 &#123;@GradleProperties &#x27;android.overrideVersionCheck&#x27;&#125; = true，可以仅输出 waring 信息不抛出异常。</span><br><span class=\"line\">    checkGradleVersion();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // SdkHandler 是 android sdk 信息的封装类，在构造方法中会寻找 andorid sdk 的路径。</span><br><span class=\"line\">    sdkHandler = new SdkHandler(project, getLogger());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当 &#123;@GradleProperties &#x27;android.builder.sdkDownload&#x27;&#125; = true、并且当前构建不是由 IDE 触发、并且当前构建的 gradle 建参数不包含 &#x27;--offline&#x27; 这个三个条件成立时：</span><br><span class=\"line\">    // SdkHandler 会在使用 android sdk 中工具时自动下载，这样即使不安装 android sdk 也能完成 android 工程构建。</span><br><span class=\"line\">    //  SdkLibData 时下载信息的抽象，包括 Downloader 对象和 SettingsController 的实现。</span><br><span class=\"line\">    // SettingsController 是注入下载配置的接口，默认实现中包括了指定使用 https、从&#123;@GradleProperties &#x27;android.sdk.channel&#x27;&#125; 中获取下载channel、从 System.getProperties() 获取网络代理信息等。</span><br><span class=\"line\">    if (!project.getGradle().getStartParameter().isOffline() </span><br><span class=\"line\">                &amp;&amp; projectOptions.get(BooleanOption.ENABLE_SDK_DOWNLOAD)</span><br><span class=\"line\">                &amp;&amp; !projectOptions.get(BooleanOption.IDE_INVOKED_FROM_IDE)) &#123;</span><br><span class=\"line\">            SdkLibData sdkLibData = SdkLibData.download(getDownloader(), getSettingsController());</span><br><span class=\"line\">            sdkHandler.setSdkLibData(sdkLibData);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    // AndroidBuilder 是构建 toolchain 的接口类。</span><br><span class=\"line\">    androidBuilder = new AndroidBuilder(</span><br><span class=\"line\">                project == project.getRootProject() ? project.getName() : project.getPath(),</span><br><span class=\"line\">                creator,</span><br><span class=\"line\">                new GradleProcessExecutor(project),</span><br><span class=\"line\">                new GradleJavaProcessExecutor(project),</span><br><span class=\"line\">                extraModelInfo,</span><br><span class=\"line\">                getLogger(),</span><br><span class=\"line\">                isVerbose());</span><br><span class=\"line\"></span><br><span class=\"line\">    // @DataBinding 初始化 DataBindingBuilder。</span><br><span class=\"line\">    [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // apply 了 JavaBasePlugin 插件和 JacocoPlugin 插件</span><br><span class=\"line\">    project.getPlugins().apply(JavaBasePlugin.class);</span><br><span class=\"line\">    project.getPlugins().apply(JacocoPlugin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 替换 &#123;@Task assemble&#125; 的描述，&#123;@Task assemble&#125; 在 apply JavaBasePlugin.class 之后创建。</span><br><span class=\"line\">    project.getTasks().getByName(&quot;assemble&quot;)</span><br><span class=\"line\">        .setDescription(&quot;Assembles all variants of all applications and secondary packages.&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    project.getGradle().addBuildListener(</span><br><span class=\"line\">        buildFinished(BuildResult buildResult) -&gt; &#123;</span><br><span class=\"line\">            // 构建结束后一些 release 工作。</span><br><span class=\"line\">            ExecutorSingleton.shutdown();</span><br><span class=\"line\">            sdkHandler.unload();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 清理 PreDexCache 中的缓存，并将其写在 &#x27;&#123;@File gradleProjectRoot&#125;/build/intermediates/dex-cache/cache.xml&#x27; 文件</span><br><span class=\"line\">            // TOOD : 分析 Dex 过程时在回来看这里。</span><br><span class=\"line\">            PreDexCache.getCache().clear(</span><br><span class=\"line\">                FileUtils.join(</span><br><span class=\"line\">                    project.getRootProject().getBuildDir(),</span><br><span class=\"line\">                    FD_INTERMEDIATES,</span><br><span class=\"line\">                    &quot;dex-cache&quot;,</span><br><span class=\"line\">                    &quot;cache.xml&quot;),</span><br><span class=\"line\">                getLogger());</span><br><span class=\"line\">                Main.clearInternTables();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    // 任务树生成后进行检查：如果任务树中存在 DexTransform 类型的任务，</span><br><span class=\"line\">    // PreDexCache 从 &#x27;&#123;@File gradleProjectRoot&#125;/build/intermediates/dex-cache/cache.xml&#x27; 文件加载缓存。</span><br><span class=\"line\">    // TOOD : 分析 Dex 过程时在回来看这里。</span><br><span class=\"line\">    project.getGradle().getTaskGraph().addTaskExecutionGraphListener(</span><br><span class=\"line\">        (taskGraph) -&gt; &#123;</span><br><span class=\"line\">            for (Task task : taskGraph.getAllTasks()) &#123;</span><br><span class=\"line\">                if (task instanceof TransformTask) &#123;</span><br><span class=\"line\">                    Transform transform = ((TransformTask) task).getTransform();</span><br><span class=\"line\">                    if (transform instanceof DexTransform) &#123;</span><br><span class=\"line\">                        PreDexCache.getCache().load(</span><br><span class=\"line\">                            FileUtils.join(</span><br><span class=\"line\">                                project.getRootProject().getBuildDir(),</span><br><span class=\"line\">                                FD_INTERMEDIATES,</span><br><span class=\"line\">                                dex-cache&quot;,</span><br><span class=\"line\">                                &quot;cache.xml&quot;));</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"SdkHandler-寻找-android-sdk-路径\"><a href=\"#SdkHandler-寻找-android-sdk-路径\" class=\"headerlink\" title=\"SdkHandler 寻找 android sdk 路径\"></a><code>SdkHandler</code> 寻找 android sdk 路径</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SdkHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public SdkHandler(@NonNull Project project,</span><br><span class=\"line\">                      @NonNull ILogger logger) &#123;</span><br><span class=\"line\">        this.logger = logger;</span><br><span class=\"line\">        findLocation(project);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void findLocation(@NonNull Project project) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //@Test </span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //读取 &#x27;&#123;@File gradleProjectRoot&#125;/local.properties&#x27;</span><br><span class=\"line\">        File rootDir = project.getRootDir();</span><br><span class=\"line\">        File localProperties = new File(rootDir, FN_LOCAL_PROPERTIES);</span><br><span class=\"line\">        Properties properties = new Properties();</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 按照如下优先级寻找 android sdk 路径：</span><br><span class=\"line\">        // local.properties 的 &#x27;sdk.dir&#x27; 属性 &gt; local.properties 的 &#x27;android.dir&#x27; 属性 &gt; </span><br><span class=\"line\">        // ANDROID_HOME 环境变量 &gt; android.home 环境变量。</span><br><span class=\"line\">        Pair&lt;File, Boolean&gt; sdkLocation = findSdkLocation(properties, rootDir);</span><br><span class=\"line\">        sdkFolder = sdkLocation.getFirst();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // isRegularSdk 的作用见下面 getSdkLoader() 方法前</span><br><span class=\"line\">        isRegularSdk = sdkLocation.getSecond();</span><br><span class=\"line\"></span><br><span class=\"line\">        //按照如下优先级寻找 ndk路径</span><br><span class=\"line\">        // local.properties 的 &#x27;ndk.dir&#x27; 属性 &gt; ANDROID_NDK_HOME 环境变量</span><br><span class=\"line\">        // &gt; &#x27;&#123;@File sdkFolder&#125;/ndk-bundle&#x27;</span><br><span class=\"line\">        ndkFolder = NdkHandler.findNdkDirectory(properties, rootDir);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Ndk 从 local.properties 中读出 &#x27;cmake.dir&#x27;，并赋值给 cmakePathInLocalProp 属性(File 类型)。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 仅当 android sdk 路径是由 local.properties 的 &#x27;android.dir&#x27; 属性定义时，isRegularSdk 为 false。</span><br><span class=\"line\">    // 这时认为当前构建使用 &quot;Platform-based&quot; 的 android sdk，其文件布局与开发使用的 android sdk 不同，</span><br><span class=\"line\">    // 所以在解析 android sdk 文件布局时使用 PlatformLoader 而非 DefaultSdkLoader。</span><br><span class=\"line\">    // 在依赖 android 源码中的 android sdk 而非发布版的 android sdk 会出现这种情况。</span><br><span class=\"line\">    public synchronized SdkLoader getSdkLoader() &#123;</span><br><span class=\"line\">        if (sdkLoader == null) &#123;</span><br><span class=\"line\">            if (isRegularSdk) &#123;</span><br><span class=\"line\">                sdkLoader = DefaultSdkLoader.getLoader(sdkFolder);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                sdkLoader = PlatformLoader.getLoader(sdkFolder);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sdkLoader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BasePlugin-apply-gt-configureExtension\"><a href=\"#BasePlugin-apply-gt-configureExtension\" class=\"headerlink\" title=\"BasePlugin::apply() &gt; configureExtension()\"></a><code>BasePlugin::apply() &gt; configureExtension()</code></h3><ul>\n<li>创建了 extension 对象并将其注册到 gradle project 中，extension 对象包含 android plugin 和用户构建脚本之间的所有 api 对象，这些 api 对象定义的 android plugin api 并承载了构建脚本中的开发者配置。</li>\n<li>初始化 project 模型和任务树有关的管理类：TaskManager、VariantManager、VariantFactory，这3个管理类可以说是配置阶段的核心；这些管理类通过注册 api 对象监听事件，收集开发者构建脚本中的配置信息。</li>\n<li>创建 FileCache、GlobalScope 等一些上下文对象。</li>\n</ul>\n<p>完成 <code>configureExtension()</code> 执行后 android plugin 就已经做好执行构建脚本，获取配置信息的准备了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void configureExtension() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建了承载 BuildType、ProductFlavor、SigningConfig 的3个容器。</span><br><span class=\"line\">    // 这3个容器作为创建 extension 的参数，通过 extension 链接到编译脚步，收集开发者配置。</span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;BuildType&gt; buildTypeContainer =</span><br><span class=\"line\">            project.container(BuildType.class,</span><br><span class=\"line\">                    new BuildTypeFactory(instantiator, project, extraModelInfo));</span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavorContainer =</span><br><span class=\"line\">            project.container(ProductFlavor.class,</span><br><span class=\"line\">                    new ProductFlavorFactory(</span><br><span class=\"line\">                            instantiator, project, project.getLogger(), extraModelInfo));</span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigContainer =</span><br><span class=\"line\">            project.container(SigningConfig.class, new SigningConfigFactory(instantiator));</span><br><span class=\"line\"></span><br><span class=\"line\">    // TODO：BaseVariantOutput </span><br><span class=\"line\">    final NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs =</span><br><span class=\"line\">            project.container(BaseVariantOutput.class);</span><br><span class=\"line\">    project.getExtensions().add(&quot;buildOutputs&quot;, buildOutputs);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 extension 对象，可以看到之前创建的4个容器最终由 extension 对象持有。</span><br><span class=\"line\">    // 创建 extension 的过程会完成以下工作：</span><br><span class=\"line\">    // * 完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；</span><br><span class=\"line\">    // * 通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；</span><br><span class=\"line\">    // *为 android plugin api 对象添加默认配置。</span><br><span class=\"line\">    extension =</span><br><span class=\"line\">            createExtension(</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    instantiator,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    sdkHandler,</span><br><span class=\"line\">                    buildTypeContainer,</span><br><span class=\"line\">                    productFlavorContainer,</span><br><span class=\"line\">                    signingConfigContainer,</span><br><span class=\"line\">                    buildOutputs,</span><br><span class=\"line\">                    extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    // @Ndk 创建 NdkHandler。</span><br><span class=\"line\">    [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 FileCache 和 GlobalScope 对象，FileCache 被 GlobalScope 对象持有。</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 当 &#x27;&#123;@GradleProperties android.enableBuildCache&#125;&#x27; = true 时创建 FileCache。</span><br><span class=\"line\">    // FileCache 默认缓存路径是 &#x27;&#123;@File androidHomeDir&#125;/build-cache&#x27;，可以通过 &#x27;&#123;@GradleProperties android.buildCacheDir&#125;&#x27; 自定义缓存路径。</span><br><span class=\"line\">    // &#123;@File androidHomeDir&#125; 是选取规则在见后面设置 debug.keystore 的代码分析。</span><br><span class=\"line\">    // FileCache 的实际作用留到它被使用时再分析。</span><br><span class=\"line\">    @Nullable</span><br><span class=\"line\">    FileCache buildCache = BuildCacheUtils.createBuildCacheIfEnabled(project, projectOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">    // GlobalScope 对象是当前 android 工程的上下文对象，它只负责持有对象，方便获取。</span><br><span class=\"line\">    // GlobalScope 对象 之后分别被 TaskManager、VariantManager、VariantFactory 3个对象持有。</span><br><span class=\"line\">    GlobalScope globalScope =</span><br><span class=\"line\">            new GlobalScope(</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    sdkHandler,</span><br><span class=\"line\">                    ndkHandler,</span><br><span class=\"line\">                    registry,</span><br><span class=\"line\">                    buildCache);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 TaskManager、VariantManager、VariantFactory 3个管理类。</span><br><span class=\"line\">    variantFactory = createVariantFactory(globalScope, instantiator, androidBuilder, extension);</span><br><span class=\"line\">    taskManager =</span><br><span class=\"line\">            createTaskManager(</span><br><span class=\"line\">                    globalScope,</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    dataBindingBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    sdkHandler,</span><br><span class=\"line\">                    ndkHandler,</span><br><span class=\"line\">                    registry,</span><br><span class=\"line\">                    threadRecorder);</span><br><span class=\"line\">    variantManager =</span><br><span class=\"line\">            new VariantManager(</span><br><span class=\"line\">                    globalScope,</span><br><span class=\"line\">                    project,</span><br><span class=\"line\">                    projectOptions,</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    variantFactory,</span><br><span class=\"line\">                    taskManager,</span><br><span class=\"line\">                    threadRecorder);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 Add 事件监听。</span><br><span class=\"line\">    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class=\"line\">    buildTypeContainer.whenObjectAdded(</span><br><span class=\"line\">            buildType -&gt; &#123;</span><br><span class=\"line\">                SigningConfig signingConfig =</span><br><span class=\"line\">                        signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class=\"line\">                buildType.init(signingConfig);</span><br><span class=\"line\">                variantManager.addBuildType(buildType);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为 BuildType、ProductFlavor、SigningConfig 的3个容器注册 remove 事件监听。</span><br><span class=\"line\">    // 禁止开发者对这三个配置做 remove 操作，如果发生就抛出异常。</span><br><span class=\"line\">    signingConfigContainer.whenObjectRemoved(</span><br><span class=\"line\">            new UnsupportedAction(&quot;Removing signingConfigs is not supported.&quot;));</span><br><span class=\"line\">    buildTypeContainer.whenObjectRemoved(</span><br><span class=\"line\">            new UnsupportedAction(&quot;Removing build types is not supported.&quot;));</span><br><span class=\"line\">    productFlavorContainer.whenObjectRemoved(</span><br><span class=\"line\">            new UnsupportedAction(&quot;Removing product flavors is not supported.&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 向 BuildType、ProductFlavor、SigningConfig 3个容器创建 default 成员。</span><br><span class=\"line\">    // 大多数 VariantFactory 的实现，在这里创建了 &#x27;debug&#x27; SigningConfig、&#x27;debug&#x27; BuildType、&#x27;release&#x27; BuildType。</span><br><span class=\"line\">    variantFactory.createDefaultComponents(</span><br><span class=\"line\">            buildTypeContainer, productFlavorContainer, signingConfigContainer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BuildType、ProductFlavor、SigningConfig-容器内容构造\"><a href=\"#BuildType、ProductFlavor、SigningConfig-容器内容构造\" class=\"headerlink\" title=\"BuildType、ProductFlavor、SigningConfig 容器内容构造\"></a><code>BuildType</code>、<code>ProductFlavor</code>、<code>SigningConfig</code> 容器内容构造</h4><p>这3个 NamedDomainObjectContainer<T> 类型的容器，在构造时传入 NamedDomainObjectFactory<T> 提供容器内容对象的构造方法。<code>BuildType</code> 和 <code>ProductFlavor</code> 构造方法都直接调用了构造函数，只有 <code>SigningConfig</code> 做了特殊处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SigningConfigFactory implements NamedDomainObjectFactory&lt;SigningConfig&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    public SigningConfig create(@NonNull String name) &#123;</span><br><span class=\"line\">        SigningConfig signingConfig = instantiator.newInstance(SigningConfig.class, name);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果 SigningConfig 对象的名字是 &#x27;debug&#x27;，那么用 android 环境的 debug keystore 来初始化这个对象。</span><br><span class=\"line\">        // debug keystore 存放的位置在 &#x27;&#123;@File androidHomeDir&#125;/debug.keystore&#x27;；</span><br><span class=\"line\">        // debug keystore 配置：store pw -&gt; &#x27;android&#x27;，key alias -&gt; &#x27;AndroidDebugKey&#x27;，key pw -&gt; &#x27;android&#x27;。</span><br><span class=\"line\">        // &#123;@File androidHomeDir&#125; 为 &#x27;&#123;@File homeDir&#125;/.android&#x27; ，&#123;@File homeDir&#125; 按以下优先级寻找, ，没找到就会抛异常：</span><br><span class=\"line\">        // ANDROID_SDK_HOME 环境变量或系统属性 &gt; TEST_TMPDIR 环境变量 &gt; user.home 系统属性 &gt; HOME 环境变量 </span><br><span class=\"line\">        if (BuilderConstants.DEBUG.equals(name)) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                signingConfig.initWith(</span><br><span class=\"line\">                        DefaultSigningConfig.debugSigningConfig(</span><br><span class=\"line\">                                new File(KeystoreHelper.defaultDebugKeystoreLocation())));</span><br><span class=\"line\">            &#125; catch (AndroidLocation.AndroidLocationException e) &#123;</span><br><span class=\"line\">                throw new BuildException(&quot;Failed to get default debug keystore location.&quot;, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return signingConfig;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BuildType、ProductFlavor、SigningConfig-Add-操作监听\"><a href=\"#BuildType、ProductFlavor、SigningConfig-Add-操作监听\" class=\"headerlink\" title=\"BuildType、ProductFlavor、SigningConfig Add 操作监听\"></a><code>BuildType</code>、<code>ProductFlavor</code>、<code>SigningConfig</code> Add 操作监听</h3><p>总体来说，VariantManager 监听了 <code>BuildType</code>、<code>ProductFlavor</code>、<code>SigningConfig</code> 对象的创建操作，并将被创建的对象分别保存在 map 容器中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void configureExtension() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // VariantManager.addSigningConfig() 仅仅将 SigningConfig 对象加入了 VariantManager 的 map 容器持有。</span><br><span class=\"line\">    signingConfigContainer.whenObjectAdded(variantManager::addSigningConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里看起来好像用 &#x27;debug&#x27; SigningConfig 初始化了所有 BuildType 对象。</span><br><span class=\"line\">    // 实际上 BuildType.init(SigningConfig) 中有判断，只有 BuildType 的名字也是 &#x27;debug&#x27; 时才会用调用 BuildType.setSigningConfig(SigningConfig)。</span><br><span class=\"line\">    buildTypeContainer.whenObjectAdded(</span><br><span class=\"line\">            buildType -&gt; &#123;</span><br><span class=\"line\">                SigningConfig signingConfig =</span><br><span class=\"line\">                        signingConfigContainer.findByName(BuilderConstants.DEBUG);</span><br><span class=\"line\">                buildType.init(signingConfig);</span><br><span class=\"line\">                variantManager.addBuildType(buildType);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    productFlavorContainer.whenObjectAdded(variantManager::addProductFlavor);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class VariantManager implements VariantModel &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // BuildType 对象的加入引发 SourceSet 和 BuildTypeData 对象的创建。</span><br><span class=\"line\">    public void addBuildType(@NonNull CoreBuildType buildType) &#123;</span><br><span class=\"line\">        String name = buildType.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 检查 BuildType 名字的合法性，名字不能以 &#x27;androidTest&#x27; 或 &#x27;test&#x27; 开头；名字不能为 &#x27;lint&#x27;。</span><br><span class=\"line\">        checkName(name, &quot;BuildType&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // BuildType 名字不能和任何 ProductFlavor 相同。</span><br><span class=\"line\">        if (productFlavors.containsKey(name)) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;BuildType names cannot collide with ProductFlavor names&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建和 BuildType 同名的 SourceSet。</span><br><span class=\"line\">        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(name);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test，创建名为 &#x27;&#123;$BuildTypeName&#125;AndroidTest&#x27; 和 &#x27;&#123;$BuildTypeName&#125;UnitTest&#x27; 的 SourceSet。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 BuildTypeData，其持有 BuildType 对象和 3个刚刚创建 SourceSet。</span><br><span class=\"line\">        BuildTypeData buildTypeData =</span><br><span class=\"line\">                new BuildTypeData(</span><br><span class=\"line\">                        buildType, project, mainSourceSet, androidTestSourceSet, unitTestSourceSet);</span><br><span class=\"line\">        buildTypes.put(name, buildTypeData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public void addProductFlavor(@NonNull CoreProductFlavor productFlavor) &#123;</span><br><span class=\"line\">        String name = productFlavor.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 检查 BuildType 名字的合法性，名字不能以 &#x27;androidTest&#x27; 或 &#x27;test&#x27; 开头；名字不能为 &#x27;lint&#x27;。</span><br><span class=\"line\">        checkName(name, &quot;ProductFlavor&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // ProductFlavor 名字不能和任何 BuildType 相同。</span><br><span class=\"line\">        if (buildTypes.containsKey(name)) &#123;</span><br><span class=\"line\">            throw new RuntimeException(&quot;ProductFlavor names cannot collide with BuildType names&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建和 ProductFlavor 同名的 SourceSet。</span><br><span class=\"line\">        DefaultAndroidSourceSet mainSourceSet = (DefaultAndroidSourceSet) extension.getSourceSets().maybeCreate(</span><br><span class=\"line\">                productFlavor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test，创建名为 &#x27;&#123;$BuildTypeName&#125;AndroidTest&#x27; 和 &#x27;&#123;$BuildTypeName&#125;UnitTest&#x27; 的 SourceSet。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 ProductFlavorData，其持有 ProductFlavor 对象和 3个刚刚创建 SourceSet。</span><br><span class=\"line\">        ProductFlavorData&lt;CoreProductFlavor&gt; productFlavorData =</span><br><span class=\"line\">                new ProductFlavorData&lt;&gt;(</span><br><span class=\"line\">                        productFlavor,</span><br><span class=\"line\">                        mainSourceSet,</span><br><span class=\"line\">                        androidTestSourceSet,</span><br><span class=\"line\">                        unitTestSourceSet,</span><br><span class=\"line\">                        project);</span><br><span class=\"line\">        productFlavors.put(productFlavor.getName(), productFlavorData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"BuildTypeData、ProductFlavorData-的创建\"><a href=\"#BuildTypeData、ProductFlavorData-的创建\" class=\"headerlink\" title=\"BuildTypeData、ProductFlavorData 的创建\"></a><code>BuildTypeData</code>、<code>ProductFlavorData</code> 的创建</h4><p>BuildTypeData、ProductFlavorData 的基类均为 VariantDimensionData，在导出类中没有特殊操作，仅仅额外持有了 BuildType 和 ProductFlavor 对象，生成任务树之后会额外持有 {@Task assemble{$BuildType}} 和 {@Task assemble{$ProductFlavor}} 的引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class VariantDimensionData &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private final DefaultAndroidSourceSet sourceSet;</span><br><span class=\"line\">    private final DefaultAndroidSourceSet androidTestSourceSet;</span><br><span class=\"line\">    private final DefaultAndroidSourceSet unitTestSourceSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    public VariantDimensionData(</span><br><span class=\"line\">            @NonNull DefaultAndroidSourceSet sourceSet,</span><br><span class=\"line\">            @Nullable DefaultAndroidSourceSet androidTestSourceSet,</span><br><span class=\"line\">            @Nullable DefaultAndroidSourceSet unitTestSourceSet,</span><br><span class=\"line\">            @NonNull Project project) &#123;</span><br><span class=\"line\">        this.sourceSet = sourceSet;</span><br><span class=\"line\">        this.androidTestSourceSet = androidTestSourceSet;</span><br><span class=\"line\">        this.unitTestSourceSet = unitTestSourceSet;</span><br><span class=\"line\"></span><br><span class=\"line\">        final ConfigurationContainer configurations = project.getConfigurations();</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test </span><br><span class=\"line\">        // 让名为 &#x27;&#123;$VariantDimensionName&#125;AndroidTestImplementation&#x27; 和 &#x27;&#123;$VariantDimensionName&#125;UnitTestImplementation&#x27; 的 Configuration 继承 &#x27;&#123;$VariantDimensionName&#125;Implementation&#x27;</span><br><span class=\"line\">        // 让名为 &#x27;&#123;$VariantDimensionName&#125;AndroidTestRuntimeOnly&#x27; 和 &#x27;&#123;$VariantDimensionName&#125;UnitTestRuntimeOnly&#x27; 的 Configuration 继承 &#x27;&#123;$VariantDimensionName&#125;RuntimeOnly&#x27;</span><br><span class=\"line\">        if (androidTestSourceSet != null) &#123;</span><br><span class=\"line\">            makeTestExtendMain(sourceSet, androidTestSourceSet, configurations);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (unitTestSourceSet != null) &#123;</span><br><span class=\"line\">            makeTestExtendMain(sourceSet, unitTestSourceSet, configurations);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BasePlugin-configureExtension-gt-createExtension\"><a href=\"#BasePlugin-configureExtension-gt-createExtension\" class=\"headerlink\" title=\"BasePlugin::configureExtension() &gt; createExtension()\"></a><code>BasePlugin::configureExtension() &gt; createExtension()</code></h4><p><code>createExtension()</code> 是个抽象函数，不过实际上 BasePlugin 的各个实现类只是构造了不同的 BaseExtension 类的实现，没有在这个方法中做别的事情。<br>各个 BaseExtension 类的实现区别也很小，所以这里只会提到 BaseExtension 和 TestedExtension。</p>\n<p>BaseExtension<br>    -&gt; TestExtension<br>    -&gt; TestedExtension<br>        -&gt; AppExtension<br>        -&gt; LibraryExtension<br>            -&gt; FeatureExtension<br>    -&gt; InstantAppExtension </p>\n<p>在 BaseExtension 的构造函数中：</p>\n<ul>\n<li>完成 andorid plugin 所有 api 对象的创建 ( DebugConfig 对象、SourceSet 容器、AaptOptions 对象、DexOptions 对象等）；</li>\n<li>通过对 SourceSet 容器的监听调用 gradle api ，创建 Configuration 对象；</li>\n<li>为 android plugin api 对象添加少许默认配置。</li>\n</ul>\n<p><em>创建 Configuration 的过程使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class BaseExtension implements AndroidConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    BaseExtension(</span><br><span class=\"line\">            @NonNull final Project project,</span><br><span class=\"line\">            @NonNull final ProjectOptions projectOptions,</span><br><span class=\"line\">            @NonNull Instantiator instantiator,</span><br><span class=\"line\">            @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">            @NonNull SdkHandler sdkHandler,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypes,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavors,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigs,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">            @NonNull ExtraModelInfo extraModelInfo,</span><br><span class=\"line\">            final boolean publishPackage) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Simplify 保存构造函数传入的参数。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        logger = Logging.getLogger(this.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 DefaultConfig 对象，DefaultConfig 对象是一个名为 &#x27;main&#x27; 的特殊的 ProductFlavor，DefaultConfig 和 ProductFlavor 有共同的父类。</span><br><span class=\"line\">        defaultConfig =</span><br><span class=\"line\">                instantiator.newInstance(</span><br><span class=\"line\">                        DefaultConfig.class,</span><br><span class=\"line\">                        BuilderConstants.MAIN,</span><br><span class=\"line\">                        project,</span><br><span class=\"line\">                        instantiator,</span><br><span class=\"line\">                        project.getLogger(),</span><br><span class=\"line\">                        extraModelInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Simplify 创建各种 Options 类型对象，都用于描述 android plugin api 并承载编译脚本配置。</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 SourceSet 容器，容器中的使用 DefaultAndroidSourceSet 类构造。</span><br><span class=\"line\">        sourceSetsContainer =</span><br><span class=\"line\">                project.container(</span><br><span class=\"line\">                        AndroidSourceSet.class,</span><br><span class=\"line\">                        new AndroidSourceSetFactory(instantiator, project, publishPackage));</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        // 监听 SourceSet 容器的 Add 操作。</span><br><span class=\"line\">        // 当有新的 SoucreSet 加入容器之后，初始化 SourceSet 的默认布局，建与之相对应的 Configuration，设置被创建的 Configuration 之间的 extendsFrom 关系。</span><br><span class=\"line\">        // 这是段较长的 labor 代码，改为用伪代码分析</span><br><span class=\"line\">        sourceSetsContainer.whenObjectAdded() &#123;</span><br><span class=\"line\">            // @Pseudocode</span><br><span class=\"line\">            sourceSet -&gt; &#123;</span><br><span class=\"line\">                ConfigurationContainer configurations = project.getConfigurations();</span><br><span class=\"line\"></span><br><span class=\"line\">                String sourceSetName = sourceSet.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">                // 创建名为 &#x27;&#123;SouceSetName&#125;Api&#x27;、&#x27;&#123;SouceSetName&#125;Implementation&#x27;、</span><br><span class=\"line\">                // &#x27;&#123;SouceSetName&#125;RuntimeOnly&#x27;、&#x27;&#123;SouceSetName&#125;CompileOnly&#x27; 的 SourceSet。</span><br><span class=\"line\">                // 创建名为 &#x27;&#123;SouceSetName&#125;Compile&#x27;、&#x27;&#123;SouceSetName&#125;Provided&#x27; 的 SourceSet。</span><br><span class=\"line\">                // 在 App 工程中创建 &#x27;&#123;SouceSetName&#125;Apk&#x27;；在 Lib 工程中创建 &#x27;&#123;SouceSetName&#125;Publish&#x27;。</span><br><span class=\"line\">                // 对于名为 &#x27;main&#x27; 的 sourceSet 而言，创建 Configuration 的命名规则特殊处理，不加前缀。</span><br><span class=\"line\">                Configuration compile = createConfiguration(configurations, sourceSetName + &#x27;Compile&#x27;);</span><br><span class=\"line\">                if (&#123;in AppExtension&#125;) &#123;</span><br><span class=\"line\">                    Configuration apk = createConfiguration(configurations, sourceSetName + &#x27;Apk&#x27;);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    Configuration apk = createConfiguration(configurations, sourceSetName + &#x27;Publish&#x27;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Configuration provided = createConfiguration(configurations, sourceSetName + &#x27;Provided&#x27;);</span><br><span class=\"line\">                Configuration api = createConfiguration(configurations, sourceSetName + &#x27;Api&#x27;);</span><br><span class=\"line\">                Configuration implementation = createConfiguration(configurations, sourceSetName + &#x27;Implementation&#x27;);</span><br><span class=\"line\">                Configuration runtimeOnly = createConfiguration(configurations, sourceSetName + &#x27;RuntimeOnly&#x27;);</span><br><span class=\"line\">                Configuration compileOnly = createConfiguration(configurations, sourceSetName + &#x27;CompileOnly&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">                // compile、apk、provided 3个 Configuration 属于 Depercated 设定。</span><br><span class=\"line\">                // 当这3个 Configuration 有任何 dependency 增加时输出 warning。</span><br><span class=\"line\">                compile.getAllDependencies().whenObjectAdded(</span><br><span class=\"line\">                    new DeprecatedConfigurationAction());</span><br><span class=\"line\">                apk.getAllDependencies().whenObjectAdded(</span><br><span class=\"line\">                    new DeprecatedConfigurationAction());</span><br><span class=\"line\">                provided.getAllDependencies().whenObjectAdded(</span><br><span class=\"line\">                    new DeprecatedConfigurationAction());</span><br><span class=\"line\"></span><br><span class=\"line\">                // 设置 extendsFrom 关系。</span><br><span class=\"line\">                api.extendsFrom(compile);</span><br><span class=\"line\">                implementation.extendsFrom(api);</span><br><span class=\"line\">                runtimeOnly.extendsFrom(apk);</span><br><span class=\"line\">                compileOnly.extendsFrom(provided);</span><br><span class=\"line\"></span><br><span class=\"line\">                // @Wear 创建名为 &#x27;&#123;SouceSetName&#125;WearApp&#x27; 的 Configuration。</span><br><span class=\"line\">                [+] &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                // &#x27;&#123;SouceSetName&#125;AnnotationProcessor&#x27; 的 Configuration。</span><br><span class=\"line\">                // 用于做 apt。</span><br><span class=\"line\">                createConfiguration(configurations, sourceSetName + &#x27;AnnotationProcessor&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">                // 设置 sourceSet 的默认布局：</span><br><span class=\"line\">                // java -&gt; &#x27;src/&#123;SouceSetName&#125;/java&#x27;</span><br><span class=\"line\">                // javaResources -&gt; &#x27;src/&#123;SouceSetName&#125;/resources&#x27;</span><br><span class=\"line\">                // res -&gt; &#x27;src/&#123;SouceSetName&#125;/res&#x27;</span><br><span class=\"line\">                // assets -&gt; &#x27;src/&#123;SouceSetName&#125;/assets&#x27;</span><br><span class=\"line\">                // manifest -&gt; &#x27;src/&#123;SouceSetName&#125;/AndroidManifest.xml&#x27;</span><br><span class=\"line\">                // aidl -&gt; &#x27;src/&#123;SouceSetName&#125;/aidl&#x27;</span><br><span class=\"line\">                // renderscript -&gt; &#x27;src/&#123;SouceSetName&#125;/rs&#x27;</span><br><span class=\"line\">                // jni -&gt; &#x27;src/&#123;SouceSetName&#125;/jni&#x27;</span><br><span class=\"line\">                // jniLibs -&gt; &#x27;src/&#123;SouceSetName&#125;/jniLibs&#x27;</span><br><span class=\"line\">                // shaders -&gt; &#x27;src/&#123;SouceSetName&#125;/shaders&#x27;</span><br><span class=\"line\">                sourceSet.setRoot(String.format(&quot;src/%s&quot;, sourceSet.getName()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test 创建名为 &#x27;androidTestUtil&#x27; 的 Configuration</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 创建名为 &#x27;main&#x27; 的 SourceSet。</span><br><span class=\"line\">        sourceSetsContainer.create(defaultConfig.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 设置一些默认的编译脚本配置。</span><br><span class=\"line\">        // 设置默认的 buildTools Revision，如果开发者没有在编译脚本中指定，就使用默认版本。不同版本的 android plugin 定一个默认 buildTools 版本不同。</span><br><span class=\"line\">        buildToolsRevision = AndroidBuilder.DEFAULT_BUILD_TOOLS_REVISION;</span><br><span class=\"line\">        // 这个函数会对 DefaultConfig 对象做一些有关矢量图的配置。 </span><br><span class=\"line\">        setDefaultConfigValues();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 TestedExtension 的构造函数中创建了名为 ‘androidTest’ 和 ‘test’ 的 SourceSet，与 ‘main’ SourceSet 对应是默认存在基础 SourceSet。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// TestedExtension 是 AppExtension、LibraryExtension、FeatureExtension 的父类。</span><br><span class=\"line\">public abstract class TestedExtension extends BaseExtension implements TestedAndroidConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public TestedExtension(</span><br><span class=\"line\">            @NonNull Project project,</span><br><span class=\"line\">            @NonNull ProjectOptions projectOptions,</span><br><span class=\"line\">            @NonNull Instantiator instantiator,</span><br><span class=\"line\">            @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">            @NonNull SdkHandler sdkHandler,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BuildType&gt; buildTypes,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;ProductFlavor&gt; productFlavors,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;SigningConfig&gt; signingConfigs,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;BaseVariantOutput&gt; buildOutputs,</span><br><span class=\"line\">            @NonNull ExtraModelInfo extraModelInfo,</span><br><span class=\"line\">            boolean isDependency) &#123;</span><br><span class=\"line\">        super(</span><br><span class=\"line\">                project,</span><br><span class=\"line\">                projectOptions,</span><br><span class=\"line\">                instantiator,</span><br><span class=\"line\">                androidBuilder,</span><br><span class=\"line\">                sdkHandler,</span><br><span class=\"line\">                buildTypes,</span><br><span class=\"line\">                productFlavors,</span><br><span class=\"line\">                signingConfigs,</span><br><span class=\"line\">                buildOutputs,</span><br><span class=\"line\">                extraModelInfo,</span><br><span class=\"line\">                isDependency);</span><br><span class=\"line\">        // 创建名为 &#x27;androidTest&#x27; 和 &#x27;test&#x27; 的 SourceSet。</span><br><span class=\"line\">        getSourceSets().create(ANDROID_TEST.getPrefix());</span><br><span class=\"line\">        getSourceSets().create(UNIT_TEST.getPrefix());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造-TaskManager、VariantManager、VariantFactory\"><a href=\"#构造-TaskManager、VariantManager、VariantFactory\" class=\"headerlink\" title=\"构造 TaskManager、VariantManager、VariantFactory\"></a>构造 <code>TaskManager</code>、<code>VariantManager</code>、<code>VariantFactory</code></h4><p>TaskManager 通过 <code>createTaskManager()</code> 方法创建，VariantFactory 通过 <code>createVariantFactory</code> 方法创建。这两个方法均为抽象方法，在各种 plugin 的实现中，仅仅是调用了各种 TaskManager 和 VariantFactory 实现的构造函数，并无额外的代码。</p>\n<p>VariantManager 的构造函数中针对 DebugConfig 对象(DebugConfig 对象在 BaseExtension 构造时被创建)做了一些处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class VariantManager implements VariantModel &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public VariantManager(</span><br><span class=\"line\">            @NonNull GlobalScope globalScope,</span><br><span class=\"line\">            @NonNull Project project,</span><br><span class=\"line\">            @NonNull ProjectOptions projectOptions,</span><br><span class=\"line\">            @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">            @NonNull AndroidConfig extension,</span><br><span class=\"line\">            @NonNull VariantFactory variantFactory,</span><br><span class=\"line\">            @NonNull TaskManager taskManager,</span><br><span class=\"line\">            @NonNull Recorder recorder) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        DefaultAndroidSourceSet mainSourceSet =</span><br><span class=\"line\">                (DefaultAndroidSourceSet) extension.getSourceSets().getByName(extension.getDefaultConfig().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        DefaultAndroidSourceSet androidTestSourceSet = null;</span><br><span class=\"line\">        DefaultAndroidSourceSet unitTestSourceSet = null;</span><br><span class=\"line\">        if (variantFactory.hasTestScope()) &#123;</span><br><span class=\"line\">            androidTestSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) extension.getSourceSets()</span><br><span class=\"line\">                            .getByName(ANDROID_TEST.getPrefix());</span><br><span class=\"line\">            unitTestSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) extension.getSourceSets()</span><br><span class=\"line\">                            .getByName(UNIT_TEST.getPrefix());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 使用 DebugConfig 对象，&#x27;main&#x27;、&#x27;androidTest&#x27;、&#x27;test&#x27; 3个 SourceSet，</span><br><span class=\"line\">        // 创建了 defaultConfigData 对象。</span><br><span class=\"line\">        // &#x27;main&#x27;、&#x27;androidTest&#x27;、&#x27;test&#x27; 3个 SourceSet 都是在 extension 中直接创建的，而不是由 BuildType 或 ProductFlavor 触发生成的。</span><br><span class=\"line\">        // 正如 DebugConfig 对象是一个特殊的 ProductFlavor，defaultConfigData 引用也持有了一个特殊的 ProductFlavorData。</span><br><span class=\"line\"></span><br><span class=\"line\">        this.defaultConfigData =</span><br><span class=\"line\">                new ProductFlavorData&lt;&gt;(</span><br><span class=\"line\">                        extension.getDefaultConfig(),</span><br><span class=\"line\">                        mainSourceSet,</span><br><span class=\"line\">                        androidTestSourceSet,</span><br><span class=\"line\">                        unitTestSourceSet,</span><br><span class=\"line\">                        project);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"BasePlugin-apply-gt-createTasks\"><a href=\"#BasePlugin-apply-gt-createTasks\" class=\"headerlink\" title=\"BasePlugin::apply() &gt; createTasks()\"></a>BasePlugin::apply() &gt; createTasks()</h3><p>运行到这里时，创建管理类、监听链建立、设置默认配置布局这些工作都完成了，终于要创建 gradle task 了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void createTasks() &#123;</span><br><span class=\"line\">    taskManager.createTasksBeforeEvaluate(</span><br><span class=\"line\">        new TaskContainerAdaptor(project.getTasks())));</span><br><span class=\"line\"></span><br><span class=\"line\">    project.afterEvaluate(</span><br><span class=\"line\">        project -&gt;</span><br><span class=\"line\">            () -&gt; createAndroidTasks(false);</span><br></pre></td></tr></table></figure>\n<p><code>createTasks()</code> 将创建 gradle task 的工作分为两部分，一部分在 evaluate 开始之前，用于创建不构建脚本配置影响的任务；另一部分在 evaluate 结束之后，这部分创建那些的任务取决于构建脚本配置。</p>\n<h4 id=\"TaskManager-createTasksBeforeEvaluate\"><a href=\"#TaskManager-createTasksBeforeEvaluate\" class=\"headerlink\" title=\"TaskManager::createTasksBeforeEvaluate()\"></a><code>TaskManager::createTasksBeforeEvaluate()</code></h4><p>TaskManager 的绝大部分实没有扩展 <code>createTasksBeforeEvaluate()</code> (只有 InstantAppTaskManager 创建了多创建了一个 gradle task)，所以对于各类 android plugin 在这里创建的任务都是相同的。</p>\n<p>在这个方法中创建了一些 Anchor 任务（没有实际内容，仅作为上游节点使用），和一些独立任务例如和 Lint 和 单元测试相关的任务。</p>\n<p><em>下面代码使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TaskManager &#123;</span><br><span class=\"line\">    public void createTasksBeforeEvaluate(@NonNull TaskFactory tasks) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;uninstallAll&quot; task as anchor task. </span><br><span class=\"line\">            it &quot;Uninstall all applications.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;deviceCheck&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Runs all device checks using Device Providers and Test Servers.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;connectedCheck&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Runs all device checks on currently connected devices.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;preBuild&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Lead all build tasks.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;extractProguardFiles&quot; task as ExtractProguardFiles.class type.</span><br><span class=\"line\">            let &quot;extractProguardFiles&quot; dependsOn &quot;preBuild&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;sourceSets&quot; task as SourceSetsTask.class type.</span><br><span class=\"line\">            it &quot;Prints out all the source sets defined in this project.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;assembleAndroidTest&quot; task as anchor task.</span><br><span class=\"line\">            it &quot;Assembles all the Test applications.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;compileLint&quot; task as LintCompile.class type.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;lint&quot; task as LintGlobalTask.class type.</span><br><span class=\"line\">            it &quot;Runs lint on all variants.&quot;</span><br><span class=\"line\">            let &quot;check&quot; task (which from java plugin) dependsOn &quot;lint&quot; task.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;lintChecks&quot; configuration.</span><br><span class=\"line\">            it &quot;Configuration to apply external lint check jar&quot;</span><br><span class=\"line\">            GlobalScope will hold &quot;lintChecks&quot; configuration</span><br><span class=\"line\"></span><br><span class=\"line\">        if (&#123;@Field buildCache&#125; is not null) &#123;</span><br><span class=\"line\">            create &quot;cleanBuildCache&quot; task as CleanBuildCache.class type.</span><br><span class=\"line\">                it &quot;Deletes the build cache directory.&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;resolveConfigAttr&quot; task as ConfigAttrTask.class type.</span><br><span class=\"line\">            set resolveConfigAttr.resolvable = true</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;consumeConfigAttr&quot; task as ConfigAttrTask.class type.</span><br><span class=\"line\">            set consumeConfigAttr.consumable true.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"BasePlugin-createAndroidTasks\"><a href=\"#BasePlugin-createAndroidTasks\" class=\"headerlink\" title=\"BasePlugin::createAndroidTasks()\"></a><code>BasePlugin::createAndroidTasks()</code></h4><p><code>BasePlugin::createAndroidTasks()</code> 是创建 BuildVariant 和 Android 编译 task 的主流程，其中包含了一些检查和准备工作，创建 task 的代码主要包含在 <code>VariantManager::createAndroidTasks</code> 中。</p>\n<p>在这里主要做完成完成了：</p>\n<ul>\n<li>加载 Android Sdk 信息和添加 Android Sdk 提供的 Maven Repo</li>\n<li>创建 lint 相关的全局 task</li>\n<li>基于编译脚本输入创建 VariantData 对象</li>\n<li>基于 VariantData 信息创建编译 task</li>\n<li>完成 Variant 对象的创建。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final void createAndroidTasks(boolean force) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // @Simplify</span><br><span class=\"line\">    // 确保 buildToolsVersion 和 compileSdkVersion 被设置了。</span><br><span class=\"line\">    // 确保 JavaPlugin.class 没有被 apply 过。</span><br><span class=\"line\">    [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化 Android SDK Target 信息。 </span><br><span class=\"line\">    ensureTargetSetup();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (hasCreatedTasks) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hasCreatedTasks = true;</span><br><span class=\"line\">    // 禁止再修改 Extension 对象，编译脚本配置到此截止。</span><br><span class=\"line\">    extension.disableWrite();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 PrepareLintJar.class 类型的 &quot;prepareLintJar&quot; 任务。</span><br><span class=\"line\">    taskManager.configureCustomLintChecks(new TaskContainerAdaptor(project.getTasks()));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将 Android SDK 包含的 Repositories 加入的 Maven Repo 中，并将这些 Repositories 调整到 Maven Repo 列表的最前面。</span><br><span class=\"line\">    sdkHandler.addLocalRepositories(project);</span><br><span class=\"line\"></span><br><span class=\"line\">    // @DataBinding，如果使用了 DataBinding，则向已有 configuration 添加一些依赖。</span><br><span class=\"line\">    [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建 VariantData 对象和编译 Task。</span><br><span class=\"line\">    variantManager.createAndroidTasks();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 依照 VariantData 对象，创建 Variant 对象。</span><br><span class=\"line\">    ApiObjectFactory apiObjectFactory =</span><br><span class=\"line\">            new ApiObjectFactory(</span><br><span class=\"line\">                    androidBuilder,</span><br><span class=\"line\">                    extension,</span><br><span class=\"line\">                    variantFactory,</span><br><span class=\"line\">                    instantiator,</span><br><span class=\"line\">                    project.getObjects());</span><br><span class=\"line\">    for (VariantScope variantScope : variantManager.getVariantScopes()) &#123;</span><br><span class=\"line\">        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">        apiObjectFactory.create(variantData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 在 Variant 对象创建完成之后，创建全局 &quot;lint&quot; Task。</span><br><span class=\"line\">    taskManager.configureGlobalLintTask(variantManager.getVariantScopes());</span><br><span class=\"line\"></span><br><span class=\"line\">    // @IDE</span><br><span class=\"line\">    [+]&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureTargetSetup() &#123;    </span><br><span class=\"line\">    TargetInfo targetInfo = androidBuilder.getTargetInfo();</span><br><span class=\"line\">    if (targetInfo == null) &#123;</span><br><span class=\"line\">        if (extension.getCompileOptions() == null) &#123;</span><br><span class=\"line\">            throw new GradleException(&quot;Calling getBootClasspath before compileSdkVersion&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 Android SDK Target 信息，并将其设置到 androidBuiler 中。</span><br><span class=\"line\">        sdkHandler.initTarget(</span><br><span class=\"line\">                extension.getCompileSdkVersion(),</span><br><span class=\"line\">                extension.getBuildToolsRevision(),</span><br><span class=\"line\">                extension.getLibraryRequests(),</span><br><span class=\"line\">                androidBuilder,</span><br><span class=\"line\">                SdkHandler.useCachedSdk(projectOptions));</span><br><span class=\"line\">        // 确保 Android SDK 中没有安装了 platform tools，如果没有就下载它。</span><br><span class=\"line\">        sdkHandler.ensurePlatformToolsIsInstalled(extraModelInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SdkHandler::initTarget()</code> 中通过 SdkLoader 对象加载 Android Sdk 中的各种工具路径。<br>SdkLoader 的不同实现对应不同的 Android Sdk 文件布局，通常使用 <code>DefaultSdkLoader</code> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SdkHandler &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">     public void initTarget(</span><br><span class=\"line\">                @NonNull String targetHash,</span><br><span class=\"line\">                @NonNull Revision buildToolRevision,</span><br><span class=\"line\">                @NonNull Collection&lt;LibraryRequest&gt; usedLibraries,</span><br><span class=\"line\">                @NonNull AndroidBuilder androidBuilder,</span><br><span class=\"line\">                boolean useCachedVersion) &#123;</span><br><span class=\"line\">            //检查targetHash和buildToolRevision不为空，否则抛异常。</span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">            // 通过getSdkLoader()创建SdkLoader对象</span><br><span class=\"line\">            // 如果useCachedVersion &amp;&amp; sSdkLoader，那么重用旧的SdkLoader。</span><br><span class=\"line\">            synchronized (LOCK_FOR_SDK_HANDLER) &#123;</span><br><span class=\"line\">                if (useCachedVersion &amp;&amp; sSdkLoader == null) &#123;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    sSdkLoader = getSdkLoader();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sdkLoader = sSdkLoader;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 通过SdkLoader -&gt; AndroidSdkHandler获得SdkInfo.</span><br><span class=\"line\">            // SdkInfo包含annotations.jar和adb执行文件的位置。</span><br><span class=\"line\">            // annotations.jar位置：$&#123;sdkLocation&#125;/tools/support/annotations.jar</span><br><span class=\"line\">            // adb文件位置：$&#123;sdkLocation&#125;/platform-tools/adb</span><br><span class=\"line\">            SdkInfo sdkInfo = sdkLoader.getSdkInfo(logger);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 通过SdkLoader -&gt; AndroidSdkHandler获得TargetInfo</span><br><span class=\"line\">            // TargetInfo包括IAndroidTarget(包装target信息),BuildToolInfo(包装build-tools信息)。</span><br><span class=\"line\">            TargetInfo targetInfo = sdkLoader.getTargetInfo(</span><br><span class=\"line\">                    targetHash,</span><br><span class=\"line\">                    buildToolRevision,</span><br><span class=\"line\">                    logger,</span><br><span class=\"line\">                    sdkLibData);</span><br><span class=\"line\"></span><br><span class=\"line\">            androidBuilder.setSdkInfo(sdkInfo);</span><br><span class=\"line\">            androidBuilder.setTargetInfo(targetInfo);</span><br><span class=\"line\">            androidBuilder.setLibraryRequests(usedLibraries);</span><br><span class=\"line\"></span><br><span class=\"line\">            // Check if platform-tools are installed. We check here because realistically, all projects</span><br><span class=\"line\">            // should have platform-tools in order to build.</span><br><span class=\"line\">            ProgressIndicator progress = new ConsoleProgressIndicator();</span><br><span class=\"line\">            AndroidSdkHandler sdk = AndroidSdkHandler.getInstance(getSdkFolder());</span><br><span class=\"line\">            LocalPackage platformToolsPackage =</span><br><span class=\"line\">                    sdk.getLatestLocalPackageForPrefix(SdkConstants.FD_PLATFORM_TOOLS, true, progress);</span><br><span class=\"line\">            if (platformToolsPackage == null) &#123;</span><br><span class=\"line\">                //如果sdkLibData.useSdkDownload()就尝试下载；否则什么都不做。</span><br><span class=\"line\">                sdkLoader.installSdkTool(sdkLibData, SdkConstants.FD_PLATFORM_TOOLS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// <code>configureCustomLintChecks</code> 和 <code>configureGlobalLintTask</code> 这两个方法都跟 Lint 任务创建相关，一个在创建 Variant 对象之前调用，一个在其后调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // &quot;prepareLintJar&quot; 任务，这个任务会将 &#123;@File lint.jar&#125; 拷贝到 &#123;@File build/intermediates/lint/lint.jar&#125;。</span><br><span class=\"line\">    public void configureCustomLintChecks(@NonNull TaskFactory tasks) &#123;</span><br><span class=\"line\">        File lintJar = FileUtils.join(globalScope.getIntermediatesDir(), &quot;lint&quot;, FN_LINT_JAR);</span><br><span class=\"line\"></span><br><span class=\"line\">        AndroidTask&lt;PrepareLintJar&gt; copyLintTask =</span><br><span class=\"line\">        getAndroidTasks()</span><br><span class=\"line\">                .create(tasks, new PrepareLintJar.ConfigAction(globalScope, lintJar));</span><br><span class=\"line\">        globalScope.addTaskOutput(LINT_JAR, lintJar, copyLintTask.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void configureGlobalLintTask(@NonNull final Collection&lt;VariantScope&gt; variants) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 筛选 &#x27;non testing&#x27; &amp;&amp; &#x27;non feature&#x27; 的 BuildVariant。</span><br><span class=\"line\">        List&lt;VariantScope&gt; filteredVariants =</span><br><span class=\"line\">                variants.stream().filter(TaskManager::isLintVariant).collect(Collectors.toList());</span><br><span class=\"line\">        if (filteredVariants.isEmpty()) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建全局的 &#x27;lint&#x27; 任务。</span><br><span class=\"line\">        androidTasks.configure(</span><br><span class=\"line\">                tasks, new LintGlobalTask.GlobalConfigAction(globalScope, filteredVariants));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将 &#x27;lint.jar&#x27; 文件加入每个 BuildVariant 的输出文件集中。</span><br><span class=\"line\">        FileCollection lintJarCollection = globalScope.getOutput(LINT_JAR);</span><br><span class=\"line\">        File lintJar = lintJarCollection.getSingleFile();</span><br><span class=\"line\">        for (VariantScope scope : variants) &#123;</span><br><span class=\"line\">            scope.addTaskOutput(LINT_JAR, lintJar, PrepareLintJar.NAME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>VariantManager::createAndroidTasks()</code> 中：</p>\n<ul>\n<li><code>populateVariantDataList()</code> 创建 VariantData 对象。</li>\n<li><code>TaskManager::createTopLevelTestTasks</code> 创建一些和单元测试有关的顶层 task。</li>\n<li><code>createTasksForVariantData()</code> 创建编译相关的所有 task。</li>\n<li><code>TaskManager::createReportTasks</code> 创建输出信息的工具 task。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createAndroidTasks() &#123;</span><br><span class=\"line\">        // 这是一个抽象方法，只有在 LibraryVariantFactory 中有实现。</span><br><span class=\"line\">        // LibraryVariantFactory 的实现中，确保 BuildType 和 ProductFlavor 没有配置</span><br><span class=\"line\">        // applicationId 或 applicationIdSuffix。</span><br><span class=\"line\">        variantFactory.validateModel(this);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这又是一个抽象方法，在 BaseVariantFactory 的实现中检查，</span><br><span class=\"line\">        // 如果使用了 &#x27;android-apt&#x27; 插件，则提示开发者使用更新的 &#x27;annotationProcessor&#x27; 配置。</span><br><span class=\"line\">        variantFactory.preVariantWork(project);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 VariantData 对象。</span><br><span class=\"line\">        final TaskFactory tasks = new TaskContainerAdaptor(project.getTasks());</span><br><span class=\"line\">        if (variantScopes.isEmpty()) &#123;</span><br><span class=\"line\">            populateVariantDataList();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //@Test, 创建一些和单元测试有关的顶层 task。</span><br><span class=\"line\">        taskManager.createTopLevelTestTasks(tasks, !productFlavors.isEmpty());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建基于 BuildVariant 的编译 task。</span><br><span class=\"line\">        for (final VariantScope variantScope : variantScopes) &#123;</span><br><span class=\"line\">            createTasksForVariantData(tasks, variantScope)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一些输出信息的 task。</span><br><span class=\"line\">        taskManager.createReportTasks(tasks, variantScopes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createReportTasks(TaskFactory tasks, final List&lt;VariantScope&gt; variantScopes) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        create &quot;androidDependencies&quot; as DependencyReportTask type.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;signingReport&quot; as SigningReportTask type.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建-VariantData-对象\"><a href=\"#创建-VariantData-对象\" class=\"headerlink\" title=\"创建 VariantData 对象\"></a>创建 VariantData 对象</h4><p><code>VariantManager::populateVariantDataList()</code> 依赖开发者编译脚本的配置，生成全部 VariantData 对象，进一步完成 project 模型的搭建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void populateVariantDataList() &#123;</span><br><span class=\"line\">        List&lt;String&gt; flavorDimensionList = extension.getFlavorDimensionList();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (productFlavors.isEmpty()) &#123;</span><br><span class=\"line\">            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。</span><br><span class=\"line\">            configureDependencies();</span><br><span class=\"line\">            // 如果没有配置任何 ProductFlavor，使用空参数直接构造 VariantData 对象。</span><br><span class=\"line\">            createVariantDataForProductFlavors(Collections.emptyList());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 如果配置了 ProductFlavor，检查配置合法性，并根据配置构造 VariantData 对象。</span><br><span class=\"line\">            // 确保每个 ProductFlavor 都有 Dimension</span><br><span class=\"line\">            if (flavorDimensionList == null || flavorDimensionList.isEmpty()) &#123;</span><br><span class=\"line\">                // @Simplify 从 Android Gradle 3.0 之后，所有的 ProductFlavor 都需要有 Dimension</span><br><span class=\"line\">                // 参见：https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125; else if (flavorDimensionList.size() == 1) &#123;</span><br><span class=\"line\">                // @Simplify 如果仅有一个 Dimension，将每个没有配置 Dimension 的 ProductFlavor 设为这个唯一的 Dimension。</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 注册 Gradle Transform，用于解压缩并转移所依赖的 library 提供的 aar 文件。</span><br><span class=\"line\">            configureDependencies();</span><br><span class=\"line\"></span><br><span class=\"line\">            // 下面这两个调用生成了 flavorComboList，</span><br><span class=\"line\">            // 这个列表中的每个元素代表了一种 ProductFlavor 的组合方式</span><br><span class=\"line\">            // (按照 Dimension 从高到低的方式)</span><br><span class=\"line\">            Iterable&lt;CoreProductFlavor&gt; flavorDsl =</span><br><span class=\"line\">                    Iterables.transform(</span><br><span class=\"line\">                            productFlavors.values(),</span><br><span class=\"line\">                            ProductFlavorData::getProductFlavor);</span><br><span class=\"line\">            List&lt;ProductFlavorCombo&lt;CoreProductFlavor&gt;&gt; flavorComboList =</span><br><span class=\"line\">                    ProductFlavorCombo.createCombinations(</span><br><span class=\"line\">                            flavorDimensionList,</span><br><span class=\"line\">                            flavorDsl);</span><br><span class=\"line\">            // 以每一种 ProductFlavor 组合为输入，构造 VariantData 对象。</span><br><span class=\"line\">            for (ProductFlavorCombo&lt;CoreProductFlavor&gt;  flavorCombo : flavorComboList) &#123;</span><br><span class=\"line\">                createVariantDataForProductFlavors(</span><br><span class=\"line\">                        (List&lt;ProductFlavor&gt;) (List) flavorCombo.getFlavorList());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private void createVariantDataForProductFlavors(</span><br><span class=\"line\">            @NonNull List&lt;ProductFlavor&gt; productFlavorList) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // getVariantConfigurationTypes() 是一个抽象方法，通常情况下只会返回长度为1的列表。</span><br><span class=\"line\">        // 例如 ApplicationVariantFactory 会返回 VariantType.DEFAULT;</span><br><span class=\"line\">        // LibraryVariantFactory 会返回 VariantType.LIBRARY;</span><br><span class=\"line\">        // 这里实际上就是将 VariantType 加入构造 VariantData 的参数。</span><br><span class=\"line\">        for (VariantType variantType : variantFactory.getVariantConfigurationTypes()) &#123;</span><br><span class=\"line\">            createVariantDataForProductFlavorsAndVariantType(productFlavorList, variantType);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void createVariantDataForProductFlavorsAndVariantType(</span><br><span class=\"line\">            @NonNull List&lt;ProductFlavor&gt; productFlavorList, @NonNull VariantType variantType) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test, 在工程支持单元测试的情况下，获取单元测试的目标 BuildTypeData</span><br><span class=\"line\">        // 默认情况下单元测试的目标 BuildType 是 &#x27;debug&#x27;</span><br><span class=\"line\">        BuildTypeData testBuildTypeData = null;</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        BaseVariantData variantForAndroidTest = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        CoreProductFlavor defaultConfig = defaultConfigData.getProductFlavor();</span><br><span class=\"line\"></span><br><span class=\"line\">        Action&lt;com.android.build.api.variant.VariantFilter&gt; variantFilterAction =</span><br><span class=\"line\">                extension.getVariantFilter();</span><br><span class=\"line\"></span><br><span class=\"line\">        // @IDE</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (BuildTypeData buildTypeData : buildTypes.values()) &#123;</span><br><span class=\"line\">            boolean ignore = false;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 检查编译脚本中的 VariantFilter 配置，</span><br><span class=\"line\">            // 以确认当前的 BuildType &amp; ProductFlavor 组合是否要被忽略。</span><br><span class=\"line\">            if (variantFilterAction != null) &#123;</span><br><span class=\"line\">                variantFilter.reset(</span><br><span class=\"line\">                        defaultConfig,</span><br><span class=\"line\">                        buildTypeData.getBuildType(),</span><br><span class=\"line\">                        variantType,</span><br><span class=\"line\">                        productFlavorList);</span><br><span class=\"line\"></span><br><span class=\"line\">                variantFilterAction.execute(variantFilter);</span><br><span class=\"line\">                ignore = variantFilter.isIgnore();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (!ignore) &#123;</span><br><span class=\"line\">                // 通过 BuildType &amp; ProductFlavor 组合 创建 VariantData 对象。 </span><br><span class=\"line\">                BaseVariantData variantData =</span><br><span class=\"line\">                        createVariantDataForVariantType(</span><br><span class=\"line\">                                buildTypeData.getBuildType(),</span><br><span class=\"line\">                                productFlavorList,</span><br><span class=\"line\">                                variantType,</span><br><span class=\"line\">                                false);</span><br><span class=\"line\">                // 将 VariantScope 对象保存在 variantScopes 中。</span><br><span class=\"line\">                // VariantScope 对象和 VariantData 对象是一一对应、相互持有的关系。</span><br><span class=\"line\">                addVariant(variantData);</span><br><span class=\"line\"></span><br><span class=\"line\">                // @Simplify</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                if (variantFactory.hasTestScope()) &#123;</span><br><span class=\"line\">                    if (buildTypeData == testBuildTypeData) &#123;</span><br><span class=\"line\">                        variantForAndroidTest = variantData;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    // @Test, 创建单元测试的 VariantData 对象。</span><br><span class=\"line\">                    [+]&#123;...&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (variantForAndroidTest != null) &#123;</span><br><span class=\"line\">            //@Test, 创建单 AndroidTest 的 VariantData 对象。</span><br><span class=\"line\">            [+]&#123;...&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通过 BuildType &amp; ProductFlavor 组合 创建 VariantData 对象。 </span><br><span class=\"line\">    private BaseVariantData createVariantDataForVariantType(</span><br><span class=\"line\">            @NonNull com.android.builder.model.BuildType buildType,</span><br><span class=\"line\">            @NonNull List&lt;? extends ProductFlavor&gt; productFlavorList,</span><br><span class=\"line\">            @NonNull VariantType variantType,</span><br><span class=\"line\">            boolean componentPluginUsed) &#123;</span><br><span class=\"line\">        BuildTypeData buildTypeData = buildTypes.get(buildType.getName());</span><br><span class=\"line\">        final DefaultAndroidSourceSet sourceSet = defaultConfigData.getSourceSet();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 以 DefaultConfig 和 buildType 为基础创建 VariantConfiguration 对象，</span><br><span class=\"line\">        // 这个对象代表了 BuildType &amp; ProductFlavor 组合的配置，并且会将脚本中的的配置进行合并，确定最终的配置。</span><br><span class=\"line\">        GradleVariantConfiguration variantConfig =</span><br><span class=\"line\">            GradleVariantConfiguration.getBuilderForExtension(extension)</span><br><span class=\"line\">                .create(</span><br><span class=\"line\">                    globalScope.getProjectOptions(),</span><br><span class=\"line\">                    defaultConfigData.getProductFlavor(),</span><br><span class=\"line\">                    sourceSet,</span><br><span class=\"line\">                    getParser(sourceSet.getManifestFile()),</span><br><span class=\"line\">                    buildTypeData.getBuildType(),</span><br><span class=\"line\">                    buildTypeData.getSourceSet(),</span><br><span class=\"line\">                    variantType,</span><br><span class=\"line\">                    signingOverride);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Simplify</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 依次将 ProductFlavor 对象加入 VariantConfiguration 对象，每次加入操作都会进行配置合并，保存在 &#x27;mergedFlavor&#x27; 中。</span><br><span class=\"line\">        // 合并时大部分属性会进行覆盖，高维 ProductFlavor &gt; 低维 ProductFlavor &gt; DefaultConfig。</span><br><span class=\"line\">        // 但是 applicationIdSuffix 和 versionNameSuffix 两个配置会将各个维度与 DefaultConfig 拼接到一起。</span><br><span class=\"line\">        // 此外 JavaCompileOptions、NdkOptions 等 Options 会进行覆盖合并，BuildType &gt; 高维 ProductFlavor &gt; 低维 ProductFlavor &gt; DefaultConfig。</span><br><span class=\"line\">        for (ProductFlavor productFlavor : productFlavorList) &#123;</span><br><span class=\"line\">            ProductFlavorData&lt;CoreProductFlavor&gt; data = productFlavors.get(</span><br><span class=\"line\">                    productFlavor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">            String dimensionName = productFlavor.getDimension();</span><br><span class=\"line\">            if (dimensionName == null) &#123;</span><br><span class=\"line\">                dimensionName = &quot;&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            variantConfig.addProductFlavor(</span><br><span class=\"line\">                    data.getProductFlavor(),</span><br><span class=\"line\">                    data.getSourceSet(),</span><br><span class=\"line\">                    dimensionName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 BuildType &amp; ProductFlavor 拼接而成的 SourceSet。</span><br><span class=\"line\">        // 名字分别为 &#x27;&#123;BuildVaraintName&#125;&#123;ProductFlavorList&#125;&#x27; 和 &#x27;&#123;ProductFlavorList&#125;&#x27;。</span><br><span class=\"line\">        NamedDomainObjectContainer&lt;AndroidSourceSet&gt; sourceSetsContainer = extension.getSourceSets();</span><br><span class=\"line\">        createCompoundSourceSets(productFlavorList, variantConfig, sourceSetsContainer, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 下面的5个 step 收集了 Variant 的所有相关的 SourceSet，分别是：</span><br><span class=\"line\">        // variant-specific, build type, multi-flavor, flavor1, flavor2, ..., defaultConfig.</span><br><span class=\"line\">        // 后面会使用这些 SourceSets 创建 VariantDependencies 对象。</span><br><span class=\"line\">        final List&lt;DefaultAndroidSourceSet&gt; variantSourceSets =</span><br><span class=\"line\">                Lists.newArrayListWithExpectedSize(productFlavorList.size() + 4);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. add the variant-specific if applicable.</span><br><span class=\"line\">        if (!productFlavorList.isEmpty()) &#123;</span><br><span class=\"line\">            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getVariantSourceProvider());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. the build type.</span><br><span class=\"line\">        variantSourceSets.add(buildTypeData.getSourceSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. the multi-flavor combination</span><br><span class=\"line\">        if (productFlavorList.size() &gt; 1) &#123;</span><br><span class=\"line\">            variantSourceSets.add((DefaultAndroidSourceSet) variantConfig.getMultiFlavorSourceProvider());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. the flavors.</span><br><span class=\"line\">        for (ProductFlavor productFlavor : productFlavorList) &#123;</span><br><span class=\"line\">            variantSourceSets.add(productFlavors.get(productFlavor.getName()).getSourceSet());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 5. The defaultConfig</span><br><span class=\"line\">        variantSourceSets.add(defaultConfigData.getSourceSet());</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 BaseVariantData 对象。</span><br><span class=\"line\">        BaseVariantData variantData =</span><br><span class=\"line\">                variantFactory.createVariantData(variantConfig, taskManager, recorder);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 VariantDependencies 对象并由 BaseVariantData 对象持有。</span><br><span class=\"line\">        // 构造 VariantDependencies 对象的过程中，创建了几个新的 Configuration：</span><br><span class=\"line\">        // &#x27;&#123;VariantName&#125;CompileClasspath&#x27;，&#x27;&#123;VariantName&#125;RuntimeClasspath&#x27; 等。</span><br><span class=\"line\">        // 由于每个 SourceSet 都会对应一个 Configuration，</span><br><span class=\"line\">        // 所以以通过 variantSourceSets 参数可以获取所有与 Variant 的所有相关的 Configuration。</span><br><span class=\"line\">        // 这里新创建的 Configuration 会视情况依赖 与 Variant 的所有相关的 Configuration。</span><br><span class=\"line\">        VariantDependencies.Builder builder =</span><br><span class=\"line\">            VariantDependencies.builder(</span><br><span class=\"line\">                        project, androidBuilder.getErrorReporter(), variantConfig)</span><br><span class=\"line\">                .setConsumeType(</span><br><span class=\"line\">                        getConsumeType(variantData.getVariantConfiguration().getType()))</span><br><span class=\"line\">                .setPublishType(</span><br><span class=\"line\">                        getPublishingType(variantData.getVariantConfiguration().getType()))</span><br><span class=\"line\">                .setFlavorSelection(getFlavorSelection(variantConfig))</span><br><span class=\"line\">                .addSourceSets(variantSourceSets)</span><br><span class=\"line\">                .setBaseSplit(</span><br><span class=\"line\">                        variantType == VariantType.FEATURE &amp;&amp; extension.getBaseFeature());</span><br><span class=\"line\">        final VariantDependencies variantDep = builder.build();</span><br><span class=\"line\">        variantData.setVariantDependency(variantDep);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果需要兼容 4.x 的 MultiDex，</span><br><span class=\"line\">        // 那么添加依赖 &#x27;com.android.support:multidex:1.0.2&#x27;。</span><br><span class=\"line\">        if (variantConfig.isLegacyMultiDexMode()) &#123;</span><br><span class=\"line\">            project.getDependencies().add(</span><br><span class=\"line\">                    variantDep.getCompileClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);</span><br><span class=\"line\">            project.getDependencies().add(</span><br><span class=\"line\">                    variantDep.getRuntimeClasspath().getName(), COM_ANDROID_SUPPORT_MULTIDEX);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @RenderScript</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return variantData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private void createCompoundSourceSets(</span><br><span class=\"line\">            @NonNull List&lt;? extends ProductFlavor&gt; productFlavorList,</span><br><span class=\"line\">            @NonNull GradleVariantConfiguration variantConfig,</span><br><span class=\"line\">            @NonNull NamedDomainObjectContainer&lt;AndroidSourceSet&gt; sourceSetsContainer,</span><br><span class=\"line\">            @Nullable BaseVariantData testedVariantData) &#123;</span><br><span class=\"line\">        if (!productFlavorList.isEmpty()) &#123;</span><br><span class=\"line\">            // 创建名为 &#x27;&#123;BuildVaraintName&#125;&#123;ProductFlavorList&#125;&#x27; 的 SourceSet。</span><br><span class=\"line\">            DefaultAndroidSourceSet variantSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(</span><br><span class=\"line\">                            computeSourceSetName(</span><br><span class=\"line\">                                    variantConfig.getFullName(),</span><br><span class=\"line\">                                    variantConfig.getType()));</span><br><span class=\"line\">            variantConfig.setVariantSourceProvider(variantSourceSet);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (testedVariantData != null) &#123;</span><br><span class=\"line\">                // @Test,配置 Configuration 的依赖关系。</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (productFlavorList.size() &gt; 1) &#123;</span><br><span class=\"line\">            // 创建名为 &#x27;&#123;ProductFlavorList&#125;&#x27; 的 SourceSet。</span><br><span class=\"line\">            DefaultAndroidSourceSet multiFlavorSourceSet =</span><br><span class=\"line\">                    (DefaultAndroidSourceSet) sourceSetsContainer.maybeCreate(</span><br><span class=\"line\">                            computeSourceSetName(</span><br><span class=\"line\">                                    variantConfig.getFlavorName(),</span><br><span class=\"line\">                                    variantConfig.getType()));</span><br><span class=\"line\">            variantConfig.setMultiFlavorSourceProvider(multiFlavorSourceSet);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (testedVariantData != null) &#123;</span><br><span class=\"line\">                // @Test,配置 Configuration 的依赖关系。</span><br><span class=\"line\">                [+]&#123;...&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"VariantMananger-configureDependencies\"><a href=\"#VariantMananger-configureDependencies\" class=\"headerlink\" title=\"VariantMananger::configureDependencies()\"></a><code>VariantMananger::configureDependencies()</code></h4><p>在这个方法，通过注册 Gradle Transform 接口，解压缩并转移了所依赖 AAR 中的文件，使这些文件能够参与后续的编译过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void configureDependencies() &#123;</span><br><span class=\"line\">        final DependencyHandler dependencies = project.getDependencies();</span><br><span class=\"line\"></span><br><span class=\"line\">        // register transforms.</span><br><span class=\"line\">        final String explodedAarType = ArtifactType.EXPLODED_AAR.getType();</span><br><span class=\"line\">        dependencies.registerTransform(</span><br><span class=\"line\">                reg -&gt; &#123;</span><br><span class=\"line\">                    reg.getFrom().attribute(ARTIFACT_FORMAT, AndroidArtifacts.TYPE_AAR);</span><br><span class=\"line\">                    reg.getTo().attribute(ARTIFACT_FORMAT, explodedAarType);</span><br><span class=\"line\">                    reg.artifactTransform(ExtractAarTransform.class);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (ArtifactType transformTarget : AarTransform.getTransformTargets()) &#123;</span><br><span class=\"line\">            dependencies.registerTransform(</span><br><span class=\"line\">                    reg -&gt; &#123;</span><br><span class=\"line\">                        reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);</span><br><span class=\"line\">                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget.getType());</span><br><span class=\"line\">                        reg.artifactTransform(</span><br><span class=\"line\">                                AarTransform.class, config -&gt; config.params(transformTarget));</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dependencies.registerTransform(</span><br><span class=\"line\">                reg -&gt; &#123;</span><br><span class=\"line\">                    reg.getFrom().attribute(ARTIFACT_FORMAT, explodedAarType);</span><br><span class=\"line\">                    reg.getTo()</span><br><span class=\"line\">                            .attribute(</span><br><span class=\"line\">                                    ARTIFACT_FORMAT,</span><br><span class=\"line\">                                    ArtifactType.SYMBOL_LIST_WITH_PACKAGE_NAME.getType());</span><br><span class=\"line\">                    reg.artifactTransform(LibrarySymbolTableTransform.class);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (String transformTarget : JarTransform.getTransformTargets()) &#123;</span><br><span class=\"line\">            dependencies.registerTransform(</span><br><span class=\"line\">                    reg -&gt; &#123;</span><br><span class=\"line\">                        reg.getFrom().attribute(ARTIFACT_FORMAT, &quot;jar&quot;);</span><br><span class=\"line\">                        reg.getTo().attribute(ARTIFACT_FORMAT, transformTarget);</span><br><span class=\"line\">                        reg.artifactTransform(JarTransform.class);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        AttributesSchema schema = dependencies.getAttributesSchema();</span><br><span class=\"line\"></span><br><span class=\"line\">        // custom strategy for AndroidTypeAttr</span><br><span class=\"line\">        AttributeMatchingStrategy&lt;AndroidTypeAttr&gt; androidTypeAttrStrategy =</span><br><span class=\"line\">                schema.attribute(AndroidTypeAttr.ATTRIBUTE);</span><br><span class=\"line\">        androidTypeAttrStrategy.getCompatibilityRules().add(AndroidTypeAttrCompatRule.class);</span><br><span class=\"line\">        androidTypeAttrStrategy.getDisambiguationRules().add(AndroidTypeAttrDisambRule.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        // custom strategy for build-type and product-flavor.</span><br><span class=\"line\">        setBuildTypeStrategy(schema);</span><br><span class=\"line\"></span><br><span class=\"line\">        setupFlavorStrategy(schema);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"VariantMananger-createTasksForVariantData\"><a href=\"#VariantMananger-createTasksForVariantData\" class=\"headerlink\" title=\"VariantMananger::createTasksForVariantData()\"></a><code>VariantMananger::createTasksForVariantData()</code></h4><p><em>下面代码使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class VariantMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createTasksForVariantData(</span><br><span class=\"line\">            final TaskFactory tasks, final VariantScope variantScope) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        create &quot;assemble&#123;BuildTypeName&#125;&quot; task as anchor task. </span><br><span class=\"line\">            it &quot;Assembles all assemble&#123;BuildTypeName&#125; builds.&quot;</span><br><span class=\"line\">            let &quot;assemble&quot; dependsOn &quot;assemble&#123;BuildTypeName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建更多基于 Variant 的 assemble task. </span><br><span class=\"line\">        createAssembleTaskForVariantData(tasks, variantData);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (variantType.isForTesting()) &#123;</span><br><span class=\"line\">            // @Test，创建基于 Variant 的单元测试 task.</span><br><span class=\"line\">            [+]&#123;...&#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 创建基于 Variant 的编译 task.</span><br><span class=\"line\">            taskManager.createTasksForVariantScope(tasks, variantScope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 创建基于 Variant 的 assemble task. </span><br><span class=\"line\">    private void createAssembleTaskForVariantData(</span><br><span class=\"line\">            TaskFactory tasks, final BaseVariantData variantData) &#123;</span><br><span class=\"line\">        final VariantScope variantScope = variantData.getScope();</span><br><span class=\"line\">        if (variantData.getType().isForTesting()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            create &quot;assemble&#123;VariantName&#125;&quot; task as anchor task. </span><br><span class=\"line\">                set variantScope assemble task with it.</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (productFlavors.isEmpty()) &#123;</span><br><span class=\"line\">                set variantScope assemble task with &quot;assemble&#123;BuildTypeName&#125;&quot;.</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                create &quot;assemble&#123;VariantName&#125;&quot; task as anchor task. </span><br><span class=\"line\">                    set variantScope assemble task with it.</span><br><span class=\"line\">                    let &quot;assemble&#123;BuildTypeName&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">                for each flavor</span><br><span class=\"line\">                    create &quot;assemble&#123;ProductFlavor&#125;&quot; as anchor task.</span><br><span class=\"line\">                        set ProductFlavorData assemble task with it.</span><br><span class=\"line\">                        let  &quot;assemble&#123;ProductFlavor&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">                if (variantConfig.getProductFlavors().size() &gt; 1) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    create &quot;assmble&#123;ProductFlavorList&#125;&quot; as anchor task.</span><br><span class=\"line\">                        it &quot;Assembles all builds for flavor combination: &#123;ProductFlavorList&#125;&quot;.</span><br><span class=\"line\">                        let &quot;assmble&#123;ProductFlavorList&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    let &quot;assemble&quot; dependsOn &quot;assmble&#123;ProductFlavorList&#125;&quot;.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"TaskMananger-createTasksForVariantScope\"><a href=\"#TaskMananger-createTasksForVariantScope\" class=\"headerlink\" title=\"TaskMananger::createTasksForVariantScope()\"></a><code>TaskMananger::createTasksForVariantScope()</code></h4><p><code>TaskMananger::createTasksForVariantScope()</code> 是一个抽象方法，创建基于 Variant 的编译 task，这些编译 task 就是 android 编译 toolchain 的调用者。<br>这个方法在各个 TaskMananger 子类中实现不同，这里就选 ApplicationTaskManager 的实现来看。</p>\n<p><em>下面代码使用伪代码展现</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationTaskManager extends TaskManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createTasksForVariantScope(</span><br><span class=\"line\">            @NonNull final TaskFactory tasks, @NonNull final VariantScope variantScope) &#123;</span><br><span class=\"line\">        BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">        assert variantData instanceof ApplicationVariantData;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createAnchorTasks()</span><br><span class=\"line\">        create &quot;pre&#123;VariantName&#125;Build&quot; task as AppPreBuildTask task. </span><br><span class=\"line\">            set VariantScope prebuild task with it.</span><br><span class=\"line\">            let &quot;pre&#123;VariantName&#125;Build&quot; dependsOn &quot;preBuild&quot;.</span><br><span class=\"line\">        if enable code skrink</span><br><span class=\"line\">            let &quot;pre&#123;VariantName&#125;Build&quot; dependsOn &quot;extractProguardFiles&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;Sources&quot; as anchor task. </span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;prepareLintJar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;Resources&quot; as anchor task. </span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;Assets&quot; as anchor task. </span><br><span class=\"line\"></span><br><span class=\"line\">        // @Test，创建单元测试覆盖率报告 task。</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Sources&quot; as anchor task. </span><br><span class=\"line\">            let &quot;assemble&#123;VariantName&#125;&quot; dependsOn &quot;compile&#123;VariantName&#125;Sources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createCheckManifestTask()</span><br><span class=\"line\">        create &quot;check&#123;VariantName&#125;Manifest&quot; as CheckManifest type task. </span><br><span class=\"line\">            let &quot;check&#123;VariantName&#125;Manifest&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Wear</span><br><span class=\"line\">        handleMicroApp(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建基于依赖的 transform stream</span><br><span class=\"line\">        createDependencyStreams(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createApplicationIdWriterTask()</span><br><span class=\"line\">        create &quot;write&#123;VariantName&#125;ApplicationId&quot; as ApplicationIdWriterTask type task. </span><br><span class=\"line\">            add &quot;build/intermediates/applicationId/&#123;ProductFlavorName&#125;/&#123;BuildTypeName&#125;&quot; to VariantScope outputs.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeApkManifestsTask()</span><br><span class=\"line\">        create &quot;create&#123;VariantName&#125;CompatibleScreenManifests&quot; as CompatibleScreensManifest type task.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;process&#123;VariantName&#125;Manifest&quot; as MergeManifests type task.</span><br><span class=\"line\">            let &quot;process&#123;VariantName&#125;Manifest&quot; dependsOn &quot;check&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createGenerateResValuesTask()</span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;ResValues&quot; as GenerateResValues type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Resources&quot; dependsOn &quot;generate&#123;VariantName&#125;ResValues&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createRenderscriptTask()</span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Renderscript&quot; as RenderscriptCompile type task.</span><br><span class=\"line\">        if is testing</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Renderscript&quot; dependsOn &quot;process&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\">        else</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Renderscript&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        let &quot;generate&#123;VariantName&#125;Resources&quot; dependsOn &quot;compile&#123;VariantName&#125;Renderscript&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        if not RenderscriptNdkModeEnabled</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;compile&#123;VariantName&#125;Renderscript&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeResourcesTask()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;Resources&quot; as MergeResources type task.</span><br><span class=\"line\">            let &quot;merge&#123;VariantName&#125;Resources&quot; dependsOn &quot;generate&#123;VariantName&#125;Resources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeAssetsTask()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;Assets&quot; as MergeSourceSetFolders type task.</span><br><span class=\"line\">            let &quot;merge&#123;VariantName&#125;Assets&quot; dependsOn &quot;generate&#123;VariantName&#125;Assets&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createBuildConfigTask()</span><br><span class=\"line\">        create &quot;generate&#123;VariantName&#125;BuildConfig&quot; as GenerateBuildConfig type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;generate&#123;VariantName&#125;BuildConfig&quot;.</span><br><span class=\"line\">            if is testing</span><br><span class=\"line\">                let &quot;generate&#123;VariantName&#125;BuildConfig&quot; dependsOn &quot;process&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\">            else </span><br><span class=\"line\">                let &quot;generate&#123;VariantName&#125;BuildConfig&quot; dependsOn &quot;check&#123;VariantName&#125;Manifest&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createApkProcessResTask()</span><br><span class=\"line\">        create &quot;process&#123;VariantName&#125;Resources&quot; as ProcessAndroidResources type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;process&#123;VariantName&#125;Resources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;process&#123;VariantName&#125;JavaRes&quot; as Sync type task.</span><br><span class=\"line\">            let &quot;process&#123;VariantName&#125;JavaRes&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createAidlTask()</span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Aidl&quot; as AidlCompile type task.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Sources&quot; dependsOn &quot;compile&#123;VariantName&#125;Aidl&quot;.</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Aidl&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createShaderTask()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;Shaders&quot; as MergeSourceSetFolders type task.</span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;Shaders&quot; as ShaderCompile type task.</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;Shaders&quot; dependsOn &quot;merge&#123;VariantName&#125;Shaders&quot;.</span><br><span class=\"line\">            let &quot;generate&#123;VariantName&#125;Assets&quot; dependsOn &quot;compile&#123;VariantName&#125;Shaders&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @NDK, ndk 编译任务</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeJniLibFoldersTasks()</span><br><span class=\"line\">        create &quot;merge&#123;VariantName&#125;JniLibFolders&quot; as MergeSourceSetFolders type task.</span><br><span class=\"line\">            let &quot;merge&#123;VariantName&#125;JniLibFolders&quot; dependsOn &quot;generate&#123;VariantName&#125;Assets&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;mergedJniFolder&quot; stream</span><br><span class=\"line\">            type ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from &#123;@File &#x27;intermediates/jniLibs/&#123;VariantConfigurationDir&#125;&#x27;&#125;</span><br><span class=\"line\">            let stream depend on &quot;merge&#123;VariantName&#125;JniLibFolders&quot; task</span><br><span class=\"line\"></span><br><span class=\"line\">        // @NDK, 创建当前工程 ndk 编译产出的 so 文件以及 obj 文件 的 stream</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @RenderScript, 创建当前工程 rs 编译产物的 stream</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;transformNativeLibsWithMergeJniLibsFor&#123;VariantName&#125;&quot; task</span><br><span class=\"line\">            with &quot;mergeJniLibs&quot; transform as MergeJavaResourcesTransform type.</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES. </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // @DataBinding</span><br><span class=\"line\">        createDataBindingTasksIfNecessary(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 java 编译 task。</span><br><span class=\"line\">        addCompileTask();</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Ndk</span><br><span class=\"line\">        createStripNativeLibraryTask(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Multi</span><br><span class=\"line\">        createSplitTasks(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建打包 task。</span><br><span class=\"line\">        createPackagingTask(tasks, variantScope, buildInfoWriterTask);</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createLintTasks()</span><br><span class=\"line\">        create &quot;lint&#123;VariantName&#125;&quot; as LintPerVariantTask type.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TaskMananger::createDependencyStreams</code> 为 external 依赖（maven 或者 local jar 文件）和工程依赖创建 Android Transform stream 对象，使来自依赖的文件（主要是 class 文件）参与到 Android Transform 过程中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void createDependencyStreams(</span><br><span class=\"line\">            @NonNull TaskFactory tasks,</span><br><span class=\"line\">            @NonNull final VariantScope variantScope) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Test, 基于测试覆盖率需求，修改 Configuration</span><br><span class=\"line\">        handleJacocoDependencies(variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        TransformManager transformManager = variantScope.getTransformManager();</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;ext-libs-classes&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES</span><br><span class=\"line\">            scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            from ArtifactType.CLASSES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  </span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;ext-libs-res-plus-native&quot; stream</span><br><span class=\"line\">            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            from ArtifactType.JAVA_RES files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH  </span><br><span class=\"line\"></span><br><span class=\"line\">        // and the android AAR also have a specific jni folder</span><br><span class=\"line\">        create &quot;ext-libs-native&quot; stream</span><br><span class=\"line\">            type ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            from ArtifactType.JNI files in ArtifactScope.EXTERNAL on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // data binding related artifacts for external libs</span><br><span class=\"line\">        // @DataBinding, 创建 dataBinding 需要的 steams</span><br><span class=\"line\">        if (extension.getDataBinding().isEnabled()) &#123;</span><br><span class=\"line\">            &#123;...&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // for the sub modules, new intermediary classes artifact has its own stream</span><br><span class=\"line\">        create &quot;sub-projects-classes&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES</span><br><span class=\"line\">            scope Scope.SUB_PROJECTS</span><br><span class=\"line\">            from ArtifactType.CLASSES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // same for the resources which can be java-res or jni</span><br><span class=\"line\">        create &quot;sub-projects-res-plus-native&quot; stream</span><br><span class=\"line\">            type DefaultContentType.RESOURCES, ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.SUB_PROJECTS</span><br><span class=\"line\">            from ArtifactType.JAVA_RES files in ArtifactScope.MODULE on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // and the android library sub-modules also have a specific jni folder</span><br><span class=\"line\">        create &quot;sub-projects-native&quot; stream</span><br><span class=\"line\">            type ExtendedContentType.NATIVE_LIBS</span><br><span class=\"line\">            scope Scope.SUB_PROJECTS</span><br><span class=\"line\">            from ArtifactType.JNI files in ArtifactScope.MODULE on RUNTIME_CLASSPATH</span><br><span class=\"line\"></span><br><span class=\"line\">        // provided only scopes.</span><br><span class=\"line\">        create &quot;provided-classes&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES</span><br><span class=\"line\">            scope Scope.PROVIDED_ONLY</span><br><span class=\"line\">            from ArtifactType.JNI files in ArtifactScope.MODULE on (COMPILE_CLASSPATH minus RUNTIME_CLASSPATH)</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Test,  创建 test 需要的 steams</span><br><span class=\"line\">        if (variantScope.getTestedVariantData() != null) &#123;</span><br><span class=\"line\">            &#123;...&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>compile 任务创建流程: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationTaskManager extends TaskManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    private void addCompileTask(@NonNull TaskFactory tasks, @NonNull VariantScope variantScope) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @DataBinding</span><br><span class=\"line\">        createDataBindingMergeArtifactsTaskIfNecessary(tasks, variantScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createJavacTask()</span><br><span class=\"line\">        create &quot;javaPreCompile&#123;VariantName&#125;&quot; as JavaPreCompileTask type.</span><br><span class=\"line\">            let &quot;javaPreCompile&#123;VariantName&#125;&quot; dependsOn &quot;pre&#123;VariantName&#125;Build&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;compile&#123;VariantName&#125;JavaWithJavac&quot; as AndroidJavaCompile type.</span><br><span class=\"line\">            let &quot;compile&#123;VariantName&#125;JavaWithJavac&quot; dependsOn &quot;generate&#123;VariantName&#125;Sources&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Create the classes artifact for uses by external test modules.</span><br><span class=\"line\">        create &quot;bundleAppClasses&#123;VariantName&#125;&quot; as Jar type.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // @Java8，一些基于 java8 配置的 validation 工作。</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in addJavacClassesStream(variantScope)</span><br><span class=\"line\">        create &quot;javac-output&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from JAVAC output on variantScope</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;pre-javac-generated-bytecode&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from PreJavacGeneratedBytecode</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;post-javac-generated-bytecode&quot; stream</span><br><span class=\"line\">            type DefaultContentType.CLASSES, DefaultContentType.RESOURCES</span><br><span class=\"line\">            scope Scope.PROJECT</span><br><span class=\"line\">            from PostJavacGeneratedBytecode</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        // in setJavaCompilerTask()</span><br><span class=\"line\">        let &quot;compile&#123;VariantName&#125;Sources&quot; dependsOn &quot;compile&#123;VariantName&#125;JavaWithJavac&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建生成 dex 相关的 task。</span><br><span class=\"line\">        createPostCompilationTasks(tasks, variantScope);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskMananger &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createPostCompilationTasks(</span><br><span class=\"line\">            @NonNull TaskFactory tasks,</span><br><span class=\"line\">            @NonNull final VariantScope variantScope) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        checkNotNull(variantScope.getJavacTask());</span><br><span class=\"line\"></span><br><span class=\"line\">        final BaseVariantData variantData = variantScope.getVariantData();</span><br><span class=\"line\">        final GradleVariantConfiguration config = variantData.getVariantConfiguration();</span><br><span class=\"line\"></span><br><span class=\"line\">        TransformManager transformManager = variantScope.getTransformManager();</span><br><span class=\"line\">        // ---- Code Coverage first -----</span><br><span class=\"line\">        </span><br><span class=\"line\">        // @Test，创建测试覆盖率相关的 transform</span><br><span class=\"line\">        if (isTestCoverageEnabled) &#123;</span><br><span class=\"line\">            createJacocoTransform(tasks, variantScope);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in maybeCreateDesugarTask(tasks, variantScope, config.getMinSdkVersion(), transformManager)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果 java8 支持使用 desuger</span><br><span class=\"line\">        if (variantScope.getJava8LangSupportType() == Java8LangSupport.DESUGAR) &#123;</span><br><span class=\"line\">            create &quot;transformClassWithStackFramesFixerFor&#123;VariantName&#125;&quot; task </span><br><span class=\"line\">                with &quot;stackFramesFixer&quot; transform as FixStackFramesTransform type.</span><br><span class=\"line\">                on Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">            create &quot;transformClassWithDesugarFor&#123;VariantName&#125;&quot; task as TransformTask</span><br><span class=\"line\">                with &quot;desugar&quot; transform as DesugarTransform type.</span><br><span class=\"line\">                on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">            // 如果 minSdk.getFeatureLevel() 小于 19</span><br><span class=\"line\">            if (minSdk.getFeatureLevel()</span><br><span class=\"line\">                    &lt; DesugarProcessBuilder.MIN_SUPPORTED_API_TRY_WITH_RESOURCES) &#123;</span><br><span class=\"line\">                create &quot;extractTryWithResourcesSupportJar&#123;VariantName&#125;&quot; as ExtractTryWithResourcesSupportJar type.</span><br><span class=\"line\">                    let &#123;@File &#x27;intermediates/processing-tools/runtime-deps/&#123;VariantConfigurationDir&#125;/desugar_try_with_resources.jar&#x27;&#125; depend on &quot;extractTryWithResourcesSupportJar&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">                create &#x27;runtime-deps-try-with-resources&#x27; stream</span><br><span class=\"line\">                    type DefaultContentType.CLASSES</span><br><span class=\"line\">                    scope Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">                    from &#123;@File &#x27;intermediates/processing-tools/runtime-deps/&#123;VariantConfigurationDir&#125;/desugar_try_with_resources.jar&#x27;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        AndroidConfig extension = variantScope.getGlobalScope().getExtension();</span><br><span class=\"line\"></span><br><span class=\"line\">        // in createMergeJavaResTransform(tasks, variantScope)</span><br><span class=\"line\">        create &#x27;transformResourcesWithMergeJavaResFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with &#x27;mergeJavaRes&#x27; transform as MergeJavaResourcesTransform type</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES </span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        // 处理开发者自行注册的 transform</span><br><span class=\"line\">        // ----- External Transforms -----</span><br><span class=\"line\">        // apply all the external transforms.</span><br><span class=\"line\">        List&lt;Transform&gt; customTransforms = extension.getTransforms();</span><br><span class=\"line\">        List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0, count = customTransforms.size(); i &lt; count; i++) &#123;</span><br><span class=\"line\">            Transform transform = customTransforms.get(i);</span><br><span class=\"line\"></span><br><span class=\"line\">            List&lt;Object&gt; deps = customTransformsDependencies.get(i);</span><br><span class=\"line\">            transformManager</span><br><span class=\"line\">                    .addTransform(tasks, variantScope, transform)</span><br><span class=\"line\">                    .ifPresent(t -&gt; &#123;</span><br><span class=\"line\">                        if (!deps.isEmpty()) &#123;</span><br><span class=\"line\">                            t.dependsOn(tasks, deps);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        // if the task is a no-op then we make assemble task depend on it.</span><br><span class=\"line\">                        if (transform.getScopes().isEmpty()) &#123;</span><br><span class=\"line\">                            variantScope.getAssembleTask().dependsOn(tasks, t);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @IDE </span><br><span class=\"line\">        // ----- Android studio profiling transforms</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建包大小压缩的 transform</span><br><span class=\"line\">        // ----- Minify next -----</span><br><span class=\"line\">        // in maybeCreateJavaCodeShrinkerTransform(tasks, variantScope)</span><br><span class=\"line\">        create &#x27;transformClassAndResourcesWithProguardFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with &#x27;proguard&#x27; as ProGuardTransform type</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">        create &#x27;transformClassWithAndroidGradleClassShrinkerFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with &#x27;androidGradleClassShrinker&#x27; as BuiltInShrinkerTransform type</span><br><span class=\"line\">            on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\"></span><br><span class=\"line\">        create &#x27;check&#123;VariantName&#125;ProguardFiles&#x27; as CheckProguardFiles type</span><br><span class=\"line\">            let &#x27;transformClassAndResourcesWithProguardFor&#123;VariantName&#125;&#x27; or &#x27;transformClassWithAndroidGradleClassShrinkerFor&#123;VariantName&#125;&#x27; depend on &#x27;check&#123;VariantName&#125;ProguardFiles&#x27;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // in  maybeCreateResourcesShrinkerTransform(tasks, variantScope)</span><br><span class=\"line\">        create &#x27;transformClassWithShrinkResFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">            with shrinkRes transform as ShrinkResourcesTransform type</span><br><span class=\"line\">            on empty scope</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        // ----- 10x support</span><br><span class=\"line\">        [+] &#123;...&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ----- Multi-Dex support</span><br><span class=\"line\"></span><br><span class=\"line\">        DexingType dexingType = variantScope.getDexingType();</span><br><span class=\"line\"></span><br><span class=\"line\">        // Upgrade from legacy multi-dex to native multi-dex if possible when using with a device</span><br><span class=\"line\">        if (dexingType == DexingType.LEGACY_MULTIDEX) &#123;</span><br><span class=\"line\">            if (variantScope.getVariantConfiguration().isMultiDexEnabled()</span><br><span class=\"line\">                    &amp;&amp; variantScope</span><br><span class=\"line\">                                    .getVariantConfiguration()</span><br><span class=\"line\">                                    .getMinSdkVersionWithTargetDeviceApi()</span><br><span class=\"line\">                                    .getFeatureLevel()</span><br><span class=\"line\">                            &gt;= 21) &#123;</span><br><span class=\"line\">                dexingType = DexingType.NATIVE_MULTIDEX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;AndroidTask&lt;TransformTask&gt;&gt; multiDexClassListTask;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (dexingType == DexingType.LEGACY_MULTIDEX) &#123;</span><br><span class=\"line\">            boolean proguardInPipeline = variantScope.getCodeShrinker() == CodeShrinker.PROGUARD;</span><br><span class=\"line\"></span><br><span class=\"line\">            // If ProGuard will be used, we&#x27;ll end up with a &quot;fat&quot; jar anyway. If we&#x27;re using the</span><br><span class=\"line\">            // new dexing pipeline, we&#x27;ll use the new MainDexListTransform below, so there&#x27;s no need</span><br><span class=\"line\">            // for merging all classes into a single jar.</span><br><span class=\"line\">            if (!proguardInPipeline &amp;&amp; !usingIncrementalDexing(variantScope)) &#123;</span><br><span class=\"line\">                // Create a transform to jar the inputs into a single jar. Merge the classes only,</span><br><span class=\"line\">                // no need to package the resources since they are not used during the computation.</span><br><span class=\"line\">                 create &#x27;transformClassWithJarMergingFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with jarMerging transform as JarMergingTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // ---------</span><br><span class=\"line\">            // create the transform that&#x27;s going to take the code and the proguard keep list</span><br><span class=\"line\">            // from above and compute the main class list.</span><br><span class=\"line\">            Transform multiDexTransform;</span><br><span class=\"line\">            if (usingIncrementalDexing(variantScope)) &#123;</span><br><span class=\"line\">                create &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with multidexlist transform as MainDexListTransform type</span><br><span class=\"line\">                    on empty scope</span><br><span class=\"line\">                    set multiDexTransform with it</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                create &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with multidexlist transform as MultiDexTransform type</span><br><span class=\"line\">                    on empty scope</span><br><span class=\"line\">                    set multiDexTransform with it</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            multiDexClassListTask =</span><br><span class=\"line\">                    transformManager.addTransform(tasks, variantScope, multiDexTransform);</span><br><span class=\"line\">            multiDexClassListTask.ifPresent(variantScope::addColdSwapBuildTask);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            multiDexClassListTask = Optional.empty();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (usingIncrementalDexing(variantScope)) &#123;</span><br><span class=\"line\">            // in createNewDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)</span><br><span class=\"line\">            create &#x27;transformClassWithDexBuilderFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with dexBuilder transform as DexArchiveBuilderTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\"></span><br><span class=\"line\">            if (dexingType != DexingType.LEGACY_MULTIDEX</span><br><span class=\"line\">                &amp;&amp; variantScope.getCodeShrinker() == null</span><br><span class=\"line\">                &amp;&amp; extension.getTransforms().isEmpty()) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                create &#x27;transformDexArchiveWithExternalLibsDexMergerFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with externalLibsDexMerger transform as ExternalLibsMergerTransform type</span><br><span class=\"line\">                    on Scope.EXTERNAL_LIBRARIES</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            create &#x27;transformDexArchiveWithDexMergerFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with dexMerger transform as DexMergerTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\">            let &#x27;transformDexWithDexMergerFor&#123;VariantName&#125;&#x27; depend on &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // in createDexTasks(tasks, variantScope, multiDexClassListTask.orElse(null), dexingType)</span><br><span class=\"line\"></span><br><span class=\"line\">            if (preDexEnabled) &#123;</span><br><span class=\"line\">                create &#x27;transformClassWithPreDexFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with preDex transform as PreDexTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (!preDexEnabled || dexingType != DexingType.NATIVE_MULTIDEX) &#123;</span><br><span class=\"line\">                // run if non native multidex or no pre-dexing</span><br><span class=\"line\">                create &#x27;transformClassWithDexFor&#123;VariantName&#125;&#x27; task</span><br><span class=\"line\">                    with dex transform as DexTransform type</span><br><span class=\"line\">                    on Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES, InternalScope.MAIN_SPLIT</span><br><span class=\"line\"></span><br><span class=\"line\">                let &#x27;transformClassWithDexFor&#123;VariantName&#125;&#x27; depend on &#x27;transformClassWithMultidexlistFor&#123;VariantName&#125;&#x27;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>package 任务创建流程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskManager &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void createPackagingTask(</span><br><span class=\"line\">            @NonNull TaskFactory tasks,</span><br><span class=\"line\">            @NonNull VariantScope variantScope,</span><br><span class=\"line\">            @Nullable AndroidTask&lt;BuildInfoWriterTask&gt; fullBuildInfoGeneratorTask) &#123;</span><br><span class=\"line\">        ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();</span><br><span class=\"line\"></span><br><span class=\"line\">        boolean signedApk = variantData.isSigned();</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;package&#123;VariantName&#125;&quot; as PackageApplication type.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;merge&#123;VariantName&#125;Assets&quot;.</span><br><span class=\"line\">        let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;process&#123;VariantName&#125;Resources&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;validateSigning&#123;VariantName&#125;&quot; as ValidateSigningTask type.</span><br><span class=\"line\">            let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;validateSigning&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        let &quot;package&#123;VariantName&#125;&quot; dependsOn &quot;compile&#123;VariantName&#125;JavaWithJavac&quot;.</span><br><span class=\"line\">        let &quot;assemble&#123;VariantName&#125;&quot; dependsOn package&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // @InstantRun</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // @Multi</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (signedApk) &#123;</span><br><span class=\"line\">            create &quot;install&#123;VariantName&#125;&quot; as InstallVariantTask type.</span><br><span class=\"line\">                let &quot;install&#123;VariantName&#125;&quot; dependsOn &quot;assemble&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // in maybeCreateLintVitalTask()</span><br><span class=\"line\">        create &quot;lintVital&#123;VariantName&#125;&quot; as LintPerVariantTask type.</span><br><span class=\"line\">            let &quot;lintVital&#123;VariantName&#125;&quot; dependsOn &quot;compile&#123;VariantName&#125;JavaWithJavac&quot;.</span><br><span class=\"line\">        let &quot;assemble&#123;VariantName&#125;&quot; dependsOn &quot;lintVital&#123;VariantName&#125;&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果任务树中包含 &quot;lint&quot;，就不再执行 &quot;lintVital&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">        project.getGradle().getTaskGraph().whenReady(</span><br><span class=\"line\">            taskGraph -&gt; &#123;</span><br><span class=\"line\">                if (taskGraph.hasTask(getTaskPath(LINT))) &#123;</span><br><span class=\"line\">                    project.getTasks()</span><br><span class=\"line\">                            .getByName(lintReleaseCheck.getName())</span><br><span class=\"line\">                            .setEnabled(false);</span><br><span class=\"line\">                &#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        create &quot;uninstall&#123;VariantName&#125;&quot; as UninstallTask type.</span><br><span class=\"line\">            let &quot;uninstallAll&quot; dependsOn &quot;uninstall&#123;VariantName&#125;&quot;.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ApiObjectFactory-create\"><a href=\"#ApiObjectFactory-create\" class=\"headerlink\" title=\"ApiObjectFactory.create()\"></a><code>ApiObjectFactory.create()</code></h4><p>基于 BaseVariantData 对象创建 BaseVariantImpl 对象, 并将 BaseVariantImpl 对象加入 extension 的容器中，到这里 project 模型的搭建完成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public BaseVariantImpl create(BaseVariantData variantData) &#123;</span><br><span class=\"line\">    if (variantData.getType().isForTesting()) &#123;</span><br><span class=\"line\">        // Testing variants are handled together with their &quot;owners&quot;.</span><br><span class=\"line\">        createVariantOutput(variantData, null);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BaseVariantImpl variantApi =</span><br><span class=\"line\">        variantFactory.createVariantApi(</span><br><span class=\"line\">            instantiator,</span><br><span class=\"line\">            objectFactory,</span><br><span class=\"line\">            androidBuilder,</span><br><span class=\"line\">            variantData,</span><br><span class=\"line\">            readOnlyObjectProvider);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (variantApi == null) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // @Test</span><br><span class=\"line\">    if (variantFactory.hasTestScope()) &#123;</span><br><span class=\"line\">        // 创建 TestVariantImpl 对象和 UnitTestVariantImpl 对象</span><br><span class=\"line\">        [+]&#123;...&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // in createVariantOutput(variantData, variantApi)</span><br><span class=\"line\">    // 创建 VariantOutputFactory 对象</span><br><span class=\"line\">    variantData.variantOutputFactory =</span><br><span class=\"line\">        new VariantOutputFactory(</span><br><span class=\"line\">            (variantData.getType() == LIBRARY)</span><br><span class=\"line\">                    ? LibraryVariantOutputImpl.class</span><br><span class=\"line\">                    : ApkVariantOutputImpl.class,</span><br><span class=\"line\">            instantiator,</span><br><span class=\"line\">            extension,</span><br><span class=\"line\">            variantApi,</span><br><span class=\"line\">            variantData);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修改 apk 输出的的 versionCode 和 versionName</span><br><span class=\"line\">    variantData</span><br><span class=\"line\">            .getOutputScope()</span><br><span class=\"line\">            .getApkDatas()</span><br><span class=\"line\">            .forEach(</span><br><span class=\"line\">                apkData -&gt; &#123;</span><br><span class=\"line\">                    apkData.setVersionCode(</span><br><span class=\"line\">                        variantData.getVariantConfiguration().getVersionCode());</span><br><span class=\"line\">                    apkData.setVersionName(</span><br><span class=\"line\">                        variantData.getVariantConfiguration().getVersionName());</span><br><span class=\"line\">                    variantData.variantOutputFactory.create(apkData);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将 BaseVariantImpl 对象置入 extension 的 variantList 容器中</span><br><span class=\"line\">    // Only add the variant API object to the domain object set once it&#x27;s been fully</span><br><span class=\"line\">    // initialized.</span><br><span class=\"line\">    extension.addVariant(variantApi);</span><br><span class=\"line\"></span><br><span class=\"line\">    return variantApi;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Android-Transform-体系\"><a href=\"#Android-Transform-体系\" class=\"headerlink\" title=\"Android Transform 体系\"></a>Android Transform 体系</h3><h2 id=\"附表\"><a href=\"#附表\" class=\"headerlink\" title=\"附表\"></a>附表</h2><h3 id=\"android-plugin-支持的-gradle-properties\"><a href=\"#android-plugin-支持的-gradle-properties\" class=\"headerlink\" title=\"android plugin 支持的 gradle properties\"></a>android plugin 支持的 gradle properties</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckq0lr4oo00013mrfae9d920p","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002i3mrf3cfv34vi"},{"post_id":"ckq0lr4os00033mrf793oewhz","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002k3mrfbea09acw"},{"post_id":"ckq0lr4os00053mrfdk1rb7nf","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002m3mrf986ibbxd"},{"post_id":"ckq0lr4ou00073mrffne69zn3","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002o3mrf2s65giui"},{"post_id":"ckq0lr4ou00083mrf0xqo5fmy","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002q3mrff5fp132g"},{"post_id":"ckq0lr4ov00093mrfafiz1nf6","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002s3mrf1r11dlwo"},{"post_id":"ckq0lr4ov000a3mrfhkr699zx","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002u3mrf4uds0641"},{"post_id":"ckq0lr4ov000b3mrfdu3o5lec","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pv002w3mrfco9w310k"},{"post_id":"ckq0lr4ow000c3mrf4at855u9","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw002y3mrf7m4yar5h"},{"post_id":"ckq0lr4ow000d3mrf4vqo2vzc","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw00303mrf3vmoha9y"},{"post_id":"ckq0lr4ox000e3mrffsemfh8n","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw00323mrfdthuaoak"},{"post_id":"ckq0lr4ox000f3mrf3zbobrq7","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw00343mrf5xfcast3"},{"post_id":"ckq0lr4oy000g3mrfgrac3axr","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw00363mrfhojv4qzz"},{"post_id":"ckq0lr4oy000h3mrfbn50ckhn","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw00383mrf0vuqcy9e"},{"post_id":"ckq0lr4oy000i3mrf532n4omi","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw003a3mrf656q2l6s"},{"post_id":"ckq0lr4oz000j3mrf7v0i76lj","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw003c3mrffioz4t4s"},{"post_id":"ckq0lr4p1000k3mrfejq98498","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw003e3mrf8dniecvn"},{"post_id":"ckq0lr4p1000l3mrf23ad0n29","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4pw003g3mrf169vemun"},{"post_id":"ckq0lr4p1000m3mrf1pyw15pi","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003i3mrfa7jjc18t"},{"post_id":"ckq0lr4p2000n3mrf8xey78hp","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003k3mrfdxjdchm8"},{"post_id":"ckq0lr4p2000o3mrf8g7q1aqn","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003m3mrf123ieej8"},{"post_id":"ckq0lr4p3000p3mrfht575ztj","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003o3mrfc1nt1x9o"},{"post_id":"ckq0lr4p3000q3mrf71ve7jpm","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003q3mrf1yoc5b1e"},{"post_id":"ckq0lr4p3000r3mrf773jcvim","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003s3mrf51k51ysd"},{"post_id":"ckq0lr4p4000s3mrffzfv5pzw","category_id":"ckq0lr4p9000x3mrf8cqefvds","_id":"ckq0lr4px003u3mrfbpkw6dte"},{"post_id":"ckq0lr4p4000t3mrfgmrh0c0u","category_id":"ckq0lr4pr002b3mrf492x2bjc","_id":"ckq0lr4px003w3mrfgv2wcrzk"},{"post_id":"ckq0lr4p4000u3mrf044jg0p7","category_id":"ckq0lr4pr002b3mrf492x2bjc","_id":"ckq0lr4px003y3mrfdd2a6l64"},{"post_id":"ckq0lr4p5000v3mrffqw48pz6","category_id":"ckq0lr4pr002b3mrf492x2bjc","_id":"ckq0lr4py00403mrfddo065te"},{"post_id":"ckq0lr4pz00413mrf11r1ci7p","category_id":"ckq0lr4q000423mrf1fl8cq2t","_id":"ckq0lr4q000443mrfblukdbsr"}],"PostTag":[{"post_id":"ckq0lr4oo00013mrfae9d920p","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pv002h3mrfdaos9bti"},{"post_id":"ckq0lr4os00033mrf793oewhz","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4pv002j3mrf77y5b3g3"},{"post_id":"ckq0lr4os00053mrfdk1rb7nf","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4pv002l3mrf8d09abgh"},{"post_id":"ckq0lr4ou00073mrffne69zn3","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4pv002n3mrf8bpyb1no"},{"post_id":"ckq0lr4ou00083mrf0xqo5fmy","tag_id":"ckq0lr4ph00163mrf974v4r1l","_id":"ckq0lr4pv002p3mrffw593hk3"},{"post_id":"ckq0lr4ov00093mrfafiz1nf6","tag_id":"ckq0lr4ph00163mrf974v4r1l","_id":"ckq0lr4pv002r3mrf7wg2cg93"},{"post_id":"ckq0lr4ov000a3mrfhkr699zx","tag_id":"ckq0lr4pi001a3mrfd4jlaefn","_id":"ckq0lr4pv002t3mrfb839dex0"},{"post_id":"ckq0lr4ov000b3mrfdu3o5lec","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pv002v3mrfglmx8nwy"},{"post_id":"ckq0lr4ow000c3mrf4at855u9","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw002x3mrf2ccm3shs"},{"post_id":"ckq0lr4ow000d3mrf4vqo2vzc","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw002z3mrf12dp72ph"},{"post_id":"ckq0lr4ox000e3mrffsemfh8n","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw00313mrfagq5bjvx"},{"post_id":"ckq0lr4ox000f3mrf3zbobrq7","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw00333mrf4x5b1in7"},{"post_id":"ckq0lr4oy000g3mrfgrac3axr","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw00353mrfbydqfamc"},{"post_id":"ckq0lr4oy000h3mrfbn50ckhn","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw00373mrf38h9b299"},{"post_id":"ckq0lr4oy000i3mrf532n4omi","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw00393mrfc51zfrjf"},{"post_id":"ckq0lr4oz000j3mrf7v0i76lj","tag_id":"ckq0lr4pe000y3mrf69ww6k1p","_id":"ckq0lr4pw003b3mrf1l1ef4ve"},{"post_id":"ckq0lr4p1000k3mrfejq98498","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4pw003d3mrfck4t3qf6"},{"post_id":"ckq0lr4p1000l3mrf23ad0n29","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4pw003f3mrf7mt57sqe"},{"post_id":"ckq0lr4p1000m3mrf1pyw15pi","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4pw003h3mrffmeeh143"},{"post_id":"ckq0lr4p2000n3mrf8xey78hp","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003j3mrfdhl6cp4d"},{"post_id":"ckq0lr4p2000o3mrf8g7q1aqn","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003l3mrf9665fszh"},{"post_id":"ckq0lr4p3000p3mrfht575ztj","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003n3mrf9kk51bqr"},{"post_id":"ckq0lr4p3000q3mrf71ve7jpm","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003p3mrf68ug4hct"},{"post_id":"ckq0lr4p3000r3mrf773jcvim","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003r3mrf8k8l0tia"},{"post_id":"ckq0lr4p4000s3mrffzfv5pzw","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003t3mrf9ys231dl"},{"post_id":"ckq0lr4p4000t3mrfgmrh0c0u","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003v3mrf8aay2r42"},{"post_id":"ckq0lr4p4000u3mrf044jg0p7","tag_id":"ckq0lr4ps002e3mrfa5qv1m7l","_id":"ckq0lr4px003x3mrf0c5h8qx0"},{"post_id":"ckq0lr4p5000v3mrffqw48pz6","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4px003z3mrfdnfa0aqg"},{"post_id":"ckq0lr4pz00413mrf11r1ci7p","tag_id":"ckq0lr4pf00103mrf79e347bf","_id":"ckq0lr4q000433mrf6s1o5riu"}],"Tag":[{"name":"Java","_id":"ckq0lr4pe000y3mrf69ww6k1p"},{"name":"Android","_id":"ckq0lr4pf00103mrf79e347bf"},{"name":"Gradle","_id":"ckq0lr4ph00163mrf974v4r1l"},{"name":"design","_id":"ckq0lr4pi001a3mrfd4jlaefn"},{"name":"Git","_id":"ckq0lr4ps002e3mrfa5qv1m7l"}]}}
